<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Flutter 3-5】Flutter进阶教程——在Flutter中使用Lottie动画</title>
      <link href="flutter-high-lottie-3-5.html"/>
      <url>flutter-high-lottie-3-5.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="Lottie动画"><a href="#Lottie动画" class="headerlink" title="Lottie动画"></a>Lottie动画</h4><p>在移动开发中总是需要展示一些动画特效，作为程序员的我们并不是很擅长用代码做动画，即便是有些动画可以实现，在跨平台的过程中也会因为API的差异性导致动画在各个平台中展示的有差异。<br>所以为了释放程序员的双手，不再陷入写动画调参数的苦恼，Airbnb开源了一款专门用于跨平台的动画解决方案：<code>Lottie</code>。<br><code>Lottie</code>可以解析使用Bodymovin导出为json的Adobe After Effects动画，并在移动端和Web端展示。这样我们就可以把做动画的工作交给专业做动画的同事来完成，我们只需要使用导入json文件即可，这样是不是大大减少了程序员的工作量，并且能够：实现专业的人做专业的事。</p><h4 id="导入Lottie框架"><a href="#导入Lottie框架" class="headerlink" title="导入Lottie框架"></a>导入Lottie框架</h4><p>在Flutter中已经存在开源的<a href="https://pub.dev/packages/lottie">Lottie库</a>，所以我们只需要在<code>pubspec.yaml</code>中的<code>dependencies</code>导入相关的依赖即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">lottie:</span> <span class="string">^0.7.0</span>              </span><br></pre></td></tr></table></figure><h4 id="使用Lottie库"><a href="#使用Lottie库" class="headerlink" title="使用Lottie库"></a>使用Lottie库</h4><p>在需要展示Lottie动画Widget导入头文件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lottie/lottie.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="默认读取本地json文件"><a href="#默认读取本地json文件" class="headerlink" title="默认读取本地json文件"></a>默认读取本地json文件</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lottie.asset(<span class="string">&quot;json/fun_do_like.json&quot;</span>),</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_04_21_lottie_nomail.gif" alt="2021_04_21_lottie_nomail"><br>只需要一句话即可展示Lottie动画，是不是很简单。<br>我们来看其他的属性</p><ul><li>repeat 是否重复执行。默认是true，如果是false，动画执行一遍就会停止</li><li>reverse 是否倒序播放。默认是false，如果设置为true，动画会先正序播放一遍，然后再倒序播放一遍</li><li>animate 是否允许播放动画。默认是true，如果设置为false，则不会播放动画</li></ul><h4 id="从网络读取json文件"><a href="#从网络读取json文件" class="headerlink" title="从网络读取json文件"></a>从网络读取json文件</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lottie.network(<span class="string">&quot;https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/lottie_test.json&quot;</span>,),</span><br></pre></td></tr></table></figure><p>同样我们可以设置获取到网络资源后的回调</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lottie.network(<span class="string">&quot;https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/lottie_test.json&quot;</span>,</span><br><span class="line">    onLoaded: (LottieComposition composition) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;onLoaded&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>好了，关于<code>Lottie</code>的使用就总结这些了。</p><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>lottie_demo_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter lottie </tag>
            
            <tag> Lottie 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薅羊毛利器——Loon Cookie放在本地一点也不担心</title>
      <link href="tips-loon-10.html"/>
      <url>tips-loon-10.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="Loon"><a href="#Loon" class="headerlink" title="Loon"></a>Loon</h4><p><a href="https://apps.apple.com/us/app/loon/id1373567447">Loon</a>是一款在iOS系统下的代理工具(<strong>目前还没有Android版本</strong>)，它支持在本地执行js脚本，只需简单配置即可成为薅羊毛利器</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><ul><li>可以去美区AppStore下载，价格$4.99，需要有一个美区的AppleId账号，并且充值美元</li><li>可以去某宝或拼夕夕搜索并购买，价格大概在￥9.99</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_1.jpg" alt="2022_01_27_jd_loon_1"><br>然后将下面 框里面的配置赋值粘贴进去，点击保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line"><span class="comment"># IPv6 支持</span></span><br><span class="line">ipv6 = <span class="literal">false</span></span><br><span class="line"><span class="comment">## skip-proxy和bypass-tun 一般不需要做改动,除非你自己知道自己在做什么</span></span><br><span class="line"><span class="comment"># 需要跳过代理的IP段及其域名,其中的域名和IP段将不会在通过规则匹配</span></span><br><span class="line">skip-proxy = 127.0.0.1,192.168.0.0/16,10.0.0.0/8,172.16.0.0/12,100.64.0.0/10,localhost,*.<span class="built_in">local</span>,passenger.t3go.cn,passenger.t3go.cn</span><br><span class="line"><span class="comment"># 设置不通过tun的域名和IP,同上所在内容将不会走规则匹配</span></span><br><span class="line">bypass-tun = 10.0.0.0/8,100.64.0.0/10,127.0.0.0/8,169.254.0.0/16,172.16.0.0/12,192.0.0.0/24,192.0.2.0/24,192.88.99.0/24,192.168.0.0/16,198.18.0.0/15,198.51.100.0/24,203.0.113.0/24,224.0.0.0/4,255.255.255.255/32</span><br><span class="line"><span class="comment"># DNS 服务器</span></span><br><span class="line"><span class="comment"># Loon将并行查询所有dns,使用最快返回的IP进行网络访问和分流判断</span></span><br><span class="line"><span class="comment"># 配置DNS服务器IP,不推荐8.8.8.8和1.1.1.1等国外dns提供商,这些并不会提高国外访问稳定性,并且会导致国内域名的dns查询变慢</span></span><br><span class="line"><span class="comment"># 需要使用WIFI和运营商分配的dns可以添加[system],例如dns-server=system,119.29.29.29</span></span><br><span class="line"><span class="comment"># system和公共IP必须二选一填写</span></span><br><span class="line">dns-server = 119.29.29.29,223.5.5.5</span><br><span class="line"><span class="comment"># 允许UDP代理</span></span><br><span class="line"><span class="comment"># 实际需要节点支持,和在节点中开启UDP</span></span><br><span class="line">allow-udp-proxy = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 局域网共享</span></span><br><span class="line"><span class="comment"># 为局域网设备共享HTTP和SOCKS代理</span></span><br><span class="line">allow-wifi-access = <span class="literal">false</span></span><br><span class="line">wifi-access-http-port = 7890</span><br><span class="line">wifi-access-socket5-port = 7891</span><br><span class="line"><span class="comment"># 代理测速 URL</span></span><br><span class="line"><span class="comment"># 用于节点的可用性检测</span></span><br><span class="line">proxy-test-url = http://www.gstatic.com/generate_204</span><br><span class="line"><span class="comment"># 检测超时时间</span></span><br><span class="line">test-timeout = 5</span><br><span class="line"><span class="comment"># 返回真实IP</span></span><br><span class="line"><span class="comment"># 对一下域名不再返回FakeIP 一般不需要添加和修改</span></span><br><span class="line">real-ip = msftconnecttest.com, msftncsi.com, *.msftconnecttest.com, *.msftncsi.com, *.srv.nintendo.net, *.stun.playstation.net, xbox.*.microsoft.com, *.xboxlive.com, *.battlenet.com.cn, *.battlenet.com, *.blzstatic.cn, *.battle.net</span><br><span class="line"><span class="comment"># 解析器</span></span><br><span class="line"><span class="comment"># 用于订阅 规则 复写等的解析</span></span><br><span class="line"><span class="comment"># 必须在配置中填写解析器URL,否则在UI不会出现解析器选项</span></span><br><span class="line"><span class="comment"># 现在Loon解析器功能暂时功能较弱,非必要条件下无需使用</span></span><br><span class="line">resource-parser = https://raw.githubusercontent.com/Peng-YM/Sub-Store/master/scripts/sub-store-parser.js</span><br><span class="line"><span class="comment"># 运行模式SSID</span></span><br><span class="line"><span class="comment"># 用于在不同网络环境下切换Loon的运行模式,全局直连(direct)、自动分流(rule)和全局代理(proxy)</span></span><br><span class="line"><span class="comment"># 通过ssid(WIFI名)进行判断</span></span><br><span class="line"><span class="comment"># ssid-trigger参数,用于指定SSID下流量模式切换,（default表示默认,cellular表示蜂窝,目前支持三种值：,, </span></span><br><span class="line"><span class="comment"># 以下表示蜂窝数据(cellular)使用自动分流模式(rule),当链接WIFI名为ASUS的WIFI时使用直连模式(direct)</span></span><br><span class="line"><span class="comment"># 链接WIFI名为TPLINK的WIFI时使用自动分流模式(rule),其他情况(default)使用全局代理模式(proxy)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssid-trigger=&quot;proxy&quot;:rule,&quot;cellular&quot;:rule,&quot;ASUS&quot;:direct,&quot;TPLINK&quot;:rule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地节点</span></span><br><span class="line">[Proxy]</span><br><span class="line"><span class="comment"># 用于书写自己的节点,节点格式参考https://raw.githubusercontent.com/Loon0x00/LoonExampleConfig/master/Nodes/ExampleNodes.list</span></span><br><span class="line"><span class="comment"># 可以直接从Loon的节点列表中通过信息,复制出对应节点的Loon格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 机场订阅</span></span><br><span class="line"><span class="comment"># Loon订阅支持ss,ssr,trojan,vmess(v2ray)的原始订阅格式,可不使用转换器直接订阅</span></span><br><span class="line"><span class="comment"># 也可以使用Loon格式的专属订阅,节点格式参考[本地节点]</span></span><br><span class="line">[Remote Proxy]</span><br><span class="line">app = https://iwxf.netlify.app,udp=<span class="literal">false</span>,fast-open=<span class="literal">false</span>,img-url=app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点过滤,为策略组过滤是需要的节点,比如过滤订阅的所有的新加坡节点、香港节点、美国节点等</span></span><br><span class="line">[Remote Filter]</span><br><span class="line">机场节点 = NameRegex, FilterKey = <span class="string">&quot;(.*)&quot;</span></span><br><span class="line">[Proxy Group]</span><br><span class="line">All = select,app,机场节点</span><br><span class="line"><span class="comment"># img-url为策略组图标,可选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 规则,用于自动分流 </span></span><br><span class="line"><span class="comment"># 本地规则</span></span><br><span class="line"><span class="comment"># 通常优先于订阅规则</span></span><br><span class="line"><span class="comment"># 规则优先级,从上往下依次匹配</span></span><br><span class="line"><span class="comment"># 格式: 类型,域名或IP,策略组</span></span><br><span class="line"><span class="comment"># 具体可参考https://raw.githubusercontent.com/Loon0x00/LoonExampleConfig/master/Rule/ExampleRule.list</span></span><br><span class="line">[Rule]</span><br><span class="line">DOMAIN,qq.com,DIRECT</span><br><span class="line">DOMAIN-SUFFIX,baidu.com,DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两个规则将在最后匹配,优先级最低</span></span><br><span class="line"><span class="comment"># 若之前规则没匹配上,则通过查geoip数据库,如果请求是CN(中国)则走直连</span></span><br><span class="line">GEOIP,CN,DIRECT</span><br><span class="line"><span class="comment"># 最后匹配的规则,之前没有匹配上的规则的请求将会触发这条规则</span></span><br><span class="line"><span class="comment"># 将走Global策略组所选节点</span></span><br><span class="line">FINAL,Global</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程规则订阅</span></span><br><span class="line"><span class="comment"># 优先级从上往下</span></span><br><span class="line"><span class="comment"># 优先于GEOIP和FINAL本地规则</span></span><br><span class="line">[Remote Rule]</span><br><span class="line">https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/China/China.list, policy=direct, tag=国内域名, enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 使用Global策略组,匹配上国外域名规则的请求将会走Global所选节点</span></span><br><span class="line">https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Proxy/Proxy_Domain.list, policy=Global, tag=国外域名, enabled=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地脚本</span></span><br><span class="line">[Script]</span><br><span class="line"><span class="built_in">enable</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 远程脚本订阅</span></span><br><span class="line">[Remote Script]</span><br><span class="line">https://raw.githubusercontent.com/Tartarus2014/Loon-Script/master/JD.conf, tag=jd, enabled=<span class="literal">true</span></span><br><span class="line">https://raw.githubusercontent.com/Tartarus2014/Loon-Script/master/Script.conf, tag=Script, enabled=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 复写,需要配合MITM才能,否则无法针对HTTPS网站</span></span><br><span class="line"><span class="comment"># 主要用于重定向和广告的精准屏蔽(reject)</span></span><br><span class="line">[URL Rewrite]</span><br><span class="line"><span class="built_in">enable</span> = <span class="literal">false</span></span><br><span class="line">^https?:\/\/(www.)?(g|google)\.com\.hk 302 https://www.google.com</span><br><span class="line">^https?:\/\/(www.)?(g|google)\.cn 302 https://www.google.com</span><br><span class="line"></span><br><span class="line"><span class="built_in">enable</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 京东比价Fix</span></span><br><span class="line">^https?:\/\/api\.m\.jd.com\/client\.action\?functionId=start reject-200</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loon插件</span></span><br><span class="line">[Plugin]</span><br><span class="line"><span class="comment"># 需要配置并开启MITM后才能使用</span></span><br><span class="line">https://raw.subloon.cf/AccelerateRaw.plugin, tag=Github加速, enabled=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为域名指定解析的DNS服务器或者直接为域名指定IP</span></span><br><span class="line">[Host]</span><br><span class="line"></span><br><span class="line">[MITM]</span><br></pre></td></tr></table></figure><p>该配置文件包含jd的脚本<br><strong>Loon的使用和配置方法还有很多，这里就先以配置文件的方式来操作</strong></p><h4 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h4><p>在<code>配置</code>——&gt;<code>证书管理</code>安装证书，安装后记得在手机<code>设置</code>——&gt;<code>通用</code>——&gt;<code>关于本机</code>——&gt;<code>证书信任设置</code>里面找到以<code>LOON CA</code>开头的证书，开启信任</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_2.jpg" alt="2022_01_27_jd_loon_2"><br>选择<code>自动分流</code>并点击<code>启动</code>,第一次启动会弹出对话框，都点确定就行</p><h4 id="更新脚本"><a href="#更新脚本" class="headerlink" title="更新脚本"></a>更新脚本</h4><p>找到<code>配置</code>——&gt;<code>订阅脚本</code>点击刷新按钮<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_3.jpg" alt="2022_01_27_jd_loon_3"><br>可以点击第一行的jd,进去看一下，确保每个脚本都更新完成，如果更新失败可以多试几次。<br><strong>所有脚本更新成功后，找到获取京东cookie的脚本并启用 (这一步很关键)</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_5.jpg" alt="2022_01_27_jd_loon_5"></p><h4 id="获取-京东Cookie"><a href="#获取-京东Cookie" class="headerlink" title="获取 京东Cookie"></a>获取 京东Cookie</h4><p>然后打开 Safari浏览器，输入<code>jd.com</code>，找到登录页面并登录(如果已经登录了，点击刷新即可，切记不要登出，否则cookie会失效)<br>登录成功后一定点一下 这里的 <code>我的</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_6.jpg" alt="2022_01_27_jd_loon_6"><br>如果有多个账号，可继续点击  Safari 的<code>无痕浏览</code>登录其他账号即可</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>打开<code>Loon</code>，找到首页<code>脚本</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_7.jpeg" alt="2022_01_27_jd_loon_7"><br>点击<code>jd</code>找到第一个脚本，左滑并点击<code>运行</code>，看到输出有京豆变化可以了~<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2022_01_27_jd_loon_8.jpeg" alt="2022_01_27_jd_loon_8"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>开启loon之后，手机所有的流量都会通过loon来转发，在使用AppStore下载App的时候，会比较慢。只要关掉loon下载等完成后再开启就可以了</li></ol><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起名字老重名？使用这款利器可以快速帮你查询有哪些站点用了你的名字！</title>
      <link href="tips-sherlock-9.html"/>
      <url>tips-sherlock-9.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2021_03_29_sherlock_demo.gif" alt="2021_03_29_sherlock_demo"></p><p>不知道有没有小伙伴跟我一样，常常在注册账号的时候输入了昵称往往会反回一个“用户名已存在”，然后尝试了好几个昵称之后才能成功。<br>今天介绍的这款工具可以帮助我们迅速的检索各大网站有没有我们自己的用户昵称，同样它也可以帮助我们快速的查询同一个用户名都注册了哪些网站。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://github.com/sherlock-project/sherlock">sherloc</a>，在Github上面已经有24k的Star数，它的名字取自于电影《神探夏洛克》的英文名字——sherlock。<br>sherlock主要使用Python3来开发完成的，这使得它具有更多的灵活性，可以运行在Windows、Mac以及Linux操作系统上。</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>我们这里以Linux为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从Github上面下载源码</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/sherlock-project/sherlock.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到源码文件夹内</span></span><br><span class="line">$ <span class="built_in">cd</span> sherlock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需要的依赖</span></span><br><span class="line">$ python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>得益于Python良好的包管理工具，使得我们的安装非常的简单和方便，只需要几个命令就可搞定。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ python3 sherlock --<span class="built_in">help</span></span><br><span class="line">usage: sherlock [-h] [--version] [--verbose] [--folderoutput FOLDEROUTPUT]</span><br><span class="line">                [--output OUTPUT] [--tor] [--unique-tor] [--csv]</span><br><span class="line">                [--site SITE_NAME] [--proxy PROXY_URL] [--json JSON_FILE]</span><br><span class="line">                [--timeout TIMEOUT] [--print-all] [--print-found] [--no-color]</span><br><span class="line">                [--browse] [--<span class="built_in">local</span>]</span><br><span class="line">                USERNAMES [USERNAMES ...]</span><br><span class="line"></span><br><span class="line">Sherlock: Find Usernames Across Social Networks (Version 0.14.0)</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>           <span class="comment">#展示帮助页面</span></span><br><span class="line">  --version            <span class="comment"># 输出当前的版本号以及项目的依赖</span></span><br><span class="line">  --verbose, -v, -d, --debug <span class="comment"># Log的输出等级</span></span><br><span class="line">  --folderoutput FOLDEROUTPUT, -fo FOLDEROUTPUT <span class="comment">#如果需要同时查询多个用户名，可以在这里定义传入保存结果的文件夹路径</span></span><br><span class="line">  --output OUTPUT, -o OUTPUT  <span class="comment"># 当只查询一个名字的时候，指定的保村结果的文件夹</span></span><br><span class="line">  --tor, -t             <span class="comment"># 通过Tor来发送请求，Tor必须安装在系统目录里面</span></span><br><span class="line">  --unique-tor, -u      <span class="comment"># 通过Tor来发送请求，并且每次都使用新的连接</span></span><br><span class="line">  --csv                 <span class="comment"># 创建CVS文件</span></span><br><span class="line">  --site SITE_NAME      <span class="comment"># 要查询的网站名字，可以传入多个</span></span><br><span class="line">  --proxy PROXY_URL, -p PROXY_URL <span class="comment"># 使用的代理</span></span><br><span class="line">  --json JSON_FILE, -j JSON_FILE <span class="comment"># 输入格式为json文件，支持从网络获取的json文件</span></span><br><span class="line">  --timeout TIMEOUT     <span class="comment"># 超时时间</span></span><br><span class="line">  --print-all           <span class="comment"># 输出所有结果 包括没有找到昵称的网站</span></span><br><span class="line">  --print-found         <span class="comment"># 只输出找到结果的信息</span></span><br><span class="line">  --no-color            <span class="comment"># 控制台不带有颜色的输出结果</span></span><br><span class="line">  --browse, -b          <span class="comment"># 使用默认浏览器打开所有的搜索结果</span></span><br><span class="line">  --<span class="built_in">local</span>, -l           <span class="comment"># 强制使用本地的 data.json文件</span></span><br></pre></td></tr></table></figure><p>使用方法也很简单，搜索单个名字，只需要在命令行输入：<br><code>python3 sherlock username</code><br>比如我们搜索<code>川建国</code><br>搜索结果如下：<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2021_03_29_sherlock_search.png" alt="2021_03_29_sherlock_search"></p><p>同时搜索多个名字<br><code>python3 sherlock tony heisenberg johnson</code><br>搜索结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[*] Checking username tony on:</span><br><span class="line">[+] 3dnews: http:&#x2F;&#x2F;forum.3dnews.ru&#x2F;member.php?username&#x3D;tony</span><br><span class="line">[+] 7Cups: https:&#x2F;&#x2F;www.7cups.com&#x2F;@tony</span><br><span class="line">[+] 9GAG: https:&#x2F;&#x2F;www.9gag.com&#x2F;u&#x2F;tony</span><br><span class="line">[+] About.me: https:&#x2F;&#x2F;about.me&#x2F;tony</span><br><span class="line">[+] Academia.edu: https:&#x2F;&#x2F;independent.academia.edu&#x2F;tony</span><br><span class="line">[+] AllTrails: https:&#x2F;&#x2F;www.alltrails.com&#x2F;members&#x2F;tony</span><br><span class="line">....</span><br><span class="line">[+] Anobii: https:&#x2F;&#x2F;www.anobii.com&#x2F;tony&#x2F;profile</span><br><span class="line">[+] Apple Discussions: https:&#x2F;&#x2F;discussions.apple.com&#x2F;profile&#x2F;tony</span><br><span class="line">[+] Archive.org: https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;@tony</span><br><span class="line">[+] Asciinema: https:&#x2F;&#x2F;asciinema.org&#x2F;~tony</span><br><span class="line">[+] AskFM: https:&#x2F;&#x2F;ask.fm&#x2F;tony</span><br><span class="line"></span><br><span class="line">[*] Checking username heisenberg on:</span><br><span class="line">[+] 9GAG: https:&#x2F;&#x2F;www.9gag.com&#x2F;u&#x2F;heisenberg</span><br><span class="line">[+] About.me: https:&#x2F;&#x2F;about.me&#x2F;heisenberg</span><br><span class="line">[+] Academia.edu: https:&#x2F;&#x2F;independent.academia.edu&#x2F;heisenberg</span><br><span class="line">[+] AllTrails: https:&#x2F;&#x2F;www.alltrails.com&#x2F;members&#x2F;heisenberg</span><br><span class="line">[+] Anobii: https:&#x2F;&#x2F;www.anobii.com&#x2F;heisenberg&#x2F;profile</span><br><span class="line">[+] Archive.org: https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;@heisenberg</span><br><span class="line">...</span><br><span class="line">[+] Asciinema: https:&#x2F;&#x2F;asciinema.org&#x2F;~heisenberg</span><br><span class="line">[+] AskFM: https:&#x2F;&#x2F;ask.fm&#x2F;heisenberg</span><br><span class="line">[+] Audiojungle: https:&#x2F;&#x2F;audiojungle.net&#x2F;user&#x2F;heisenberg</span><br><span class="line">[+] BLIP.fm: https:&#x2F;&#x2F;blip.fm&#x2F;heisenberg</span><br><span class="line">[+] BOOTH: https:&#x2F;&#x2F;heisenberg.booth.pm&#x2F;</span><br><span class="line"></span><br><span class="line">[*] Checking username johnson on:</span><br><span class="line">[+] 7Cups: https:&#x2F;&#x2F;www.7cups.com&#x2F;@johnson</span><br><span class="line">[+] 9GAG: https:&#x2F;&#x2F;www.9gag.com&#x2F;u&#x2F;johnson</span><br><span class="line">[+] About.me: https:&#x2F;&#x2F;about.me&#x2F;johnson</span><br><span class="line">[+] Academia.edu: https:&#x2F;&#x2F;independent.academia.edu&#x2F;johnson</span><br><span class="line">[+] AllTrails: https:&#x2F;&#x2F;www.alltrails.com&#x2F;members&#x2F;johnson</span><br><span class="line">...</span><br><span class="line">[+] Anobii: https:&#x2F;&#x2F;www.anobii.com&#x2F;johnson&#x2F;profile</span><br><span class="line">[+] Archive.org: https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;@johnson</span><br><span class="line">[+] Audiojungle: https:&#x2F;&#x2F;audiojungle.net&#x2F;user&#x2F;johnson</span><br><span class="line">[+] BLIP.fm: https:&#x2F;&#x2F;blip.fm&#x2F;johnson</span><br><span class="line">[+] Bandcamp: https:&#x2F;&#x2F;www.bandcamp.com&#x2F;johnson</span><br></pre></td></tr></table></figure><p>多个搜索结果会按顺序来展示</p><h4 id="支持Docker"><a href="#支持Docker" class="headerlink" title="支持Docker"></a>支持Docker</h4><p>作者也增加了对docker的支持，我们只需要执行<code>docker build -t mysherlock-image .</code>就可以在docker中使用sherklock了。<br>更多有关docker的使用方法可以去<a href="https://github.com/sherlock-project/sherlock">github主页</a>查看</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>作者是把每一个用户的URL地址都去请求一下，如果有返回有结果就代表存在这个昵称，如果没有返回结果或者是404，就意味着不存在当前的用户。<br>比如请求：<code>https://www.about.me/tony</code>,可以请求到结果就代表存在这个昵称，如果没有相应的返回就是没有这个昵称。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金三银四招聘季，不想996？附赠一份955公司名单以及招聘链接</title>
      <link href="tips-955-8.html"/>
      <url>tips-955-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>金三银四，又到了跳槽季，相信很多小伙伴都已经在摩拳擦掌，如果你厌倦了966制的工作，不妨看一下这个955的公司名单。</p><table><thead><tr><th>公司名称</th><th>城市</th><th>招聘链接</th></tr></thead><tbody><tr><td>Amazon</td><td>北京/上海</td><td><a href="https://www.amazon.jobs/zh">https://www.amazon.jobs/zh</a></td></tr><tr><td>AMD</td><td>上海</td><td><a href="https://www.amd.com/zh-hans/corporate/careers">https://www.amd.com/zh-hans/corporate/careers</a></td></tr><tr><td>Airbnb</td><td>北京</td><td><a href="https://careers.airbnb.com/zh/">https://careers.airbnb.com/zh/</a></td></tr><tr><td>Apple</td><td>北京/上海</td><td><a href="https://www.apple.com/jobs/cn/">https://www.apple.com/jobs/cn/</a></td></tr><tr><td>ArcSoft</td><td>杭州</td><td><a href="https://www.arcsoft.com.cn/job/SocietyIntroduce.html">https://www.arcsoft.com.cn/job/SocietyIntroduce.html</a></td></tr><tr><td>Autodesk</td><td>北京/上海</td><td><a href="https://www.zhipin.com/gongsi/0424ed7219a6833e33Fy2dq8.html">https://www.zhipin.com/gongsi/0424ed7219a6833e33Fy2dq8.html</a>?</td></tr><tr><td>Booking</td><td>上海</td><td><a href="https://www.zhipin.com/gongsi/c76ab226aa5051ec03By3dQ~.html">https://www.zhipin.com/gongsi/c76ab226aa5051ec03By3dQ~.html</a></td></tr><tr><td>Citrix</td><td>南京</td><td><a href="https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-Citrix">https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-Citrix</a></td></tr><tr><td>Cisco</td><td>北京/上海/杭州/苏州</td><td><a href="https://www.zhipin.com/gongsi/bdba0c51d7aef6f51HZ60t-_.html">https://www.zhipin.com/gongsi/bdba0c51d7aef6f51HZ60t-_.html</a></td></tr><tr><td>Coolapk (酷安)</td><td>北京/深圳</td><td><a href="https://www.coolapk.com/about/jobs.html">https://www.coolapk.com/about/jobs.html</a></td></tr><tr><td>Coupang</td><td>北京/上海</td><td><a href="https://www.zhipin.com/gongsir/f446779d01512b8d1Xxy3Nm0.html">https://www.zhipin.com/gongsir/f446779d01512b8d1Xxy3Nm0.html</a></td></tr><tr><td>Douban (豆瓣)</td><td>北京</td><td><a href="https://jobs.douban.com/jobs/social/">https://jobs.douban.com/jobs/social/</a></td></tr><tr><td>eBay</td><td>上海</td><td><a href="https://www.zhipin.com/gongsi/966b2abf57fea8293nZz39S8.html">https://www.zhipin.com/gongsi/966b2abf57fea8293nZz39S8.html</a></td></tr><tr><td>eHealth</td><td>厦门</td><td><a href="http://www.ehealth-china.com/index.php?m=content&amp;c=index&amp;a=lists&amp;catid=12">http://www.ehealth-china.com/index.php?m=content&amp;c=index&amp;a=lists&amp;catid=12</a></td></tr><tr><td>Electronic Arts</td><td>上海</td><td><a href="https://www.ea.com/zh-cn/careers">https://www.ea.com/zh-cn/careers</a></td></tr><tr><td>EMC</td><td>上海</td><td><a href="https://chinajobs.dell.com/students">https://chinajobs.dell.com/students</a></td></tr><tr><td>Ericsson</td><td>上海</td><td><a href="https://jobs.51job.com/yx/co2215077.html">https://jobs.51job.com/yx/co2215077.html</a></td></tr><tr><td>FreeWheel</td><td>北京</td><td><a href="https://www.zhipin.com/gongsir/eb36cd62c98680371nN82NQ~.html">https://www.zhipin.com/gongsir/eb36cd62c98680371nN82NQ~.html</a></td></tr><tr><td>GE</td><td>上海</td><td><a href="http://careers.ge.com.cn/">http://careers.ge.com.cn/</a></td></tr><tr><td>Google</td><td>北京/上海</td><td><a href="https://careers.google.com/jobs/results/?hl=zh-CN&amp;jid=175665001">https://careers.google.com/jobs/results/?hl=zh-CN&amp;jid=175665001</a></td></tr><tr><td>Grab</td><td>北京</td><td><a href="https://www.zhipin.com/gongsi/72b5c7467d8aeb7d0nd92Ni8.html">https://www.zhipin.com/gongsi/72b5c7467d8aeb7d0nd92Ni8.html</a></td></tr><tr><td>Honeywell</td><td>上海</td><td><a href="https://www.honeywell.com.cn/careers/students-recent-graduates">https://www.honeywell.com.cn/careers/students-recent-graduates</a></td></tr><tr><td>HP</td><td>上海</td><td><a href="https://jobs.hp.com/zh-cn/Home">https://jobs.hp.com/zh-cn/Home</a></td></tr><tr><td>HSBC</td><td>上海/广州/西安</td><td><a href="https://www.about.hsbc.com.cn/zh-cn/careers">https://www.about.hsbc.com.cn/zh-cn/careers</a></td></tr><tr><td>Hulu</td><td>北京</td><td><a href="https://careers.hulu.com/">https://careers.hulu.com/</a></td></tr><tr><td>IBM</td><td>上海 (GBS除外)</td><td><a href="https://www.ibm.com/cn-zh/employment/index.html">https://www.ibm.com/cn-zh/employment/index.html</a></td></tr><tr><td>iHerb</td><td>上海</td><td><a href="https://www.zhipin.com/gongsi/5b3ecfd47f15988e1X140tS8FA~~.html">https://www.zhipin.com/gongsi/5b3ecfd47f15988e1X140tS8FA~~.html</a></td></tr><tr><td>Intel</td><td>上海</td><td><a href="https://www.intel.com/content/www/us/en/jobs/locations/china.html">https://www.intel.com/content/www/us/en/jobs/locations/china.html</a></td></tr><tr><td>LeetCode</td><td>上海</td><td><a href="https://www.zhipin.com/gongsi/af699cd638ab42601X1629W9Fg~~.html">https://www.zhipin.com/gongsi/af699cd638ab42601X1629W9Fg~~.html</a></td></tr><tr><td>Linkedin</td><td>北京</td><td><a href="https://cn.linkedin.com/company/linkedin-china">https://cn.linkedin.com/company/linkedin-china</a></td></tr><tr><td>Microsoft</td><td>北京/上海/苏州</td><td><a href="https://www.microsoft.com/zh-cn/ard/recruitment">https://www.microsoft.com/zh-cn/ard/recruitment</a></td></tr><tr><td>MicroStrategy</td><td>杭州</td><td><a href="https://www.microstrategy.cn/cn/company/careers">https://www.microstrategy.cn/cn/company/careers</a></td></tr><tr><td>National Instruments</td><td>上海</td><td><a href="https://jobs.51job.com/all/co108721.html">https://jobs.51job.com/all/co108721.html</a></td></tr><tr><td>Nokia</td><td>南京/杭州</td><td><a href="https://www.zhipin.com/gongsir/e61cff6f529e1a2203V7396_.html">https://www.zhipin.com/gongsir/e61cff6f529e1a2203V7396_.html</a></td></tr><tr><td>NVIDIA</td><td>北京/上海</td><td><a href="https://www.nvidia.com/en-us/about-nvidia/careers/">https://www.nvidia.com/en-us/about-nvidia/careers/</a></td></tr><tr><td>Oracle</td><td>上海</td><td><a href="https://www.oracle.com/cn/corporate/careers/">https://www.oracle.com/cn/corporate/careers/</a></td></tr><tr><td>PayPal</td><td>上海</td><td><a href="https://www.zhipin.com/gongsi/9f518987551682ef0nF80tS7.html">https://www.zhipin.com/gongsi/9f518987551682ef0nF80tS7.html</a></td></tr><tr><td>Pivotal</td><td>北京/上海</td><td><a href="https://www.zhipin.com/gongsi/17d509ce528a73151nN52N-4.html">https://www.zhipin.com/gongsi/17d509ce528a73151nN52N-4.html</a></td></tr><tr><td>Red Hat</td><td>北京/上海/深圳</td><td><a href="https://www.zhipin.com/gongsi/0584d877a719d9c01XN62Nm5.html">https://www.zhipin.com/gongsi/0584d877a719d9c01XN62Nm5.html</a></td></tr><tr><td>SAP</td><td>上海</td><td><a href="https://www.sap.cn/about/careers/joining/ideal-candidates.html">https://www.sap.cn/about/careers/joining/ideal-candidates.html</a></td></tr><tr><td>Shopee</td><td>深圳</td><td><a href="https://app.mokahr.com/campus_apply/shopee/2962#/">https://app.mokahr.com/campus_apply/shopee/2962#/</a></td></tr><tr><td>SmartNews</td><td>北京/上海</td><td><a href="https://cn.recruit.net/company-smartnews-jobs">https://cn.recruit.net/company-smartnews-jobs</a></td></tr><tr><td>Snap</td><td>北京/深圳</td><td><a href="https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-Snapchat">https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-Snapchat</a></td></tr><tr><td>State Street</td><td>杭州</td><td><a href="https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-State-Street">https://cn.indeed.com/%E5%B7%A5%E4%BD%9C-State-Street</a></td></tr><tr><td>SUSE</td><td>北京/上海/深圳</td><td><a href="https://jobs.suse.com/us/en">https://jobs.suse.com/us/en</a></td></tr><tr><td>ThoughtWorks</td><td>西安/北京/深圳/成都/武汉/上海/香港</td><td><a href="https://join.thoughtworks.cn/">https://join.thoughtworks.cn/</a></td></tr><tr><td>Trend Micro</td><td>南京</td><td><a href="https://careers.trendmicro.com.cn/">https://careers.trendmicro.com.cn/</a></td></tr><tr><td>TuSimple</td><td>北京</td><td><a href="https://www.tusimple.com/cn/%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC/">https://www.tusimple.com/cn/%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC/</a></td></tr><tr><td>Ubisoft</td><td>上海</td><td><a href="https://zh-cn.ubisoft.com/home/">https://zh-cn.ubisoft.com/home/</a></td></tr><tr><td>Unity</td><td>上海</td><td><a href="https://campus.unity.cn/">https://campus.unity.cn/</a></td></tr><tr><td>Vipshop (唯品会)</td><td>上海</td><td><a href="https://recruitment.corp.vipshop.com/">https://recruitment.corp.vipshop.com/</a></td></tr><tr><td>VMware</td><td>北京/上海</td><td><a href="https://careers.vmware.com/china?lang=zh-CN">https://careers.vmware.com/china?lang=zh-CN</a></td></tr><tr><td>WeWork</td><td>上海</td><td><a href="https://www.wework.cn/">https://www.wework.cn/</a></td></tr><tr><td>Works Applications</td><td>上海</td><td><a href="https://career.worksap.com/cn/">https://career.worksap.com/cn/</a></td></tr><tr><td>Zoom</td><td>合肥/杭州/苏州</td><td><a href="https://www.zhipin.com/gongsi/56cf5a2d7754fc0b1nV729u6FA~~.html">https://www.zhipin.com/gongsi/56cf5a2d7754fc0b1nV729u6FA~~.html</a></td></tr></tbody></table><p>以上公司名单，基本不属于 996 的公司，相对接近 955/965 的水平，但是依旧要看部门和地区，不能保证完全准确性。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LastPass即将收费，是时候更换一款新的密码管理工具了！</title>
      <link href="tips-password-bitwarden-7.html"/>
      <url>tips-password-bitwarden-7.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>前几天收到了<code>LastPass</code>的邮件：自2021年3月16日起，不再提供全平台的免费服务，用户只能选择一个平台享受免费(iOS、Android 或者 PC端)</p><p>邮件里还提到，购买会员享受25%折扣，打完折27美元。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_02_23_lastpass_details.png" alt="2021_02_23_lastpass_details"><br>感谢<code>LastPass</code>这些年来的陪伴，不管是在移动端还是PC网页端都很好用，特别是PC网页端自动填充密码功能真心不错，填充率非常高。</p><p>让我们来看看其他除了<code>LastPass</code>还有哪些密码管理工具</p><h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a><a href="https://1password.com/sign-up/">1Password</a></h3><p>毫无疑问<code>1Password</code>是人气最高的一款密码管理工具，支持跨平台而且还配备了中文版。浏览器扩展支持：Chrome, FireFox, Opera, Safari，桌面版同样支持 Windows, Mac, Android, iPhone, iPad。如果不差钱，完全可以选择<code>1Password</code></p><h4 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h4><ul><li>个人版：每月 2.99 美元；</li><li>家庭版：每月4.99 美元，可以包含 5 个账号使用。</li><li>购买后，一个账号可以在多个平台登录进行同步使用。</li><li>另外：1Password 提供 30 天免费试用，可以体验后根据需求选择购买。</li></ul><h3 id="Enpass"><a href="#Enpass" class="headerlink" title="Enpass"></a><a href="https://www.enpass.io/">Enpass</a></h3><p><code>Enpass</code>同样支持跨平台，最大的特点是密码不统一存储在官方的服务器上。如果我们想跨终端同步数据，可以借助一些云盘服务（比如DropBox、坚果云等）来实现，如果不想把数据上传到云盘也可以通过局域网来备份和传输。</p><h4 id="费用-1"><a href="#费用-1" class="headerlink" title="费用"></a>费用</h4><ul><li><code>Enpass</code>桌面版是不收费的，移动端只能免费同步20条账号和密码</li><li>如果想在移动端查看更多的数据，可以购买专业版，价格为68元，一次购买终生享用。</li></ul><h3 id="Bitwarden"><a href="#Bitwarden" class="headerlink" title="Bitwarden"></a><a href="https://bitwarden.com/pricing/">Bitwarden</a></h3><p><code>Bitwarden</code>也是一款免费的密码管理工具(基础功能免费)，对于我们个人来说，这些功能就够用的。我平时就使用一个PC端外加一个移动端。<br><code>Bitwarden</code>最大的优势是开源，并且支持我们自建云端存储服务器，可以使用官方提供的客户端连接到我们自己服务器上，然后自己的密码就可以存储在自己的服务器上，这样做的目的是更安全。</p><h4 id="费用-2"><a href="#费用-2" class="headerlink" title="费用"></a>费用</h4><ul><li>基础版本免费</li><li>可以自建服务器</li></ul><p>我选择使用<code>Bitwarden</code>，前几天刚刚把<code>LastPass</code>的密码同步过来</p><h4 id="LastPass迁移到Bitwarden"><a href="#LastPass迁移到Bitwarden" class="headerlink" title="LastPass迁移到Bitwarden"></a>LastPass迁移到Bitwarden</h4><h4 id="1-把LastPass数据导出"><a href="#1-把LastPass数据导出" class="headerlink" title="1. 把LastPass数据导出"></a>1. 把LastPass数据导出</h4><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_02_23_lastpass_export.png" alt="2021_02_23_lastpass_export"></p><ul><li>登录到LastPass官方网站</li><li>选择菜单——&gt;登录 </li><li>在打开的页面上，从边栏菜单中选择“Advanced Options”，然后选择“Export”。</li><li>输入您的LastPass电子邮件和密码，确认导出请求。</li><li>LastPass以原始文本格式显示数据，打开新的页面后，选择页面上的所有内容，进行复制以将所选数据复制到剪贴板。</li><li>在桌面创建一个新的文本文件。</li><li>打开它，然后将复制的内容粘贴到其中，将文件重命名为lastpass.csv</li></ul><h4 id="2-将数据导入到Bitwarden"><a href="#2-将数据导入到Bitwarden" class="headerlink" title="2. 将数据导入到Bitwarden"></a>2. 将数据导入到Bitwarden</h4><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_02_23_lastpass_import.png" alt="2021_02_23_lastpass_import"></p><ul><li>在Bitwarden网站上打开Web Vault。</li><li>选择顶部菜单中的工具。</li><li>在“工具”页面上，选择“导入数据”。</li><li>使用打开的页面上的下拉菜单选择LastPass（csv）。</li><li>选择“选择文件”，然后选择导出的lastpass.csv文件。</li><li>选择导入数据以完成该过程。</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 3-4】Flutter进阶教程——数据持久化sqflite使用</title>
      <link href="flutter-high-sqflite-3-4.html"/>
      <url>flutter-high-sqflite-3-4.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="sqflite"><a href="#sqflite" class="headerlink" title="sqflite"></a>sqflite</h3><p>数据持久化是在移动端开发中必不可少的技术手段。我们总是有一些用户信息，应用资源，列表数据等需要存储起来，这里我们主要来讲基于SQLite数据库的数据储存。<br>SQLite，是一款轻型的数据库。它的设计目标是嵌入式的，而且已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。更多详细信息可以参考:<a href="https://zh.wikipedia.org/wiki/SQLite">维基百科</a>、<a href="https://baike.baidu.com/item/SQLite">百度百科</a>。<br>Flutter已经帮助我们封装了操作SQLite的库，它就是：<a href="https://pub.dev/packages/sqflite">sqflite</a></p><h3 id="集成sqflite库"><a href="#集成sqflite库" class="headerlink" title="集成sqflite库"></a>集成sqflite库</h3><p>使用<code>sqflite</code>第三方库需要我们在<code>pubspec.yaml</code>文件先添加库的名字和版本号<br>在<code>dependencies</code>字段下添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sqflite:</span> <span class="string">^1.1.3</span></span><br></pre></td></tr></table></figure><p>这里以<code>1.1.3</code>为例<br>添加完成后保存一下，VSCode默认会执行<code>pub get</code>帮我们把需要的库下载下来，同样我们也可以在项目根目录下执行<code>pub get</code>来手动拉取需要的库。</p><h4 id="1-创建本地数据文件"><a href="#1-创建本地数据文件" class="headerlink" title="1. 创建本地数据文件"></a>1. 创建本地数据文件</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;SqfliteManager&gt; _initDataBase() <span class="keyword">async</span> &#123;</span><br><span class="line">SqfliteManager manager = SqfliteManager();</span><br><span class="line"><span class="built_in">String</span> dbPath = <span class="keyword">await</span> getDatabasesPath() + <span class="string">&quot;/<span class="subst">$sqlName</span>&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (manager.db == <span class="keyword">null</span>) &#123;</span><br><span class="line">    manager.db = <span class="keyword">await</span> openDatabase(</span><br><span class="line">    dbPath,</span><br><span class="line">    version: <span class="number">1</span>,</span><br><span class="line">    onCreate: (db, version) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">/// <span class="markdown">如果不存在 当前的表 就创建需要的表</span></span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> manager.isTableExit(db, tableName) == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.execute(CREATE_DATA_TABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们通过<code>getDatabasesPath()</code>函数获取到本地保存数据库文件的路径，在此路径后面拼接上我们的数据库文件名字，就是保存数据库文件的路径。在iOS中该路径在沙河路径下的<code>Documents</code>文件夹内，在Android中时默认数据库目录。<br>之后我们声明一个<code>Database</code>对象，用来保存数据库操作对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Database db;</span><br></pre></td></tr></table></figure><p>先判断此对象是否存在，如果不存在我们调用<code>openDatabase</code>来创建<br>这里传入前面获取到的数据库地址，版本号，和<code>onCreate</code>回调函数。<br>在<code>onCreate</code>回调内部判断是否存在我们需要使用的表名字，如果不存就执行创建数据库表的<code>sql</code>语句。</p><blockquote><p>除了<code>onCreate</code>回调，还有<code>onUpgrade</code>、<code>onDowngrade</code>、<code>onOpen</code>等回调。另外一个参数<code>singleInstance</code>它表示当传入相同的数据库路径是否返回同一个的实例对象，默认是<code>true</code></p></blockquote><h4 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><p>鉴于<code>sqflite</code>帮我们做了很多工作，所以在使用基本的<code>增</code>、<code>删</code>、<code>改</code>、<code>查</code>也很简单</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">插入数据</span></span></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; insertData(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; value) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> db.insert(tableName, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要传入表名字和要插入的数据就行<br>我们再来看一下<code>insert</code>函数的其他参数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; insert(<span class="built_in">String</span> table, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; values,</span><br><span class="line">      &#123;<span class="built_in">String</span> nullColumnHack, ConflictAlgorithm conflictAlgorithm&#125;);</span><br></pre></td></tr></table></figure><ul><li>nullColumnHack 是在传入的插入数据是空的时候 起到作用的<br>如果插入数据为空：<br>若不添加nullColumnHack则sql语句最终的结果将会类似insert into tableName()values()，这是不允许的。<br>若添加上nullColumnHack则sql语句将会变成insert into tableName (nullColumnHack)values(null)，这是可以的。</li><li>conflictAlgorithm 是一个枚举，当插入的数据出现冲突或错误时，我们该使用哪种策略，有以下几个值<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ConflictAlgorithm &#123;</span><br><span class="line">  rollback,</span><br><span class="line">  abort,</span><br><span class="line">  fail,</span><br><span class="line">  ignore,</span><br><span class="line">  replace,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><p>删除数据的代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">删除一条数据</span></span></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; deleteData(<span class="built_in">int</span> id) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.delete(tableName, where: <span class="string">&quot;id = ?&quot;</span>, whereArgs: [id]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下详细的<code>delete</code>函数都有哪些参数:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; delete(<span class="built_in">String</span> table, &#123;<span class="built_in">String</span> where, <span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; whereArgs&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>table</code>是要删除数据所在的表的名字 例如：testTable</li><li><code>where</code>是一个字符串，表示的是要删除的表达语句 例如：”id = ?”</li><li><code>whereArgs</code>是一个数组，是用来补充<code>where</code>语句里面的<code>?</code>参数的 例如：[2]<br>当我们传入上面示例参数后，要标的意思就是：要删除testTable 表内 id = 2 的数据</li></ul><h4 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4. 更新数据"></a>4. 更新数据</h4><p>删除数据代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; updateData(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; value, <span class="built_in">int</span> id) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.update(</span><br><span class="line">        tableName,</span><br><span class="line">        value,</span><br><span class="line">        where: <span class="string">&quot;id = ?&quot;</span>,</span><br><span class="line">        whereArgs: [id],</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的<code>update</code>函数如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; update(<span class="built_in">String</span> table, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; values,</span><br><span class="line">      &#123;<span class="built_in">String</span> where,</span><br><span class="line">      <span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; whereArgs,</span><br><span class="line">      ConflictAlgorithm conflictAlgorithm&#125;);</span><br></pre></td></tr></table></figure><p>跟<code>insert</code>函数的参数基本一致，这里就不赘述了</p><h4 id="5-查询数据"><a href="#5-查询数据" class="headerlink" title="5. 查询数据"></a>5. 查询数据</h4><p>直接来看查询语句的参数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&gt;&gt; query(</span><br><span class="line">    <span class="built_in">String</span> table,  <span class="comment">/// <span class="markdown">表名字 是必传参数</span></span></span><br><span class="line">    &#123;<span class="built_in">bool</span> distinct,  <span class="comment">// 是否包含重复数据</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; columns,  <span class="comment">// 需要查询的列</span></span><br><span class="line">    <span class="built_in">String</span> where,       <span class="comment">//  查询条件</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; whereArgs, <span class="comment">// 查询条件参数</span></span><br><span class="line">    <span class="built_in">String</span> groupBy,  <span class="comment">//按列分组 列的名字</span></span><br><span class="line">    <span class="built_in">String</span> having,   <span class="comment">// 给分组设置条件</span></span><br><span class="line">    <span class="built_in">String</span> orderBy,   <span class="comment">// 按列排序 asc/desc</span></span><br><span class="line">    <span class="built_in">int</span> limit,     <span class="comment">// 限制查询结果数量</span></span><br><span class="line">    <span class="built_in">int</span> offset&#125;);  <span class="comment">// 从第几条开始查询</span></span><br></pre></td></tr></table></figure><p>查询语句的参数比较丰富，基本可以满足我们一些复杂场景的查询需求</p><p>好了，关于<code>sqflite</code>的使用就总结这些了。</p><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>sqflite_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter sqflite </tag>
            
            <tag> Flutter 数据库 </tag>
            
            <tag> Flutter 数据持久化 </tag>
            
            <tag> Flutter sqlite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 3-3】Flutter进阶教程——http请求和FutureBuilder</title>
      <link href="flutter-high-request-3-3.html"/>
      <url>flutter-high-request-3-3.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>在移动开发过程中很多时候我们都需要依赖异步请求数据然后再来刷新UI。在用户打开界面的时候，先给出一个Loading提示，等数据请求完成后，我们再把数据展示在页面上，这是很常见的操作。  </p><p>异步请求的好处就是不会阻塞主线程，用户虽然在“等”，但是页面不会卡死。<br>同步请求不适应于这种情况，同步请求会出现页面卡死现象，此时用户不能点击(即使点击也没有效果)，体验非常不好。<br>所以大多数时候我们都是使用异步请求来获取数据</p><h3 id="http-库"><a href="#http-库" class="headerlink" title="http 库"></a>http 库</h3><p>在Flutter中，我们可以用<a href="https://pub.dev/packages/http">http库</a>来做网络请求，它支持异步请求，并且有良好的API接口<br>使用http库的步骤：</p><ul><li>在项目中，打开<code>pubspec.yaml</code>文件</li><li>找到<code>dependencies</code>字段，在下面添加<code>http: ^0.12.2</code>，其中<code>0.12.2</code>是版本号</li><li>然后保存<code>pubspec.yaml</code> 并执行<code>pub get</code>命令把我们要使用的第三方库下载下来  </li></ul><blockquote><p>具体 <code>pub get</code>命令的使用在之前的<a href="http://fulade.me/dart-pub-command-1-15.html">文章</a>有介绍过 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_02_02_http_request_yaml.jpg" alt="2021_02_02_http_request_yaml"></p><p>然后在要使用http库的文件里面引入头文件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:http/http.dart&#x27;</span> <span class="keyword">as</span> http;</span><br></pre></td></tr></table></figure><p>发送http请求的代码也比较简单，我们这里以<code>get</code>请求为例</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="keyword">get</span>(<span class="string">&quot;https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/request_demo_test.json&quot;</span>);</span><br></pre></td></tr></table></figure><p>只要传入要请求的地址即可，这里的URL地址是我自己上传的测试文件。</p><h3 id="http-异步请求返回结果"><a href="#http-异步请求返回结果" class="headerlink" title="http 异步请求返回结果"></a>http 异步请求返回结果</h3><p>前面我知道http库发送请求是支持异步的，那么异步请求的返回结果我们该如何接收呢？</p><ul><li>通过<code>then</code>函数获取，在<code>get</code>请求之后我们可以直接跟上<code>then</code>函数来作为回调，在回调内部可以获取到请求的结果<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="keyword">get</span>(getURL).then((value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>这样写确实很方便，但当我们的网络请求很多，并且一个网络请求依赖另外一个网络请求的时候，这个时候就会多个回调函数嵌套在一起(又称为<code>回调地狱</code>)，代码就会显得很凌乱，很不适合Debug。</li><li>使用<code>await</code>来接收异步操作的结果<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> http.<span class="keyword">get</span>(getURL);</span><br></pre></td></tr></table></figure>这样写代码就比上面的代码清爽多了<br>但是需要注意的是，如果函数内部有被<code>await</code>修饰的方法，那么函数应该被<code>async</code>来修饰，并且返回值需要被<code>Future</code>修饰，<code>Future</code>是一个延时计算的对象，在被<code>await</code>修饰的函数返回的时候才能拿到<code>Future</code>的具体值。<br>示例入下：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Map</span>&gt; getData() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> http.<span class="keyword">get</span>(getURL);</span><br><span class="line">  <span class="keyword">return</span> data.body; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p>我们前面已经知道：调用<code>setState()</code>函数可以刷新页面，所以在http请求之后我们调用<code>setState()</code>函数即可刷新页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="keyword">get</span>(getURL).then((value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line">  <span class="keyword">var</span> data = jsonDecode(data.body);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">此处执行刷新页面的代码</span></span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用FutureBuilder来刷新页面"><a href="#使用FutureBuilder来刷新页面" class="headerlink" title="使用FutureBuilder来刷新页面"></a>使用FutureBuilder来刷新页面</h3><p><code>setState()</code>固然是可以刷新页面，但是当我们页面内有多个网络请求的时候，就会不停的调用<code>setState()</code>来全量刷新页面，显然这就有点冗余。<br>Flutter为我们提供了更好的方式来实现获取数据并且刷新UI的操作，那就是<code>FutureBuilder</code><br>来看它的初始化方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FutureBuilder(&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步的操作</span></span></span><br><span class="line">  <span class="keyword">this</span>.future,</span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化数据</span></span></span><br><span class="line">  <span class="keyword">this</span>.initialData,</span><br><span class="line">  <span class="comment">/// <span class="markdown">构建UI的函数</span></span></span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>由构造函数可见，我们需要传入<code>future</code>参数，也就是我们的耗时操作函数，还需要传入<code>builder</code>函数<br>在<code>builder</code>方法里可以捕捉到两个参数<code>BuildContext context</code>和<code>AsyncSnapshot snap</code><br>其中<code>snap</code>的属性会携带<code>future</code>的耗时函数的返回值，也就是说：在耗时操作函数返回结果之后，我们可以在<code>builder</code>方法内获取到这一返回值。<br>所以上面的请求我们也可以这么来实现:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FutureBuilder(</span><br><span class="line">  future: getData(),</span><br><span class="line">  builder: (BuildContext context, AsyncSnapshot snap) &#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">如果没有数据 我们就显示loading页面</span></span></span><br><span class="line">    <span class="keyword">if</span> (snap.hasData == <span class="keyword">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">如果获取到了数据 我们就初始化一个 ListView来展示获取到的数据</span></span></span><br><span class="line">      <span class="keyword">var</span> dataSource = snap.data[<span class="string">&quot;tracks&quot;</span>];</span><br><span class="line">      <span class="keyword">return</span> ListView.builder(</span><br><span class="line">        itemCount: dataSource.length,</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(</span><br><span class="line">            title: Text(dataSource[index][<span class="string">&quot;title&quot;</span>]),</span><br><span class="line">            subtitle: Text(dataSource[index][<span class="string">&quot;cover&quot;</span>]),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>在获取到数据之后，我们通过<code>ListView.builder</code>来构建一个<code>ListView</code>并返回，此时就完成了刷新UI的工作</p><p>我这里写的比较简单，只是用<code>hasData</code>来做为判断的依据<br>其实还有更优雅的做法：使用<code>snap</code>的另一个属性<code>connectionState</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ConnectionState &#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">没有异步任务，</span></span></span><br><span class="line">  none,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步任务正在等待</span></span></span><br><span class="line">  waiting,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步任务正在执行 或者 数据正在传输</span></span></span><br><span class="line">  active,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步任务已经终止.</span></span></span><br><span class="line">  done,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在<code>connectionState</code>是<code>done</code>的时候在来判断是否存在数据<br>如果存在就展示数据！</p><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>http_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 异步 </tag>
            
            <tag> Flutter await </tag>
            
            <tag> Flutter FutureBuilder </tag>
            
            <tag> Flutter async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 3-2】Flutter进阶教程——路由Router和导航Navigator以及传值</title>
      <link href="flutter-high-router-widget-3-2.html"/>
      <url>flutter-high-router-widget-3-2.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在移动开发中，我们管页面之间的跳转叫做路由。在iOS中指的就是ViewController之间的跳转，在Android中就是Activity之间的跳转。路由是在移动端开发中非常重要的概念，它负责管理着各个页面之间的跳转还有传值工作，是必不可缺少的控件。</p><h3 id="路由Map"><a href="#路由Map" class="headerlink" title="路由Map"></a>路由Map</h3><p>为了方便我们管理跳转页面，<code>Flutter</code>为我们 提供了路由Map。<br>路由Map由在<code>main.dart</code>文件里面<code>MaterialApp</code>的参数<code>routes</code>管理，<code>routes</code>参数接收一个Map，Map里面就是我们项目的路由Map，你可以打开<a href="https://github.com/Johnson8888/learn_flutter">我的项目</a>看到<code>routes</code>参数如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">routes: &#123;</span><br><span class="line">  <span class="string">&quot;/&quot;</span>: (context) =&gt; MainPage(),</span><br><span class="line">  <span class="string">&quot;TextDemoPage&quot;</span>: (context) =&gt; TextDemoPage(),</span><br><span class="line">  <span class="string">&quot;RaisedButtonDemoPage&quot;</span>: (context) =&gt; RaisedButtonDemoPage(),</span><br><span class="line">  <span class="string">&quot;FlatButtonDemoPage&quot;</span>: (context) =&gt; FlatButtonDemoPage(),</span><br><span class="line">  <span class="string">&quot;OutlineButtonDemoePage&quot;</span>: (context) =&gt; OutlineButtonDemoePage(),</span><br><span class="line">  <span class="string">&quot;IconButtonDemoPage&quot;</span>: (context) =&gt; IconButtonDemoPage(),</span><br><span class="line">  <span class="string">&quot;ContainerDemoPage&quot;</span>: (context) =&gt; ContainerDemoPage(),</span><br><span class="line">  <span class="string">&quot;StatefulWidgetDemoPage&quot;</span>: (context) =&gt; StatefulWidgetDemoPage(),</span><br><span class="line">  <span class="string">&quot;TextFieldDemoPage&quot;</span>: (context) =&gt; TextFieldDemoPage(),</span><br><span class="line">  <span class="string">&quot;ImageDemoPage&quot;</span>: (context) =&gt; ImageDemoPage(),</span><br><span class="line">  <span class="string">&quot;ColumnDemoPage&quot;</span>: (context) =&gt; ColumnDemoPage(),</span><br><span class="line">  <span class="string">&quot;RowDemoPage&quot;</span>: (context) =&gt; RowDemoPage(),</span><br><span class="line">  <span class="string">&quot;FlexibleDemoPage&quot;</span>: (context) =&gt; FlexibleDemoPage(),</span><br><span class="line">  <span class="string">&quot;WrapDemoPage&quot;</span>: (context) =&gt; WrapDemoPage(),</span><br><span class="line">  <span class="string">&quot;ListViewDemoPage&quot;</span>: (context) =&gt; ListViewDemoPage(),</span><br><span class="line">  <span class="string">&quot;GridViewDemoPage&quot;</span>: (context) =&gt; GridViewDemoPage(),</span><br><span class="line">  <span class="string">&quot;BottomNavigationBarDemoPage&quot;</span>: (context) =&gt;</span><br><span class="line">      BottomNavigationBarDemoPage(),</span><br><span class="line">  <span class="string">&quot;RouterDemoPage&quot;</span>: (context) =&gt; RouterDemoPage(),</span><br><span class="line">  <span class="string">&quot;RouterDemoPage2&quot;</span>: (context) =&gt; RouterDemoPage2(),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其中<code>key</code>为<code>/</code>对应的<code>Value</code>是整个Flutter项目的入口页面，这里需要另外一个很重要的参数<code>initialRoute</code>来配合使用<br>我们给<code>initialRoute</code>参数传值如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initialRoute: <span class="string">&quot;/&quot;</span>,</span><br></pre></td></tr></table></figure><p>这里表示的是Flutter项目的入口页面对应的<code>key</code>是<code>/</code>，那么就会找到在<code>routes</code>中<code>/</code>对应的页面，也就是<code>MainPage()</code></p><blockquote><p>需要注意的是：<br>默认我们新创建的Flutter项目中<code>MaterialApp</code>是带有<code>home</code>这个参数的，它也表示也是入口页面。如果我们想要要使用路由Map的方式来管理路由，一定需要把<code>home</code>参数删除掉。</p></blockquote><h3 id="Navigator-pushNamed"><a href="#Navigator-pushNamed" class="headerlink" title="Navigator.pushNamed"></a>Navigator.pushNamed</h3><p>在我们声明好路由Map之后，我们就可以传入前面的<code>key</code>的值来实现页面的跳转工作，这个时候我们需要借助的API是<code>Navigator.pushNamed</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"> <span class="keyword">static</span> Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span><br><span class="line">   BuildContext context,    <span class="comment">/// <span class="markdown">context</span></span></span><br><span class="line">   <span class="built_in">String</span> routeName, &#123;     <span class="comment">/// <span class="markdown">路由Map中 key 的值</span></span></span><br><span class="line">   <span class="built_in">Object</span> arguments,        <span class="comment">/// <span class="markdown">参数</span></span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">   <span class="keyword">return</span> Navigator.of(context).pushNamed&lt;T&gt;(routeName, arguments: arguments);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>只需要传入路由Map中<code>key</code>的值就可以实现跳转。<br>代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">&quot;RouterDemoPage2&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>由于我们是跨平台开发，Flutter帮助我们实现了跳转时候的转场动画，在iOS中动画是从右侧滑入到左侧，返回的时候同样是由左侧滑出到右侧。在Android则是由下方弹出显示到上方，返回的时候是由上方退出到下方弹出。</p></blockquote><h3 id="跳转传值"><a href="#跳转传值" class="headerlink" title="跳转传值"></a>跳转传值</h3><p>很多时候我们希望跳转的时候可以传值过去，这个时候我们可以通过自定义<code>MaterialPageRoute</code>来实现传值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MaterialPageRoute(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">builder 方法</span></span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="comment">/// <span class="markdown">配置信息</span></span></span><br><span class="line">    RouteSettings settings,</span><br><span class="line">    <span class="comment">///  <span class="markdown">默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</span></span></span><br><span class="line">    <span class="keyword">this</span>.maintainState = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">///  <span class="markdown">表示新页面是否是全屏展示，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入</span></span></span><br><span class="line">    <span class="built_in">bool</span> fullscreenDialog = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们只需要在构建新的页面的时候传入我们想要传递的参数即可</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).push(MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RouterDemoPage3(passText: <span class="string">&quot;Fulade&quot;</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="返回传值"><a href="#返回传值" class="headerlink" title="返回传值"></a>返回传值</h3><p>传递返回值我们使用<code>Navigator</code>的<code>pop</code>方法即可</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context, <span class="string">&quot;pop value&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>pop</code>方法接收一个参数为返回的携带的参数，如果我们有多个参数，可以把它封装为<code>List</code>或<code>Map</code>即可。</p><p>返回值我们需要在<code>push</code>方法后面使用<code>then</code>来接收</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context)</span><br><span class="line">    .push(MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RouterDemoPage3(passText: <span class="string">&quot;Fulade&quot;</span>);</span><br><span class="line">&#125;)).then((value) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    title = value;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><code>then</code>函数 涉及到了Dart语音中很重要的概念 await 和future，后面有机会我们再来详细的说。</p></blockquote><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>router_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Router </tag>
            
            <tag> Flutter Navigator </tag>
            
            <tag> Flutter 导航栏 </tag>
            
            <tag> Flutter Router传值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 3-1】Flutter进阶教程——底部导航栏BottomNavigationBar使用</title>
      <link href="flutter-high-bottomnavigationbar-widget-3-1.html"/>
      <url>flutter-high-bottomnavigationbar-widget-3-1.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="BottomNavigationBar"><a href="#BottomNavigationBar" class="headerlink" title="BottomNavigationBar"></a>BottomNavigationBar</h3><p><code>BottomNavigationBar</code> 和 <code>BottomNavigationBarItem</code> 配合来共同展示Flutter里面的底部状态栏，底部状态栏是在移动端很重要的控件。</p><p>先看一下 <code>BottomNavigationBar</code>构造方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BottomNavigationBar(&#123;</span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">BottomNavigationBarItem 数组</span></span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.items,</span><br><span class="line">    <span class="comment">/// <span class="markdown">点击事件方法</span></span></span><br><span class="line">    <span class="keyword">this</span>.onTap,</span><br><span class="line">    <span class="comment">/// <span class="markdown">当前选中的 元素下标</span></span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">///  <span class="markdown">底部导航栏的Z坐标</span></span></span><br><span class="line">    <span class="keyword">this</span>.elevation,</span><br><span class="line">    <span class="comment">/// <span class="markdown">默认是 BottomNavigationBarType.shifting 一般我们使用 BottomNavigationBarType.fixed</span></span></span><br><span class="line">    <span class="keyword">this</span>.type,</span><br><span class="line">    <span class="comment">/// <span class="markdown">选中项目颜色的值</span></span></span><br><span class="line">    Color fixedColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">背景颜色</span></span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">BottomNavigationBarItem图标的大小</span></span></span><br><span class="line">    <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">选中时图标和文字的颜色</span></span></span><br><span class="line">    Color selectedItemColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">未选中时图标和文字的颜色</span></span></span><br><span class="line">    <span class="keyword">this</span>.unselectedItemColor,</span><br><span class="line">    <span class="comment">// 选中时的子Item的样式</span></span><br><span class="line">    <span class="keyword">this</span>.selectedIconTheme,</span><br><span class="line">    <span class="comment">/// <span class="markdown">未选中时的子Item的样式</span></span></span><br><span class="line">    <span class="keyword">this</span>.unselectedIconTheme,</span><br><span class="line">    <span class="comment">// 选中时字体大小</span></span><br><span class="line">    <span class="keyword">this</span>.selectedFontSize = <span class="number">14.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">未选中时的字体大小</span></span></span><br><span class="line">    <span class="keyword">this</span>.unselectedFontSize = <span class="number">12.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">选中的时候的字体样式</span></span></span><br><span class="line">    <span class="keyword">this</span>.selectedLabelStyle,</span><br><span class="line">    <span class="comment">/// <span class="markdown">未选中时的字体样式</span></span></span><br><span class="line">    <span class="keyword">this</span>.unselectedLabelStyle,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否为未选择的BottomNavigationBarItem显示标签</span></span></span><br><span class="line">    <span class="keyword">this</span>.showSelectedLabels = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">//// <span class="markdown">是否为选定的BottomNavigationBarItem显示标签</span></span></span><br><span class="line">    <span class="keyword">this</span>.showUnselectedLabels,</span><br><span class="line">    <span class="comment">/// <span class="markdown">pc端或web端使用</span></span></span><br><span class="line">    <span class="keyword">this</span>.mouseCursor,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们来做一个点击底部状态栏按钮切换颜色的Demo</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BottomNavigationBarDemoPageState</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BottomNavigationBarDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> selectedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">List</span>&lt;Container&gt; containerList = [</span><br><span class="line">    Container(</span><br><span class="line">      color: Colors.red,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      color: Colors.yellow,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">    )</span><br><span class="line">  ];</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        title: Text(<span class="string">&quot;BottomNavigationBarDemo&quot;</span>),</span><br><span class="line">        backgroundColor: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      body: containerList[selectedIndex],</span><br><span class="line">      bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">        <span class="comment">/// <span class="markdown">这个很重要</span></span></span><br><span class="line">        type: BottomNavigationBarType.fixed,</span><br><span class="line">        currentIndex: selectedIndex,</span><br><span class="line">        onTap: (index) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            selectedIndex = index;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        items: &lt;BottomNavigationBarItem&gt;[</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">            title: Text(<span class="string">&#x27;F1&#x27;</span>),</span><br><span class="line">            icon: Icon(Icons.home),</span><br><span class="line">          ),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">            title: Text(<span class="string">&#x27;F2&#x27;</span>),</span><br><span class="line">            icon: Icon(Icons.book),</span><br><span class="line">          ),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">            title: Text(<span class="string">&#x27;F3&#x27;</span>),</span><br><span class="line">            icon: Icon(Icons.school),</span><br><span class="line">          ),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">            title: Text(<span class="string">&#x27;F4&#x27;</span>),</span><br><span class="line">            icon: Icon(Icons.perm_identity),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Scaffold</code>接收一个<code>BottomNavigationBar</code>作为<code>bottomNavigationBar</code>的参数，然后<code>BottomNavigationBar</code>接收一个<code>items</code>的数组，这个数组里面传入了4个<code>BottomNavigationBarItem</code>对象分别命名为<code>F1</code>、<code>F2</code>、<code>F3</code>、<code>F4</code></p></li><li><p><code>type</code>参数传入的是<code>BottomNavigationBarType.fixed</code>，默认是<code>BottomNavigationBarType.shifting</code>，默认的效果是 只有在选中<code>BottomNavigationBarItem</code>时才会显示文字。设置成<code>BottomNavigationBarType.fixed</code>非选中状态下也会显示文字和图标</p></li><li><p><code>onTap</code>实现的是一个方法，参数是被点击的当前<code>BottomNavigationBarItem</code>的下标，在这里被点击后调用<code>setState</code>来刷新页面的颜色</p></li></ul><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_29_bottom_navigation_bar.gif" alt="2020_01_29_bottom_navigation_bar"></p><p>日常开发中以上效果基本能满足大多数需求<br>如果想要自定义下面Icon的样式，可以使用 <a href="https://material.io/components/app-bars-bottom/android#anatomy-and-key-properties">BottomAppBar</a></p><p>这里也介绍两个不错的库</p><ul><li><p>tab_bar_animation </p><p>链接: <a href="https://github.com/tunitowen/tab_bar_animation">https://github.com/tunitowen/tab_bar_animation</a><br>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_29_bottom_th2.gif" alt="2020_01_29_bottom_th2"></p></li><li><p>simpleanimations<br>链接: <a href="https://github.com/TechieBlossom/simpleanimations">https://github.com/TechieBlossom/simpleanimations</a><br>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_29_bottom_th1.gif" alt="2020_01_29_bottom_th1"></p></li></ul><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>bottom_navigation_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter BottomNavigationBar </tag>
            
            <tag> Flutter 进阶教程 </tag>
            
            <tag> Flutter 项目 </tag>
            
            <tag> Flutter 底部导航栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-12】Flutter手把手教程UI布局和Widget——网格列表GridView</title>
      <link href="flutter-ui-gridview-widget-2-12.html"/>
      <url>flutter-ui-gridview-widget-2-12.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h3><p><code>GridView</code> 是一个好用的网格布局控件，它的很多属性跟前面提到的ListView是一样的，重复的属性这里就不赘述了。我们重点了解初始化方法<code>GridView.count</code>的使用，还有两个代理<code>SliverGridDelegateWithFixedCrossAxisCount</code>、<code>SliverGridDelegateWithMaxCrossAxisExtent</code>的参数以及使用。</p><h3 id="GridView-count"><a href="#GridView-count" class="headerlink" title="GridView.count"></a>GridView.count</h3><p>我们先来看<code>GridView.count</code>的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">key </span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">布局方向</span></span></span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否 倒序显示</span></span></span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">ScrollController用于控制滚动位置和监听滚动事件</span></span></span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否使用默认的controller</span></span></span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    <span class="comment">/// <span class="markdown">滚动效果  可以通过此参数 设置 GridView 不可滚动</span></span></span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否根据子控件的总长度来设置 GridView 的长度，默认值为false</span></span></span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">///  <span class="markdown">padding</span></span></span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="comment">/// <span class="markdown">交叉轴 子控件的个数</span></span></span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">int</span> crossAxisCount,</span><br><span class="line">    <span class="comment">/// <span class="markdown">主轴方向的间距</span></span></span><br><span class="line">    <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">交叉轴方向子元素的间距</span></span></span><br><span class="line">    <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的宽高比例</span></span></span><br><span class="line">    <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">// 在 关闭屏幕时 是否释放子控件</span></span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否 避免列表项重绘</span></span></span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">该属性表示是否把子控件包装在IndexedSemantics里，用来提供无障碍语义</span></span></span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 预加载子控件的个数</span></span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的数组</span></span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的数量</span></span></span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">    DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span><br><span class="line">    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里要说的是有两个比较重要的参数<code>crossAxisSpacing</code>和<code>childAspectRatio</code>，这个两个参数是用来定义子控件大小的。</p><p>假如我们设置 <code>crossAxisSpacing = 2</code>,那么每一行就会显示<code>2</code>个控件，而且控件的高度由<code>childAspectRatio</code>来确定。<br><code>childAspectRatio</code>表示子控件的宽高比，假如我们设置为<code>2 / 3</code>，那么高就是宽的1.5倍，这样就可以计算子控件的大小了，并且按照 <code>GridView</code>设置好的方向来排列和布局子控件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">    crossAxisCount: <span class="number">3</span>,</span><br><span class="line">    childAspectRatio: <span class="number">2</span> / <span class="number">3</span>,</span><br><span class="line">    children: <span class="built_in">List</span>.generate(</span><br><span class="line">        <span class="number">50</span>,</span><br><span class="line">        (index) &#123;</span><br><span class="line">        <span class="keyword">return</span> Card(</span><br><span class="line">            child: Container(</span><br><span class="line">            color: Colors.green,</span><br><span class="line">                child: Center(</span><br><span class="line">                    child: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">        );</span><br><span class="line">        &#125;,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_gridview_count.png" alt="2021_01_16_gridview_count"></p><h4 id="SliverGridDelegateWithFixedCrossAxisCount"><a href="#SliverGridDelegateWithFixedCrossAxisCount" class="headerlink" title="SliverGridDelegateWithFixedCrossAxisCount"></a>SliverGridDelegateWithFixedCrossAxisCount</h4><p>除了<code>GridView.count()</code>这种构造方法，我们很多时候常用一个构造方法是<code>GridView.builder(gridDelegate: itemBuilder:)</code>，它接收一个<code>delegate</code>对象，并且跟<code>ListView</code>一样接收一个<code>itemBuilder</code>方法。<br><code>SliverGridDelegateWithFixedCrossAxisCount</code>的构造方法如下：  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SliverGridDelegateWithFixedCrossAxisCount(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.crossAxisCount,</span><br><span class="line">  <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看得出来它是把<code>GridView.count()</code>的几个参数封装了一下，具体的用法和效果跟<code>GridView.count()</code>一样，这里就不赘述了。</p><p><code>SliverGridDelegateWithFixedCrossAxisCount</code>在很多情况下都能满足我们的布局需求，但是有一个不足，因为它设置的每一行数是一个定值。<br>当我们把屏幕旋转，此时原来的高度会变为现在的宽度，效果就会如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_gridview_la.jpg" alt="2021_01_16_gridview_la"></p><p>所以我们可以使用下面<code>delegate</code>来解决这个问题。 </p><h4 id="SliverGridDelegateWithMaxCrossAxisExtent"><a href="#SliverGridDelegateWithMaxCrossAxisExtent" class="headerlink" title="SliverGridDelegateWithMaxCrossAxisExtent"></a>SliverGridDelegateWithMaxCrossAxisExtent</h4><p>我们可以在<code>GridView.builder(gridDelegate: itemBuilder:)</code>方法内传入另外一个参数<code>SliverGridDelegateWithMaxCrossAxisExtent</code></p><p>构造方法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGridDelegateWithMaxCrossAxisExtent(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.maxCrossAxisExtent,</span><br><span class="line">    <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>这里有一个比较重要的参数就是<code>maxCrossAxisExtent</code>，这个值表示的是子控件最大的宽度是多少。<br>举个例子：<br>手机的屏幕宽度为<code>375</code>，子控件之间的间距为<code>0</code>，<code>maxCrossAxisExtent</code>的值设置为<code>100</code>，那么我们知道子控件的宽度取值区间在<code>0~100</code>之间。</p><ul><li>假设我们布局<code>3</code>个子控件，<code>3</code> 乘以最大值<code>100</code>等于<code>300</code>，很明显是不能满足布局在<code>375</code>的宽度上的。</li><li>假设我们布局<code>4</code>个子控件，<code>4</code>乘以<code>100</code>等于<code>400</code>，<code>400</code> 大于 <code>375</code>。我们知道宽度的取值区间在<code>0~100</code>，<code>375 / 4 = 93.75</code>既满足了宽度小于<code>100</code>，又满足了可以充满<code>375</code>的宽度，那么子控件的个数为 <code>4</code>宽度为<code>93.75</code></li></ul><p>这就是<code>maxCrossAxisExtent</code>的用法。</p><p>其实<code>GridView</code>还可以做瀑布流效果，感兴趣的同学可以去查一下。</p><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>gridview_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
            <tag> Flutter Flexible </tag>
            
            <tag> Flutter GridView </tag>
            
            <tag> Flutter ListView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-11】Flutter手把手教程UI布局和Widget——列表ListView</title>
      <link href="flutter-ui-listview-widget-2-11.html"/>
      <url>flutter-ui-listview-widget-2-11.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p><code>ListView</code>是在移动端非常常见的控件，在大多数的展示场景中都离不开<code>ListView</code>。在<code>Flutter</code>中对<code>ListView</code>的封装也非常好，简单几行代码就可以满足我们布局一个滚动列表的需求。</p><p>先来看一下构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ListView(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">布局方向</span></span></span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否 倒序显示</span></span></span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">ScrollController用于控制滚动位置和监听滚动事件</span></span></span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否使用默认的controller</span></span></span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    <span class="comment">/// <span class="markdown">滚动效果  可以通过此参数 设置 ListView 不可滚动</span></span></span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否根据子控件的总长度来设置ListView的长度，默认值为false</span></span></span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">///  <span class="markdown">padding</span></span></span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件高度</span></span></span><br><span class="line">    <span class="keyword">this</span>.itemExtent,</span><br><span class="line">    <span class="comment">// 在 关闭屏幕时 是否释放子控件</span></span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">是否 避免列表项重绘</span></span></span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">该属性表示是否把子控件包装在IndexedSemantics里，用来提供无障碍语义</span></span></span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 预加载子控件的个数</span></span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件数组</span></span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的个数</span></span></span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">    DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span><br><span class="line">    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h4><p><code>Flutter</code>给我们提供了四种构造<code>ListView</code>的方法，有<code>ListView()</code>、<code>ListView.builder()</code>、<code>ListView.separated()</code>、<code>ListView.custom()</code>、</p><table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>ListView()</td><td>静态构造方法 初始化之前需要确定数据源的大小</td></tr><tr><td>ListView.builder()</td><td>动态构造方法  可动态传入数据</td></tr><tr><td>ListView.separated()</td><td>动态构造方法  可动态传入数据 可动态定制分割线的样式</td></tr><tr><td>ListView.custom()</td><td>动态构造方法 需要传入<code>SliverChildDelegate</code>来做动态生成</td></tr></tbody></table><p><strong>静态构造方法和动态构造方法</strong><br><code>ListView()</code>是初始化的时候需要确定数据源的大小，一旦初始化成功后不能再次动态的插入数据。<br><code>ListView.builder()</code>、<code>ListView.separated()</code>、<code>ListView.custom()</code>可以动态的插入数据，且能够更小的节省内存空间。<br>我们来看以下代码：  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Flexible(</span><br><span class="line">    child: ListView(</span><br><span class="line">        children: <span class="built_in">List</span>.generate(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            (index) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;without builder index = <span class="subst">$index</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Container(</span><br><span class="line">                height: <span class="number">60</span>,</span><br><span class="line">                child: Card(</span><br><span class="line">                        color: Colors.blue,</span><br><span class="line">                        child: Center(child: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>)),</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">),</span><br><span class="line">Flexible(</span><br><span class="line">    child: ListView.builder(</span><br><span class="line">        itemCount: <span class="number">10</span>,</span><br><span class="line">        itemExtent: <span class="number">60</span>,</span><br><span class="line">        itemBuilder: (BuildContext contenxt, <span class="built_in">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;builder index = <span class="subst">$index</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Container(</span><br><span class="line">                height: <span class="number">60</span>,</span><br><span class="line">                child: Card(</span><br><span class="line">                color: Colors.red,</span><br><span class="line">                child: Center(child: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>)),</span><br><span class="line">                ),</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>同样是需要初始化10个子控件，我们分别在<code>List.generate</code>方法和<code>itemBuilder</code>方法中做了打印操作<br>输出如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flutter: without builder index = <span class="number">0</span></span><br><span class="line">flutter: without builder index = <span class="number">1</span></span><br><span class="line">flutter: without builder index = <span class="number">2</span></span><br><span class="line">flutter: without builder index = <span class="number">3</span></span><br><span class="line">flutter: without builder index = <span class="number">4</span></span><br><span class="line">flutter: without builder index = <span class="number">5</span></span><br><span class="line">flutter: without builder index = <span class="number">6</span></span><br><span class="line">flutter: without builder index = <span class="number">7</span></span><br><span class="line">flutter: without builder index = <span class="number">8</span></span><br><span class="line">flutter: without builder index = <span class="number">9</span></span><br><span class="line">flutter: builder index = <span class="number">0</span></span><br><span class="line">flutter: builder index = <span class="number">1</span></span><br><span class="line">flutter: builder index = <span class="number">2</span></span><br><span class="line">flutter: builder index = <span class="number">3</span></span><br><span class="line">flutter: builder index = <span class="number">4</span></span><br><span class="line">flutter: builder index = <span class="number">5</span></span><br><span class="line">flutter: builder index = <span class="number">6</span></span><br><span class="line">flutter: builder index = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>由输出的log可见，<code>builder</code>方法只初始化了7个子控件，<code>ListView()</code>方法完整的初始化了10个子控件。<br><code>builder</code>方法是<strong>在需要使用的时候</strong>才会初始化，当页面滚动到第9个子控件的时候，这个时候才会初始化第9个子控件。<br>这样做的优势是：当我们的列表数据量很大的时候(比如说有成百上千个数据)，我们只初始化几个来满足页面的显示需求，其他的控件在需要的时候，再做初始化这样就大大的帮助我们节省内存空间。</p><h4 id="scrollDirection"><a href="#scrollDirection" class="headerlink" title="scrollDirection"></a>scrollDirection</h4><p><code>ListView</code>同时具备了水平布局和垂直布局的能力，我们只需要给<code>scrollDirection</code>设置不同的参数即可。<br><code>scrollDirection</code>接收的参数值有两个<code>Axis.vertical</code>和<code>Axis.horizontal</code>  </p><p><strong>Axis.vertical</strong><br>效果如下<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_horizontal.jpg" alt="2021_01_16_listview_horizontal"></p><p><strong>Axis.horizontal</strong><br>效果如下<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_vertical.jpg" alt="2021_01_16_listview_vertical"></p><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>参数<code>reverse</code>可以控制列表是按正序显示还是倒序显示。</p><p><strong>reverse = true</strong><br>表示倒序显示<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_reverse_true.png" alt="2021_01_16_listview_reverse_true"></p><p><strong>reverse = false</strong><br>表示正序显示<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_reverse_false.png" alt="2021_01_16_listview_reverse_false"></p><h4 id="physics"><a href="#physics" class="headerlink" title="physics"></a>physics</h4><p>某些情况下我们并不想要<code>ListView</code>可以滚动，只要把<code>physics</code>设置为<code>NeverScrollableScrollPhysics</code>即可。<br><code>physics</code>还有其他两个比较重要的值：<br><code>ClampingScrollPhysics</code>：在Android设备上有微光效果。<br><code>BouncingScrollPhysics</code>：在iOS设备上有弹性效果。</p><h4 id="separated"><a href="#separated" class="headerlink" title="separated"></a>separated</h4><p>在<code>ListView.separated()</code>构造函数中，我们可以传入一个自定义的<code>Divider</code>来作作为分隔的样式<br>这里我们来看一下<code>Divider</code>都有哪些参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Divider(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="comment">/// <span class="markdown">颜色的 高度</span></span></span><br><span class="line">    <span class="keyword">this</span>.thickness,</span><br><span class="line">    <span class="comment">/// <span class="markdown">开头处的缩进</span></span></span><br><span class="line">    <span class="keyword">this</span>.indent,</span><br><span class="line">    <span class="comment">/// <span class="markdown">结束处的缩进 </span></span></span><br><span class="line">    <span class="keyword">this</span>.endIndent,</span><br><span class="line">    <span class="comment">/// <span class="markdown">颜色</span></span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>height = 0</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_height_0.jpg" alt="2021_01_16_listview_height_0"></p><p><strong>height = 10</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_height_10.jpg" alt="2021_01_16_listview_height_10"></p><p><strong>thinkness = 10</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_thinkness_10.jpg" alt="2021_01_16_listview_thinkness_10"></p><p><strong>indent = 100</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_indent_100.jpg" alt="2021_01_16_listview_indent_100"></p><p><strong>end = 100</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_16_listview_end_100.jpg" alt="2021_01_16_listview_end_100"></p><p>想体验以上示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>listview_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
            <tag> Flutter Flexible </tag>
            
            <tag> Flutter ListView </tag>
            
            <tag> Flutter Warp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-10】Flutter手把手教程UI布局和Widget——流式布局Wrap</title>
      <link href="flutter-ui-warp-widget-2-10.html"/>
      <url>flutter-ui-warp-widget-2-10.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><p>在<code>Flutter</code>中<code>Wrap</code>是流式布局控件，<code>Row</code>和<code>Column</code>在布局上是很好用，但是有一个缺点，如果当子控件数量过多导致<code>Row</code>或<code>Column</code>装载不下的时候，就会出现UI页面上的错误。<code>Wrap</code>可以完美的避免这个问题，当控件过多一行显示不全的时候，<code>Wrap</code>可以换行显示。  </p><p>当然<code>Wrap</code>跟<code>Row</code>和<code>Column</code>有着很多相似的地方。<br>我们先来看<code>Wrap</code>的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">    <span class="comment">// Key</span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 子控件显示方向， 有垂直方向 水平方向两个值</span></span><br><span class="line">    <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的 布局方式  跟Column的 mainAxisalignment类似 </span></span></span><br><span class="line">    <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件 主轴方向间距</span></span></span><br><span class="line">    <span class="keyword">this</span>.spacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件 交叉方向的 布局方式</span></span></span><br><span class="line">    <span class="keyword">this</span>.runAlignment = WrapAlignment.start,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件 交叉方向间距</span></span></span><br><span class="line">    <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">交叉轴的对齐方式 与 Column 的crossAxisAlignment 一样</span></span></span><br><span class="line">    <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">    <span class="comment">/// <span class="markdown">书写方向 与 Column的 textDirection 一样</span></span></span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="comment">/// <span class="markdown">Wrap交叉轴方向上子控件的布局方向</span></span></span><br><span class="line">    <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="comment">/// <span class="markdown">裁剪方式</span></span></span><br><span class="line">    <span class="keyword">this</span>.clipBehavior = Clip.hardEdge,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>下面我们就来看看这些参数 </p><h4 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h4><p><code>direction</code>有两个参数值<code>Axis.horizontal</code>和<code>Axis.vertical</code>，很明显它管理着<code>Wrap</code>的是水平布局还是垂直布局。<br><code>Axis.horizontal</code>表示子控件按水平方向布局，<code>Axis.vertical</code>表示子控件按垂直方向布局显示。</p><p><strong>Axis.horizontal</strong><br>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_horizontal.png" alt="20202_01_15_wrap_horizontal"></p><p><strong>Axis.vertical</strong><br>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_vertical.png" alt="20202_01_15_wrap_vertical"></p><h4 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h4><p><code>alignment</code>接收一个<code>WrapAlignment</code>类型的枚举，<code>WrapAlignment</code>共有六个枚举值，如下：</p><blockquote><p><code>WrapAlignment</code>的枚举值与效果与 <code>Column</code> 的 <code>mainAxisAlignment</code>效果一样，想了解的可以看之前的<a href="https://juejin.cn/post/6916870555060666376">文章</a>  </p></blockquote><table><thead><tr><th>枚举值</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>与 开始的位置对齐</td></tr><tr><td>end</td><td>与 结束的位置对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>spaceBetween</td><td>把剩余的空间拆分成n-1份(n是子控件的个数) 每一份都插入到子控件之间</td></tr><tr><td>spaceEvenly</td><td>把剩余的空间拆分成n+1份(n是子控件的个数) 然后均匀分布</td></tr><tr><td>spaceAround</td><td>把剩余空间拆分成 2n 份(n是子控件的个数) 每个子控件上下各放一份</td></tr></tbody></table><p><strong>WrapAlignment.start</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_start.jpg" alt="20202_01_15_wrap_alignment_start"></p><p><strong>WrapAlignment.center</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_center.jpg" alt="20202_01_15_wrap_alignment_center"></p><p><strong>WrapAlignment.end</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_end.jpg" alt="20202_01_15_wrap_alignment_end"></p><p><strong>WrapAlignment.spaceBetween</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_between.jpg" alt="20202_01_15_wrap_alignment_between">  </p><p><strong>WrapAlignment.spaceEvenly</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_spaceEvenly.jpg" alt="20202_01_15_wrap_alignment_spaceEvenly">  </p><p><strong>WrapAlignment.spaceAround</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/20202_01_15_wrap_alignment_spaceAround.jpg" alt="20202_01_15_wrap_alignment_spaceAround">  </p><h3 id="runAlignment"><a href="#runAlignment" class="headerlink" title="runAlignment"></a>runAlignment</h3><p><code>runAlignment</code>接收一个<code>WrapAlignment</code>类型的枚举，<code>WrapAlignment</code>共有六个枚举值（跟<code>alignment</code>的枚举值是一样的），<code>runAlignment</code>控制是的是<code>Wrap</code>布局交叉方向的对齐方式。<br>如果<code>Wrap</code>的是水平方向布局，<code>runAlignment</code>控制的就是<code>Wrap</code>垂直方向的对齐方式。</p><h3 id="verticalDirection"><a href="#verticalDirection" class="headerlink" title="verticalDirection"></a>verticalDirection</h3><p><code>verticalDirection</code>有两个值<code>VerticalDirection.down</code>和<code>VerticalDirection.up</code>，表示从哪个方向开始布局。<br><strong>VerticalDirection.down</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_down.jpg" alt="2021_01_15_wrap_down"></p><p><strong>VerticalDirection.up</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_up.jpg" alt="2021_01_15_wrap_up">  </p><blockquote><p>注意 当设置为<code>VerticalDirection.up</code>的时候，第一个控件也就是<code>Number 0</code>是从最低端最左侧开始的。  </p></blockquote><h3 id="spacing-和-runSpacing"><a href="#spacing-和-runSpacing" class="headerlink" title="spacing 和 runSpacing"></a>spacing 和 runSpacing</h3><p><code>spacing</code>表示子控件主轴方向间距，<code>runSpacing</code>子控件在交叉方向间距。<br>在一个水平方向布局的<code>Wrap</code>为中，<code>spacing</code>表示的就是水平方向子控件之间的间距，<code>runSpacing</code>表示的就是子控件在垂直方向上的间距。</p><p><strong>space</strong><br><code>space</code>等于<code>10</code>的样子<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_space_10.jpg" alt="2021_01_15_wrap_space_10"></p><p><code>space</code>等于<code>40</code>的样子<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_space_40.jpg" alt="2021_01_15_wrap_space_40"><br><strong>runSpacing</strong><br><code>runSpacing</code>等于<code>10</code>的样子<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_runSpace_10.jpg" alt="2021_01_15_wrap_runSpace_10"></p><p><code>runSpacing</code>等于<code>40</code>的样子<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_15_wrap_runSpace_40.jpg" alt="2021_01_15_wrap_runSpace_40"></p><p>想体验以上示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>wrap_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
            <tag> Flutter Flexible </tag>
            
            <tag> Flutter Wrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-9】Flutter手把手教程UI布局和Widget——弹性布局控件Flexible</title>
      <link href="flutter-ui-flexible-widget-2-9.html"/>
      <url>flutter-ui-flexible-widget-2-9.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Flexible"><a href="#Flexible" class="headerlink" title="Flexible"></a>Flexible</h3><p>Flexible可以帮助Row、Column、Flex的子控件充满父控件，它的用法很灵活，也具有权重的属性。跟Flexible相类似的控件还有Expanded。<br>先来看<code>Flexible</code>的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Flexible(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 默认 flex 的值为 1</span></span><br><span class="line">    <span class="keyword">this</span>.flex = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">默认 fit参数为 FlexFit.loose 表示子控件可以以最小的大小来布局</span></span></span><br><span class="line">    <span class="keyword">this</span>.fit = FlexFit.loose,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h4 id="按比例布局"><a href="#按比例布局" class="headerlink" title="按比例布局"></a>按比例布局</h4><p><code>Flexible</code>的参数<code>flex</code>是表示比例的值。<br>假如我们在<code>Column</code>内部有三个子控件，每个控件的<code>flex</code>值都设置为<code>1</code><br>那么这三个子控件的高度都是<code>Column</code>高度(Row的情况下就是宽度)的三分之一，也就是三个子控件均分了<code>Column</code>的高度(Row的情况下就是宽度)  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: [</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_1_1_1.png" alt="2020_01_14_flexible_1_1_1"></p><p>然后我们把<code>flex</code>的值分别设置为<code>1</code>、<code>2</code>、<code>3</code>，那么这个三个控件的高度分别是五分之一、五分之二、五分之三的高度  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: [</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">3</span>,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_1_2_3.png" alt="2020_01_14_flexible_1_2_3"></p><h4 id="FlexFit-loose-和-FlexFit-tight"><a href="#FlexFit-loose-和-FlexFit-tight" class="headerlink" title="FlexFit.loose 和 FlexFit.tight"></a>FlexFit.loose 和 FlexFit.tight</h4><table><thead><tr><th>枚举值</th><th>描述</th></tr></thead><tbody><tr><td>loose</td><td>loose表示允许以最小的高度(Row下是宽度)布局 可以忽略flex的值</td></tr><tr><td>tight</td><td>必须以设置的最大的flex值来显示</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: [</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(</span><br><span class="line">            <span class="string">&quot;images/image_demo.jpg&quot;</span>,</span><br><span class="line">            height: <span class="number">80</span>,</span><br><span class="line">            ),</span><br><span class="line">            fit: FlexFit.loose,</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们给第二个控件设置的<code>flex</code>值为2，给<code>Image</code>设置的高度为<code>80</code>，给<code>fit</code>的值设置为<code>FlexFit.loose</code>，这个时候优先起到作用的是<code>FlexFit.loose</code>，<code>flex</code>的值会被忽略，所以这里的<code>Image</code>会以高度为<code>80</code>的大小来显示。<br>效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_loose.png" alt="2020_01_14_flexible_loose"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: [</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(</span><br><span class="line">            <span class="string">&quot;images/image_demo.jpg&quot;</span>,</span><br><span class="line">            height: <span class="number">80</span>,</span><br><span class="line">            ),</span><br><span class="line">            fit: FlexFit.tight,</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们把<code>FlexFit.loose</code>改为<code>FlexFit.tight</code>，此时就会忽略当前设置的高度<code>80</code>，直接使用比例来显示。<br>效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_tight.png" alt="2020_01_14_flexible_tight"></p><h4 id="优先布局"><a href="#优先布局" class="headerlink" title="优先布局"></a>优先布局</h4><p>如果我们将<code>flex</code>的值设置为0，此时<code>Flexible</code>并不是被分配0的高度，而是<code>flex</code>值为0的<code>Flexible</code>会优先布局且会尽量大的占用<code>Column</code>的高度</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    children: [</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">1</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            flex: <span class="number">0</span>,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_flex_00.png" alt="2020_01_14_flexible_flex_00"><br>可以看到第三个<code>Flexible</code>是高度最大的，因为它优先占用最高的高度。</p><h4 id="填充剩余的空间"><a href="#填充剩余的空间" class="headerlink" title="填充剩余的空间"></a>填充剩余的空间</h4><p>很多情况下在<code>Column</code>内不止是有<code>Flexible</code>控件，还有像<code>Container</code>这种控件。在二者都存在的情况下，<code>Container</code>会优先布局并占用自己需要的高度，剩余的高度由<code>Flexible</code>控件来填充满。如果有多个<code>Flexible</code>控件，它们会按自己设置的<code>flex</code>值来均分剩余的高度。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">    children: [</span><br><span class="line">        Container(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">            child: Image.asset(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">        ),</span><br><span class="line">        Flexible(</span><br><span class="line">            child: Container(</span><br><span class="line">                decoration: BoxDecoration(color: Colors.green),</span><br><span class="line">                width: <span class="number">300</span>,</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_14_flexible_flex_space_full.png" alt="2020_01_14_flexible_flex_space_full"></p><p>想体验以上示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>flexible_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
            <tag> Flutter Flexible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-8】Flutter手把手教程UI布局和Widget——水平布局控件Row</title>
      <link href="flutter-ui-row-widget-2-8.html"/>
      <url>flutter-ui-row-widget-2-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h3><p><code>Row</code>是在Flutter中常见的布局控件，它负责水平方向布局。Column负责垂直方向布局，二者都是继承于<code>Flex</code>，类似于<code>iOS</code>里面的<code>UIScrollView</code>，但是又有很多不同。</p><p><code>Row</code>的构造函数与<code>Column</code>的构造函数基本是一样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">        <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">Row的对其方式 默认是 MainAxisAlignment.start</span></span></span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    <span class="comment">/// <span class="markdown">表示Row在垂直方向占用的大小，默认是 max，表示尽可能的充满垂直方向空间。如果这是 min表示尽量小的占用垂直方向空间</span></span></span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    <span class="comment">/// <span class="markdown">水平方向对其方式 默认是 居中对齐</span></span></span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的布局顺序，不同国家书写习惯的不同(中文、英语从左往右书写，阿拉伯文从右往左书写)，这个参数可以帮助我们调整布局显示顺序</span></span></span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    <span class="comment">/// <span class="markdown">表示垂直方向的对其方向 </span></span></span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="comment">/// <span class="markdown">基线对齐方式 </span></span></span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p><code>mainAxisAlignment</code>接收一个<code>MainAxisAlignment</code>类型的枚举，<code>MainAxisAlignment</code>共有六个枚举值，如下：<br>|  枚举值   | 描述  |<br>|  —-  | —-  |<br>| start  | 与 开始的位置对齐 |<br>| end  | 与 结束的位置对齐 |<br>| center | 居中对齐 |<br>| spaceBetween  |  把剩余的空间拆分成n-1份(n是子控件的个数) 每一份都插入到子控件之间  |<br>| spaceEvenly | 把剩余的空间拆分成n+1份(n是子控件的个数) 然后均匀分布 |<br>| spaceAround | 把剩余空间拆分成 2n 份(n是子控件的个数) 每个子控件上下各放一份 |  </p><p><strong>MainAxisAlignment.start</strong><br>居左侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_start.png" alt="2021_01_13_row_start"></p><p><strong>MainAxisAlignment.center</strong><br>居中间<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_center.png" alt="2021_01_13_row_center"></p><p><strong>MainAxisAlignment.end</strong><br>居右侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_end.png" alt="2021_01_13_row_end"></p><p><strong>MainAxisAlignment.spaceBetween</strong><br>把剩余的空间拆分成n-1份(n是子控件的个数)，这里也就是3分，每一份都插入到子控件之间。看绿色数字就是每一份的编号  </p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_spaceBetween.png" alt="2021_01_13_row_spaceBetween"></p><p><strong>MainAxisAlignment.spaceEvenly</strong><br>把剩余的空间拆分成n+1份(n是子控件的个数)，这里也就是5分， 然后均匀分布。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_spaceEvenly.png" alt="2021_01_13_row_spaceEvenly"></p><p><strong>MainAxisAlignment.spaceAround</strong><br>把剩余空间拆分成 2n 份(n是子控件的个数)，这里也就是8分，每个子控件上下各放一份<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_spaceAround.png" alt="2021_01_13_row_spaceAround"></p><h3 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p><code>crossAxisAlignment</code>接收一个<code>CrossAxisAlignment</code>枚举值，有以下5中枚举  </p><table><thead><tr><th>枚举值</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>与 开始的位置对齐</td></tr><tr><td>end</td><td>与 结束的位置对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>stretch</td><td>水平方向扩充与Column相同大小</td></tr><tr><td>baseline</td><td>水平基线的对齐方式</td></tr></tbody></table><p><strong>CrossAxisAlignment.start</strong><br>居左侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_crossaxisalignment_start.png" alt="2021_01_13_row_crossaxisalignment_start"></p><p><strong>CrossAxisAlignment.center</strong><br>居中<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_crossaxisalignment_center.png" alt="2021_01_13_row_crossaxisalignment_center"></p><p><strong>CrossAxisAlignment.end</strong><br>居右侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_crossaxisalignment_end.png" alt="2021_01_13_row_crossaxisalignment_end"></p><p><strong>CrossAxisAlignment.stretch</strong><br>子控件的高度拉伸到与<code>Row</code>相同大小<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_crossaxisalignment_stretch.png" alt="2021_01_13_row_crossaxisalignment_stretch"></p><p><strong>CrossAxisAlignment.baseline</strong><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_crossaxisalignment_baseline.png" alt="2021_01_13_row_crossaxisalignment_baseline"></p><h3 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a>textDirection</h3><p><code>textDirection</code>参数接收一个<code>TextDirection</code>类型的枚举类型，它有两个不同的枚举值，如下<br>|  枚举值   | 描述  |<br>|  —-  | —-  |<br>| rtl  | 书写习惯是从右边开始  子控件默认从右边对齐 |<br>| ltr  | 书写习惯是从左边开始  子控件默认从左边对齐 |  </p><p><code>crossAxisAlignment</code>参数会受到<code>textDirection</code>参数值影响。<br>如下：  </p><ul><li><p>当 <code>textDirection</code>的参数值为<code>ltr</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.start</code>这个时候子控件居左上对齐。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_ltr_start.png" alt="2021_01_13_row_ltr_start"></p></li><li><p>当 <code>textDirection</code>的参数值为<code>ltr</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.end</code>这个时候子控件居左下对齐。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_ltr_end.png" alt="2021_01_13_row_ltr_end"></p></li></ul><ul><li>当 <code>textDirection</code>的参数值为<code>rtl</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.start</code>这个时候子控件居右上对齐。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_rtl_start.png" alt="2021_01_13_row_rtl_start"></p><ul><li>当 <code>textDirection</code>的参数值为<code>rtl</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.end</code>这个时候子控件居右下对齐。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_rtl_end.png" alt="2021_01_13_row_rtl_end"></p><p>总的来说<code>textDirection</code>会控制书写习惯来改变布局。这个其实是在做国际化的时候用到的比较多。</p><blockquote><p>在上面的描述中有<code>开始的位置</code>和<code>结束的位置</code>，为什么不直接写<code>左边</code>或<code>右边</code>，其实也是受<code>textDirection</code>的影响，<code>开始的位置</code>就是书写开始的位置，<code>结束的位置</code>就是写结束的位置。</p></blockquote><h3 id="verticalDirection"><a href="#verticalDirection" class="headerlink" title="verticalDirection"></a>verticalDirection</h3><p><code>verticalDirection</code>属性不常用，它有两个值，分别是：<code>VerticalDirection.down</code>和<code>VerticalDirection.up</code>。<br><code>VerticalDirection</code>配合<code>CrossAxisAlignment</code>的参数值，也会有不同的显示效果，跟<code>textDirection</code>类似。  </p><ul><li><p><code>VerticalDirection.down</code> 和 <code>CrossAxisAlignment.start</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_down_start.png" alt="2021_01_13_row_down_start"></p></li><li><p><code>VerticalDirection.down</code> 和 <code>CrossAxisAlignment.end</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_down_end.png" alt="2021_01_13_row_down_end"></p></li></ul><ul><li><p><code>VerticalDirection.up</code> 和 <code>CrossAxisAlignment.start</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_up_start.png" alt="2021_01_13_row_up_start"></p></li><li><p><code>VerticalDirection.up</code> 和 <code>CrossAxisAlignment.end</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_13_row_up_end.png" alt="2021_01_13_row_up_end"></p></li></ul><p>想体验以上的<code>Row</code>的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>row_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-7】Flutter手把手教程UI布局和Widget——垂直布局控件Column</title>
      <link href="flutter-ui-column-widget-2-7.html"/>
      <url>flutter-ui-column-widget-2-7.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><p><code>Column</code>是在Flutter中常见的布局控件，它负责垂直方向布局。Row负责水平方向布局，二者都是继承于<code>Flex</code>，类似于<code>iOS</code>里面的<code>UIScrollView</code>，但是又有很多不同。<br>先来看一下<code>Column</code>的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Column(&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">key</span></span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">Column的对其方式 默认是 MainAxisAlignment.start</span></span></span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    <span class="comment">/// <span class="markdown">表示Column在垂直方向占用的大小，默认是 max，表示尽可能的充满垂直方向空间。如果这是 min表示尽量小的占用垂直方向空间</span></span></span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    <span class="comment">/// <span class="markdown">横轴对其方式 默认是 居中对齐</span></span></span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件的布局顺序，不同国家书写习惯的不同(中文、英语从左往右书写，阿拉伯文从右往左书写)，这个参数可以帮助我们调整布局显示顺序</span></span></span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    <span class="comment">/// <span class="markdown">表示垂直方向的对其方向 </span></span></span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="comment">/// <span class="markdown">基线对齐方式 在Row里面会有使用</span></span></span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p><code>mainAxisAlignment</code>接收一个<code>MainAxisAlignment</code>类型的枚举，<code>MainAxisAlignment</code>共有六个枚举值，如下：<br>|  枚举值   | 描述  |<br>|  —-  | —-  |<br>| start  | 与 开始的位置对齐 |<br>| end  | 与 结束的位置对齐 |<br>| center | 居中对齐 |<br>| spaceBetween  |  把剩余的空间拆分成n-1份(n是子控件的个数) 每一份都插入到子控件之间  |<br>| spaceEvenly | 把剩余的空间拆分成n+1份(n是子控件的个数) 然后均匀分布 |<br>| spaceAround | 把剩余空间拆分成 2n 份(n是子控件的个数) 每个子控件上下各放一份 |<br>看描述比较晦涩，我们直接来看效果：</p><p><strong>MainAxisAlignment.start</strong><br>居顶部<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_start_1.png" alt="2020_01_12_column_mainaxisalignment_start_1"></p><p><strong>MainAxisAlignment.center</strong><br>居中间<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_center.png" alt="2020_01_12_column_mainaxisalignment_center"></p><p><strong>MainAxisAlignment.end</strong><br>居底部<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_end.png" alt="2020_01_12_column_mainaxisalignment_end"></p><p><strong>MainAxisAlignment.spaceBetween</strong><br>把剩余的空间拆分成n-1份(n是子控件的个数)，这里也就是3分，每一份都插入到子控件之间。看绿色数字就是每一份的编号<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_specebtween.png" alt="2020_01_12_column_mainaxisalignment_specebtween"></p><p><strong>MainAxisAlignment.spaceEvenly</strong></p><p>把剩余的空间拆分成n+1份(n是子控件的个数)，这里也就是5分， 然后均匀分布。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_speceevenly.png" alt="2020_01_12_column_mainaxisalignment_speceevenly"></p><p><strong>MainAxisAlignment.spaceAround</strong><br>把剩余空间拆分成 2n 份(n是子控件的个数)，这里也就是8分，每个子控件上下各放一份<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_mainaxisalignment_specearound.png" alt="2020_01_12_column_mainaxisalignment_specearound"></p><h3 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p><code>crossAxisAlignment</code>接收一个<code>CrossAxisAlignment</code>枚举值，有以下5中枚举</p><table><thead><tr><th>枚举值</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>与 开始的位置对齐</td></tr><tr><td>end</td><td>与 结束的位置对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>stretch</td><td>水平方向扩充与Column相同大小</td></tr><tr><td>baseline</td><td>无效</td></tr></tbody></table><p><strong>CrossAxisAlignment.start</strong><br>居左侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_crossaxisalignment_start.png" alt="2020_01_12_column_crossaxisalignment_start"></p><p><strong>CrossAxisAlignment.center</strong><br>居中<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_crossaxisalignment_center.png" alt="2020_01_12_column_crossaxisalignment_center"><br><strong>CrossAxisAlignment.end</strong><br>居右侧<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_crossaxisalignment_end.png" alt="2020_01_12_column_crossaxisalignment_end"></p><p><strong>CrossAxisAlignment.stretch</strong><br>子控件的宽度拉伸到与<code>Column</code>相同大小<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_crossaxisalignment_stretch.png" alt="2020_01_12_column_crossaxisalignment_stretch"></p><h3 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a>textDirection</h3><p><code>textDirection</code>参数接收一个<code>TextDirection</code>类型的枚举类型，它有两个不同的枚举值，如下<br>|  枚举值   | 描述  |<br>|  —-  | —-  |<br>| rtl  | 书写习惯是从右边开始  子控件默认从右边对齐 |<br>| ltr  | 书写习惯是从左边开始  子控件默认从左边对齐 |<br><code>crossAxisAlignment</code>参数会受到<code>textDirection</code>参数值影响。<br>如下：  </p><ul><li>当 <code>textDirection</code>的参数值为<code>ltr</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.start</code>这个时候子控件居左对齐。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_ltr_start.png" alt="2020_01_12_column_ltr_start"></li></ul><ul><li>当 <code>textDirection</code>的参数值为<code>ltr</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.end</code>这个时候子控件居右对齐。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_ltr_end.png" alt="2020_01_12_column_ltr_end"></p><ul><li>当 <code>textDirection</code>的参数值为<code>rtl</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.start</code>这个时候子控件居右对齐。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_rtl_start.png" alt="2020_01_12_column_rtl_start"></p><ul><li>当 <code>textDirection</code>的参数值为<code>rtl</code>时，<code>crossAxisAlignment</code>参数为<code>CrossAxisAlignment.end</code>这个时候子控件居做对齐。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_12_column_rtl_end.png" alt="2020_01_12_column_rtl_end"></p><p>总的来说<code>textDirection</code>会控制书写习惯来改变布局。这个其实是在做国际化的时候用到的比较多。在下一节即将讲解的<code>Row</code>也相同的会收到影响。</p><blockquote><p>在上面的描述中有<code>开始的位置</code>和<code>结束的位置</code>，为什么不直接写<code>左边</code>或<code>右边</code>，其实也是受<code>textDirection</code>的影响，<code>开始的位置</code>就是书写开始的位置，<code>结束的位置</code>就是写结束的位置。</p></blockquote><p>想体验以上的<code>Column</code>的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>column_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Column </tag>
            
            <tag> Flutter 布局控件 </tag>
            
            <tag> Flutter Row </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-6】Flutter手把手教程UI布局和Widget——Image控件、NetworkImage、AssetImage</title>
      <link href="flutter-ui-image-widget-2-6.html"/>
      <url>flutter-ui-image-widget-2-6.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>Image是一个常用的控件，它可以帮助我们显示图片，图片的资源可以是来自网络、本地或者是内存。在移动端的开发中会大量使用Image来展示一些图文，了解和掌握Image控件是非常有必要的。</p><h3 id="AssetImage-和-Image-asset"><a href="#AssetImage-和-Image-asset" class="headerlink" title="AssetImage 和 Image.asset"></a>AssetImage 和 Image.asset</h3><p><code>AssetImage</code>是Flutter提供的一个可以从本地读取图片资源的类，我们可以使用它来读取图片。同样Flutter还提供了<code>Image.asset</code>这个构造方法直接来帮助我们读取图片资源并返回一个Image对象。其实<code>Image.asset</code>是对<code>AssetImage</code>一层更高级的封装。</p><blockquote><p>注意：要读取本地图片我们首先需要在<code>pubspec.yaml</code>文件里配置本地图片资源的路径，我们这里在<code>assets</code>这个字段下新增了<code>- images/image_demo.jpg</code>这个文件。后续将会有一篇专门的博客来讲解资源的管理。</p></blockquote><p><strong>1. AssetImage</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">    image: AssetImage(<span class="string">&quot;images/image_demo.jpg&quot;</span>),</span><br><span class="line">    width: <span class="number">80</span>,</span><br><span class="line">    height: <span class="number">80</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>2. Image.asset</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(</span><br><span class="line">    <span class="string">&quot;images/image_demo.jpg&quot;</span>,</span><br><span class="line">    width: <span class="number">80</span>,</span><br><span class="line">    height: <span class="number">80</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>两个方法都是传入一个本地文件路径就可以了。</p><h3 id="NetworkImage-和-Image-network"><a href="#NetworkImage-和-Image-network" class="headerlink" title="NetworkImage 和 Image.network"></a>NetworkImage 和 Image.network</h3><p><code>NetworkImage</code>是一个可以从网络下载图片的类，它本身是异步的。<code>Image.network</code>是对<code>NetworkImage</code>的封装，它需要传入一个URL地址就可以返回一个Image对象。这两个的设计跟<code>AssetImage</code>和<code>Image.asset</code>的设计基本一致。<br><strong>3. NetworkImage</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">    image: NetworkImage(<span class="string">&quot;http://www.fulade.me/img/avatar.jpg&quot;</span>),</span><br><span class="line">    width: <span class="number">80</span>,</span><br><span class="line">    height: <span class="number">80</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>4. Image.network</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">    <span class="string">&quot;http://www.fulade.me/img/avatar.jpg&quot;</span>,</span><br><span class="line">    width: <span class="number">80</span>,</span><br><span class="line">    height: <span class="number">80</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h3><p><code>alignment</code>是Image的一个很重要的参数，它可以帮助我们设置图片的位置。有以下几个枚举值<br>|  参数   | 描述  |<br>|  —-  | —-  |<br>| topCenter  | 居中靠上 |<br>| topRight  | 右上角 |<br>| centerLeft | 居中靠左 |<br>| center  |   居中 |<br>| centerRight | 居中靠右 |<br>| bottomLeft | 居右下角 |<br>| bottomCenter | 居中靠下 |<br>| bottomRight | 居右下角 |</p><h3 id="BoxFit"><a href="#BoxFit" class="headerlink" title="BoxFit"></a>BoxFit</h3><p><code>fit</code>参数是很重要的布局参数，当我们的图片内容跟Image设置的大小不完全吻合的时候，<code>fit</code>的参数值<code>BoxFit</code>可以帮助我们做最优的调整和显示<br><strong>5. BoxFit.contain</strong><br><code>fit</code>的默认值是<code>BoxFit.contain</code>。由下图我们不难看出，<code>BoxFit.contain</code>会等比例缩放，保持图片的原始的比例并且显示在Image内。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_contain.png" alt="2020_01_11_box_contain"></p><p><strong>6. BoxFit.fill</strong><br>由图可见<code>BoxFit.fill</code>会充满整个容器，如果图片大小与容器不完全吻合，可能会出现拉伸。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_fill.png" alt="2020_01_11_box_fill"></p><p><strong>7. BoxFit.cover</strong><br><code>BoxFit.cover</code>会保持图片资源的大小，如果超过的部分会被裁掉不会显示。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_cover.jpg" alt="2020_01_11_box_cover"></p><p><strong>8. BoxFit.fitWidth</strong><br><code>BoxFit.fitWidth</code>会使宽度充满整个容器，高度会按比例缩放，图片不会被拉伸，超出容器的部分会被剪裁。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_fillwidth.jpg" alt="2020_01_11_box_fillwidth"></p><p><strong>9. BoxFit.fitHeight</strong><br><code>BoxFit.fitHeight</code>跟<code>BoxFit.fitWidth</code>相似，高度会充满整个容器，宽度会按比例缩放，图片不会被拉伸，超出容器的部分会被剪裁。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_fitheight.jpg" alt="2020_01_11_box_fitheight"></p><p><strong>10. BoxFit.none</strong><br>none表示没有设置显示策略，以原始大小居中来显示。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_none_2.jpg" alt="2020_01_11_box_none_2"></p><p><strong>11. BoxFit.scaleDown</strong><br>当图片资源大于容器的时候，效果相当于 <code>BoxFit.none</code>，<br>当组件比图片小时，效果相当于 <code>BoxFit.contain</code>。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_11_box_scaleDown.jpg" alt="2020_01_11_box_scaleDown"></p><blockquote><p>对于加载过的图片Flutter是会帮助我们做内存缓存，最大缓存数量是1000，最大缓存内存空间是100M。</p></blockquote><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>image_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Image </tag>
            
            <tag> Flutter NetworkImage </tag>
            
            <tag> Flutter AssetImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-5】Flutter手把手教程UI布局和Widget——TextField使用、搭配InputDecoration和FocusedNode使用</title>
      <link href="flutter-ui-textfield-widget-2-5.html"/>
      <url>flutter-ui-textfield-widget-2-5.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><p>TextField是一个常用的控件，同时它也是一个组合控件，由多个控件组合而成。<br>这是来自Material官方网站的的图片<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2021_01_07_material_textfiled.png" alt="2021_01_07_material_textfield"><br>TextField是由7个控件组成，其中有些控件默认不显示，我们可以对各个控件单独设置想要的样式来满足不同的UI展示需求。<br>下面我们就来列举几种常见的样式：</p><p><strong>1. 简单的TextField</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;最基本的的TextField&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>TextField</code>接收一个<code>InputDecoration</code>作为参数，<code>InputDecoration</code>初始化的参数<code>labelText</code>可以帮助我们定义placeholder。<code>labelText</code>模式会灰色的，选中之后会变为蓝色，并且<code>TextField</code>底部会有一条蓝色线条。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_custom.gif" alt="2020_01_08_textfield_custom"></p><p><strong>2. 限制字符的长度</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    maxLength: <span class="number">10</span>,</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;最多10个字符&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>maxLength</code>可以设置最长字符个数，如果超过这个限制再次输入不会有显示，并且在<code>TextField</code>在有右下角有当前字符个数的标记，此处是<code>10/10</code>。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_maxlength.png" alt="2020_01_08_textfield_maxlength"></p><p><strong>3. 限制行数</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    maxLines: <span class="number">2</span>,</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;两行文字，超出的文字上翻&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>maxLines</code>参数可以设置行数，比如这里设置的是2，默认只会显示两行，超过两行的部分只能通过上下滚动来显示。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_maxline.png" alt="2020_01_08_textfield_maxline"></p><blockquote><p>默认行数是1，超过的部分会往左缩进。</p></blockquote><p><strong>4. labelText设置颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;labelText 有颜色&quot;</span>,</span><br><span class="line">        labelStyle: TextStyle(color: Colors.red),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>InputDecoration</code>可以设置<code>labelStyle</code>参数，接收一个<code>TextStyle</code>对象，<code>TextStyle</code>这个我们比较熟悉，在之前讲解<code>Text</code>的文章中已经做了很多详解了。设置颜色之后，当点击<code>TextField</code>之后，文字会变小，颜色也是设置好的颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_labelcolor.png" alt="2020_01_08_textfield_labelcolor"></p><p><strong>5. 左侧Icon</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        icon: Icon(Icons.account_box),</span><br><span class="line">        labelText: <span class="string">&quot;左侧有一个Icon&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>icon</code>参数可以传入一个<code>Icon</code>对象用来显示在<code>TextField</code>的左侧，我们可以传入各式各样的<code>Icon</code>，满足我们更丰富的展示需求。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_lefticon.png" alt="2020_01_08_textfield_lefticon"></p><p><strong>6. 右侧Icon suffix和suffixIcon</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;右侧的两个Icon suffix 和 suffixIcon&quot;</span>,</span><br><span class="line">        suffix: Icon(Icons.account_box),</span><br><span class="line">        suffixIcon: Icon(Icons.add),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>suffixIcon</code>默认是显示在右侧的，<code>TextField</code>被点击之后会显示为被选中状态，<code>suffix</code>默认不显示，只有当选中<code>TextField</code>的时候才会显示出来。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_suffix.gif" alt="2020_01_08_textfield_suffix"></p><p><strong>7. 辅助提示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;下方带有辅助提示的TextField&quot;</span>,</span><br><span class="line">        helperText: <span class="string">&quot;我是辅助提示&quot;</span>,</span><br><span class="line">        helperStyle: TextStyle(color: Colors.red),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>helperText</code>可以帮助我们在<code>TextField</code>下面显示一行提示文字，同样我们也可以使用<code>helperStyle</code>来设置这段提示文字的样式。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_helpertext.jpeg" alt="2020_01_08_textfield_helpertext"></p><p><strong>8. 点击后的提示 hintText</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;点击后会有提示&quot;</span>,</span><br><span class="line">        hintText: <span class="string">&quot;我是点击后的提示&quot;</span>,</span><br><span class="line">        hintStyle: TextStyle(color: Colors.red),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>hintText</code>参数可以帮助我们设置一个点击后显示的文字，只有点击之后才可以显示，同样我们可以通过<code>hintStyle</code>来设置<code>hintText</code>的样式。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_hittext.gif" alt="2020_01_08_textfield_hittext"></p><p><strong>9. 不显示下划线</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;选中时没有下划线&quot;</span>,</span><br><span class="line">        focusedBorder: InputBorder.none,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>focusedBorder</code>可以帮助我们设置下划线的样式，如果传入<code>InputBorder.none</code>则不会显示下划线。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_focusborder.gif" alt="2020_01_08_textfield_focusborder"></p><p><strong>10. 自定义下划线样式</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;选中时的下划线颜色&quot;</span>,</span><br><span class="line">        focusedBorder: UnderlineInputBorder(</span><br><span class="line">            borderSide: BorderSide(color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以给<code>focusedBorder</code>传入自定义的<code>UnderlineInputBorder</code>来自定义下划线的样式，这里我们简单做了个颜色的改变。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_focusborder_color.gif" alt="2020_01_08_textfield_focusborder_color"></p><h3 id="TextField事件监听"><a href="#TextField事件监听" class="headerlink" title="TextField事件监听"></a>TextField事件监听</h3><p>日常开发中，我们往往希望在三个地方TextField可以给我们回调。</p><ol><li>输入文字的过程中，这样方便我们在用户输入的时候就可以判断输入内容是否合法。</li><li>输入完成的时候，这个时候我们可以拿到输入内容做一些操作。</li><li>与键盘事件的配合，在必要的时候回收键盘。</li></ol><p><code>TextField</code>提供了三个回调方法</p><ul><li><code>onChanged</code> 此方法是在输入有变化的时候就会回调。参数是当前已经输入的内容</li><li><code>onSubmitted</code> 此方法是在我们输入完成后，点击键盘上回车的时候回调。参数是当前的已经输入的内容</li><li><code>onEditingComplete</code>此方法也是在点击键盘上回车的时候回调，它会在<code>onSubmitted</code>之前执行。不会带有参数</li></ul><p>需要注意是<code>onEditingComplete</code>回调方法没有携带参数。如果我们需要在<code>onEditingComplete</code>方法中获取到当前的输入值。<br>那就需要通过<code>TextEditingController</code>来捕捉输入内容，<code>TextField</code>接收一个<code>TextEditingController</code>对象来作为<code>controller</code>参数，<br>通过<code>TextEditingController</code>的属性<code>text</code>我们也可以获取到当前的输入内容。</p><p><strong>11. 事件回调</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TextEditingController controller = TextEditingController();</span><br><span class="line">TextField(</span><br><span class="line">    controller: controller,</span><br><span class="line">    onChanged: (value) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;onChanged value = &quot;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    onSubmitted: (value) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;onSubmitted value = &quot;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    onEditingComplete: () &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;onEditingComplete value = &quot;</span> + controller.text);</span><br><span class="line">    &#125;,</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">      labelText: <span class="string">&quot;输入事件监听&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到通过<code>controller.text</code>可以获取到当前的输入内容。<br><strong>12. 键盘回收</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;键盘回收&quot;</span>,</span><br><span class="line">        suffixIcon: IconButton(</span><br><span class="line">            icon: Icon(Icons.close),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">                FocusScope.of(context).requestFocus(FocusNode());</span><br><span class="line">            &#125;),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><code>FocusNode</code>可以帮助我们进行键盘的回收，我只需要将<code>FocusScope</code>的<code>requestFocus</code>方法中传入一个新的<code>FocusNode</code>对象即刻。<br>如果在开发过程中，我们希望通过点击页面上某个按钮来结束<code>TextField</code>输入并且获取到当前的输入内容。使用<code>FocusNode</code>是很有效的。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_01_08_textfield_focusbnode.gif" alt="2020_01_08_textfield_focusbnode"></p><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>textfield_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 控件 </tag>
            
            <tag> Flutter TextField </tag>
            
            <tag> Flutter 输入框 </tag>
            
            <tag> Flutter 输入控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-4】Flutter手把手教程UI布局和Widget——Statelesswidget与Statefulwidget</title>
      <link href="flutter-ui-stateful-widget-2-4.html"/>
      <url>flutter-ui-stateful-widget-2-4.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Statelesswidget"><a href="#Statelesswidget" class="headerlink" title="Statelesswidget"></a>Statelesswidget</h3><p>如果一个Widget从初始化到使用再到销毁，整个过程中都不需要修改其UI的样式，例如纯展示页面，我们就用<code>Statelesswidget</code>。常见的<code>Statelesswidget</code>有：<code>Text</code>、<code>Icon</code>、<code>ImageIcon</code>、<code>Dialog</code>等。可以看到这些往往都是一些展示类的，不需要改变其状态的控件。<br>使用<code>Statelesswidget</code>更轻量，更节省内存资源。初始化<code>Statelesswidget</code>的时候不会附带一些动态更新UI的方法，这样也会提升我们软件的性能。</p><blockquote><p>需要注意的是：<br>在iOS开发中，初始化一个<code>Label</code>并命名为<code>la</code>，改变它的文字内容，会调用<code>la.text = @&quot;new text&quot;</code>，我们可以理解为<code>Label</code>不是<code>Statelesswidget</code>的，因为它的<code>text</code>属性被改变了。那Flutter的<code>Text</code>为什么又是<code>Statelesswidget</code>的呢？因为Flutter中一切Widget都是 “配置文件”，当我们修改文本之后，Flutter会帮助我们重新初始化一个<code>Text</code>，而不是修改当前的<code>Text</code>对象，这是与原生开发不一样的地方。</p></blockquote><h3 id="Statefulwidget"><a href="#Statefulwidget" class="headerlink" title="Statefulwidget"></a>Statefulwidget</h3><p><code>Statefulwidget</code>是可变的Widget，在我们的开发中会大量使用<code>Statefulwidget</code>。它实现了一个<code>setState</code>方法，当我们调用这个方法的时候，该<code>Statefulwidget</code>会被重新渲染，注意是<strong>重新被渲染</strong>，而不是局部更新。<br>当我们调用<code>setState</code>时，Flutter在收到该消息后，会重新调用其<code>build</code>方法重新构建这个widget，从而达到更新UI的目的。</p><p>来看如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulWidgetDemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _StatefulWidgetDemoPageState createState() =&gt; _StatefulWidgetDemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StatefulWidgetDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidgetDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          setState(() &#123;&#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;StatefuleWidget Demo&quot;</span>),</span><br><span class="line">        centerTitle: <span class="keyword">true</span>,</span><br><span class="line">        backgroundColor: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">            <span class="comment">/// <span class="markdown">颜色一个随机值</span></span></span><br><span class="line">            color: _randomColor(),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">获取一个随机的颜色值</span></span></span><br><span class="line">  _randomColor() &#123;</span><br><span class="line">    <span class="keyword">return</span> Color.fromARGB(<span class="number">255</span>, Random().nextInt(<span class="number">255</span>), Random().nextInt(<span class="number">255</span>),</span><br><span class="line">        Random().nextInt(<span class="number">255</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个生成随机颜色的方法<code>_randomColor()</code>，它会返回一个<code>Color</code>对象，然后我们又定义了一个<code>Container</code>，<code>Container</code>的初始化参数<code>color</code>的值是<code>_randomColor()</code>的返回值。然后我们在<code>FloatingActionButton</code>的<code>onPressed</code>的方法中调用一下<code>setState</code>方法，这个时候Flutter会重新绘制<code>StatefulWidgetDemoPage</code>，所以每次点击按钮，我们可以看到<code>Container</code>的颜色都是不一样的。</p><h3 id="一切都是Widget"><a href="#一切都是Widget" class="headerlink" title="一切都是Widget"></a>一切都是Widget</h3><p>在Flutter中我们看到的UI元素都是由<code>Widget</code><strong>生成的</strong>，包括手势，在Flutter中也是<code>Widget</code>。<code>Widget</code>并不是我们看到的UI元素，我们实际看到的UI元素叫<code>Element</code>，<code>Widget</code>是<code>Element</code>的配置数据。<br>我们写了大量的<code>Widget</code>经Flutter处理渲染生成了<code>Element</code>来展示在手机屏幕上。所以当我们调用<code>setState</code>方法的时候，我们只是更新了<strong>配置数据</strong>，Flutter依照更新后的配置数据来生成新的<code>Element</code>来达到渲染UI的目的。</p><blockquote><p>注意<br>一个 <code>Widget</code>可以对应多个<code>Elememt</code>对象，这等同与一个配置文件可以生成多个实例对象一样。</p></blockquote><p>想体验以上的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>statefulwidget_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 控件 </tag>
            
            <tag> Flutter Statelesswidget </tag>
            
            <tag> Flutter Statefulwidget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-18】Python手把手教程之——异常处理、try-except、error</title>
      <link href="python-error-1-18.html"/>
      <url>python-error-1-18.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行; 如果你未对异常进行处理，程序将停止，并显示一个<code>traceback</code>，其中包含有关异常的报告。<br>异常是使用<code>try-except</code>代码块处理的。<code>try-except</code>代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了<code>try-except</code>代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的<code>traceback</code>。</p><h5 id="一个简单的异常：ZeroDivisionError"><a href="#一个简单的异常：ZeroDivisionError" class="headerlink" title="一个简单的异常：ZeroDivisionError"></a>一个简单的异常：ZeroDivisionError</h5><p>下面来看一种导致Python引发异常的简单错误。你可能知道不能将一个数字除以0，但我们还是让Python这样做吧:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">5</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>显然，Python无法这样做，因此你将看到一个<code>traceback</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;division.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">print(<span class="number">5</span>/<span class="number">0</span>) </span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>在上述traceback中，我们看到的错误<code>ZeroDivisionError</code>是一个异常对象。Python无法按你的要求做时，就会创建这种对象。在这种情况下，Python将停止运行程序，并指出引发了哪种异常，而我们可根据这些信息对程序进行修改。下面我们将告诉Python，发生这种错误时怎么办;这样， 如果再次发生这样的错误，我们就有备无患了。</p><h4 id="使用try-except代码块"><a href="#使用try-except代码块" class="headerlink" title="使用try-except代码块"></a>使用try-except代码块</h4><p>当你认为可能发生了错误时，可编写一个<code>try-except</code>代码块来处理可能引发的异常。你让Python尝试运行一些代码，并告诉它如果这些代码引发了指定的异常，该怎么办。处理<code>ZeroDivisionError</code>异常的<code>try-except</code>代码块类似于下面这样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们将导致错误的代码行<code>print(5/0)</code>放在了一个<code>try</code>代码块中。如果<code>try</code>代码块中的代码运行 起来没有问题，Python将跳过<code>except</code>代码块，如果<code>try</code>代码块中的代码导致了错误，Python将查找这样的<code>except</code>代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。<br>在这个示例中，<code>try</code>代码块中的代码引发了<code>ZeroDivisionError</code>异常，因此Python指出了该如何解决问题的<code>except</code>代码块，并运行其中的代码。这样，用户看到的是一条友好的错误消息，而不是<code>traceback</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You can<span class="string">&#x27;t divide by zero!</span></span><br></pre></td></tr></table></figure><p>如果try-except代码块后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。下面来看一个捕获错误后程序将继续运行的示例。</p><h4 id="使用异常避免崩溃"><a href="#使用异常避免崩溃" class="headerlink" title="使用异常避免崩溃"></a>使用异常避免崩溃</h4><p>发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出 现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。<br>下面来创建一个只执行除法运算的简单计算器，我们把一下保存为<code>division.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> second_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    print(answer)</span><br></pre></td></tr></table></figure><p>这个程序提示用户输入一个数字，并将其存储到变量<code>first_number</code>中，如果用户输入的不是表示退出的<code>q</code>，就再提示用户输入一个数字，并将其存储到变量<code>second_number</code>中。接下来，我们计算这两个数字的商(即<code>answer</code>)。这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Give me two numbers, <span class="keyword">and</span> I<span class="string">&#x27;ll divide them. Enter &#x27;</span>q<span class="string">&#x27; to quit.</span></span><br><span class="line"><span class="string">First number: 5</span></span><br><span class="line"><span class="string">Second number: 0</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">    File &quot;division.py&quot;, line 9, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        answer = int(first_number) / int(second_number)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure><p>程序崩溃可不好，但让用户看到<code>traceback</code>也不是好主意。不懂技术的用户会被它们搞糊涂， 而且如果用户怀有恶意，他会通过<code>traceback</code>获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息 判断出可对你的代码发起什么样的攻击。</p><h4 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h4><p>通过将可能引发错误的代码放在<code>try-except</code>代码块中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到<code>try-except</code>代码块中。这个示例还包含一个<code>else</code>代码块，依赖于<code>try</code>代码块成功执行的代码都应放到<code>else</code>代码块中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>) print(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError: </span><br><span class="line">        print(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        print(answer)</span><br></pre></td></tr></table></figure><p>我们让Python尝试执行<code>try</code>代码块中的除法运算，这个代码块只包含可能导致错误的代码。依赖于<code>try</code>代码块成功执行的代码都放在<code>else</code>代码块中，在这个示例中，如果除法运算成功，我们就使用<code>else</code>代码块来打印结果。<br><code>except</code>代码块告诉Python，出现<code>ZeroDivisionError</code>异常时该怎么办。如果<code>try</code>代码块因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到<code>traceback</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Give me two numbers, <span class="keyword">and</span> I<span class="string">&#x27;ll divide them.</span></span><br><span class="line"><span class="string">Enter &#x27;</span>q<span class="string">&#x27; to quit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">First number: 5</span></span><br><span class="line"><span class="string">Second number: 0</span></span><br><span class="line"><span class="string">You can&#x27;</span>t divide by <span class="number">0</span>!</span><br><span class="line"></span><br><span class="line">First number: <span class="number">5</span> </span><br><span class="line">Second number: <span class="number">2</span> </span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">First number: q</span><br></pre></td></tr></table></figure><p><code>try-except-else</code>代码块的工作原理大致如下:Python尝试执行<code>try</code>代码块中的代码，只有可能引发异常的代码才需要放在<code>try</code>语句中。有时候，有一些仅在<code>try</code>代码块成功执行时才需要运行的代码;这些代码应放在<code>else</code>代码块中。<code>except</code>代码块告诉Python，如果它尝试运行<code>try</code>代码块中的代码时引发了指定的异常，该怎么办。<br>通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。</p><h4 id="处理FileNotFoundError异常"><a href="#处理FileNotFoundError异常" class="headerlink" title="处理FileNotFoundError异常"></a>处理FileNotFoundError异常</h4><p>使用文件时，一种常见的问题是找不到文件:你要查找的文件可能在其他地方、文件名可能不正确或者这个文件根本就不存在。对于所有这些情形，都可使用<code>try-except</code>代码块以直观的方式进行处理。<br>我们来尝试读取一个不存在的文件。下面的程序尝试读取文件<code>alice.txt</code>的内容，但我没有将这个文件存储在<code>alice.py</code>所在的目录中，我们将一下代码保存为<code>alice.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;alice.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj: </span><br><span class="line">    contents = f_obj.read()</span><br></pre></td></tr></table></figure><p>Python无法读取不存在的文件，因此它引发一个异常:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last): </span><br><span class="line">    File <span class="string">&quot;alice.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;alice.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>在上述<code>traceback</code>中，最后一行报告了<code>FileNotFoundError</code>异常，这是Python找不到要打开的文件时创建的异常。在这个示例中，这个错误是函数<code>open()</code>导致的，因此要处理这个错误，必须将<code>try</code>语句放在包含<code>open()</code>的代码行之前:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;alice.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj: </span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">&quot;Sorry, the file &quot;</span> + filename + <span class="string">&quot; does not exist.&quot;</span> </span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure><p>在这个示例中，try代码块引发<code>FileNotFoundError</code>异常，因此Python找出与该错误匹配的<code>except</code>代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是<code>traceback</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorry, the file alice.txt does <span class="keyword">not</span> exist.</span><br></pre></td></tr></table></figure><p>如果文件不存在，这个程序什么都不做，因此错误处理代码的意义不大。下面来扩展这个示例，看看在你使用多个文件时，异常处理可提供什么样的帮助。</p><blockquote><p>本篇文章没有作业，下一篇我们讲解函数的高级用法</p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 异常 </tag>
            
            <tag> Python 错误处理 </tag>
            
            <tag> Python Error </tag>
            
            <tag> Python Exceptions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-3】Flutter手把手教程UI布局和Widget——容器控件Container</title>
      <link href="flutter-ui-container-widget-2-3.html"/>
      <url>flutter-ui-container-widget-2-3.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>我们先来看一下Container初始化的参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">// 位置 居左、居右、居中</span></span><br><span class="line">  <span class="keyword">this</span>.alignment, </span><br><span class="line">  <span class="comment">// EdgeInsets Container的内边距</span></span><br><span class="line">  <span class="keyword">this</span>.padding,</span><br><span class="line">  <span class="comment">// 背景颜色  </span></span><br><span class="line">  <span class="keyword">this</span>.color,</span><br><span class="line">  <span class="comment">// 背景装饰器</span></span><br><span class="line">  <span class="keyword">this</span>.decoration,</span><br><span class="line">  <span class="comment">// 前景装饰器</span></span><br><span class="line">  <span class="keyword">this</span>.foregroundDecoration,</span><br><span class="line">  <span class="comment">// 宽度</span></span><br><span class="line">  <span class="built_in">double</span> width,</span><br><span class="line">  <span class="comment">// 告诉</span></span><br><span class="line">  <span class="built_in">double</span> height,</span><br><span class="line">  <span class="comment">// 约束</span></span><br><span class="line">  BoxConstraints constraints,</span><br><span class="line">  <span class="comment">// EdgeInsets Container的外边距</span></span><br><span class="line">  <span class="keyword">this</span>.margin,</span><br><span class="line">  <span class="comment">// 旋转</span></span><br><span class="line">  <span class="keyword">this</span>.transform,</span><br><span class="line">  <span class="comment">// 子控件</span></span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">  <span class="comment">// 裁剪Widget的模式 </span></span><br><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>Container</code> 的<code>color</code>属性与属性 <code>decoration</code>的<code>color</code>存在冲突，如果两个<code>color</code>都做了设置，默认会以<code>decoration</code>的<code>color</code>为准。</li><li>如果我们没有给<code>Container</code>设置<code>width</code>和<code>height</code>，<code>Container</code>会跟<code>child</code>的大小一样；假如我们没有设置<code>child</code>的时候，它的尺寸会极大化，尽可能的充满它的<code>父Widget</code>。</li></ul><p><strong>1. 最简单的Container</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    child: Text(<span class="string">&quot;Fulade&quot;</span>),</span><br><span class="line">    color: Colors.red,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Container接收一个<code>child</code>参数，我们可以传入<code>Text</code>作为<code>child</code>参数,然后传入是一个颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_normal.png" alt="2020_12_28_container_normal"></p><p><strong>2. Padding</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    child: Text(<span class="string">&quot;Pading 10&quot;</span>),</span><br><span class="line">    padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line">`Padding`是内边距，我们在这里设置了`padding: EdgeInsets.all(<span class="number">10</span>)`，也就是说`Text`距离`Container`的四条边的边距都是<span class="number">10</span>。  </span><br><span class="line">![<span class="number">2020</span>_12_28_container_padding](https:<span class="comment">//cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_padding.png)</span></span><br><span class="line"></span><br><span class="line">**<span class="number">3.</span> Margin**</span><br><span class="line">``` dart</span><br><span class="line">Container(</span><br><span class="line">    child: Text(<span class="string">&quot;Margin 10&quot;</span>),</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    color: Colors.green,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Margin</code>是外边距，我们在这里设置了<code>margin: EdgeInsets.all(10)</code>，<code>Container</code>在原有大小的基础上，又被<strong>包围</strong>了一层宽度为10的矩形。<br>需要注意，绿色外围的白色区域也是属于<code>Container</code>的一部分。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_margin.png" alt="2020_12_28_container_margin">  </p><p><strong>4. transform</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    padding: EdgeInsets.symmetric(horizontal: <span class="number">15</span>),</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    child: Text(<span class="string">&quot;transform&quot;</span>),</span><br><span class="line">    transform: Matrix4.rotationZ(<span class="number">0.1</span>),</span><br><span class="line">    color: Colors.red,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>transform</code>可以帮助我们做旋转，<code>Matrix4</code>给我们提供了很多的变换样式。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_transform.png" alt="2020_12_28_container_transform"></p><p><strong>5. decoration</strong><br><code>decoration</code>可以帮助我们实现更多的效果。例如形状、圆角、边界、边界颜色等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    child: Text(<span class="string">&quot;Decoration&quot;</span>),</span><br><span class="line">    padding: EdgeInsets.symmetric(horizontal: <span class="number">15</span>),</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        shape: BoxShape.rectangle,</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">5</span>)),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_decoration.png" alt="2020_12_28_container_decoration"><br>这里就是设置了一个圆角的示例，同样我们对<code>BoxDecoration</code>的<code>color</code>属性设置颜色，对整个<code>Container</code>的也是有效的。</p><p><strong>6. 显示 Image</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    height: <span class="number">40</span>,</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        image: DecorationImage(</span><br><span class="line">                image: AssetImage(<span class="string">&quot;images/flutter_icon_100.png&quot;</span>),</span><br><span class="line">                fit: BoxFit.contain,</span><br><span class="line">            ),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>BoxDecoration</code>可以传入一个<code>Image</code>对象，这样就灵活了很多，<code>Image</code>可以来自本地也可以来自网络。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_image.png" alt="2020_12_28_container_image"></p><p><strong>7. Border</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    child: Text(<span class="string">&#x27;BoxDecoration with border&#x27;</span>),</span><br><span class="line">    padding: EdgeInsets.symmetric(horizontal: <span class="number">15</span>),</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">5</span>),</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        borderRadius: BorderRadius.circula(<span class="number">12</span>),</span><br><span class="line">        border: Border.all(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            width: <span class="number">3</span>,</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用<code>border</code>可以帮助我们做边界效果，还可以设置圆角<code>borderRadius</code>，也可以设置<code>border</code>的宽度，颜色等。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_border.png" alt="2020_12_28_container_border"></p><p><strong>8. 渐变色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    padding: EdgeInsets.symmetric(horizontal: <span class="number">20</span>),</span><br><span class="line">    margin: EdgeInsets.all(<span class="number">20</span>), <span class="comment">//容器外填充</span></span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        gradient: RadialGradient(</span><br><span class="line">            colors: [Colors.blue, Colors.black, Colors.red],</span><br><span class="line">            center: Alignment.center,</span><br><span class="line">            radius: <span class="number">5</span></span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">    child: Text(</span><br><span class="line">        <span class="comment">//卡片文字</span></span><br><span class="line">        <span class="string">&quot;RadialGradient&quot;</span>,</span><br><span class="line">        style: TextStyle(color: Colors.white),</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>BoxDecoration</code>的属性<code>gradient</code>可以接收一个颜色的数组，<code>Alignment.center</code>是渐变色开始的位置，可以从<code>左上角</code>、<code>右上角</code>、<code>中间</code>等位置开始颜色变化。</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_28_container_radialGradient.png" alt="2020_12_28_container_radialGradient"></p><p>想体验以上的<code>Container</code>的示例的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>container_page.dart</code>查看，并且可以下载下来运行并体验。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter Container </tag>
            
            <tag> Flutter 容器 </tag>
            
            <tag> Flutter 控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快来领取微信红包封面，先到先得，还有圣诞节专属红包封面！</title>
      <link href="tips-wechat-redpacket-cover.html"/>
      <url>tips-wechat-redpacket-cover.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>年末了，相信大家有很多需要发红包的场景，送上几款免费的红包封面，数量有限，<del>先到先得</del>。都已过期，不能再领取了。</p><h4 id="肯德基封面"><a href="#肯德基封面" class="headerlink" title="肯德基封面"></a>肯德基封面</h4><p><a href="https://support.weixin.qq.com/cgi-bin/mmsupport-bin/showredpacket?timelimituri=p9NxhhRdhJR3LcM72920&check_type=2">肯德基链接</a><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_25_redpacket_2.jpeg" alt="2020_12_25_redpacket_2"></p><h4 id="敦煌封面"><a href="#敦煌封面" class="headerlink" title="敦煌封面"></a>敦煌封面</h4><p><a href="https://support.weixin.qq.com/cgi-bin/mmsupport-bin/showredpacket?receiveuri=bAypzj59dkO">敦煌链接</a><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_25_redpacket_3.jpeg" alt="2020_12_25_redpacket_3"></p><h4 id="使命召"><a href="#使命召" class="headerlink" title="使命召"></a>使命召</h4><p><a href="https://support.weixin.qq.com/cgi-bin/mmsupport-bin/showredpacket?combinereceiveuri=uQZb7JC3R6Y6c6Ly&check_type=3">使命召唤链接</a><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_25_redpacket_4.jpeg" alt="2020_12_25_redpacket_4"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>领取后，直接点击<code>使用</code>即可。赶紧去试一试吧！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_25_redpacket_1.jpeg" alt="2020_12_25_redpacket_1"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-17】Python手把手教程之——文件的读写以及I/O操作</title>
      <link href="python-file-1-17.html"/>
      <url>python-file-1-17.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p>文本文件可存储的数据量很多，每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其 如此。例如，你可以编写一个这样的程序:读取一个文本文件的内容，重新设置这些数据的格式 并将其写入文件，让浏览器能够显示这些内容。<br>要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。</p><h4 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h4><p>要读取文件，需要一个包含几行文本的文件。下面首先来创建一个文件，它包含精确到小数点后30位的圆周率值，且在小数点后每10位处都换行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535 </span><br><span class="line">8979323846 </span><br><span class="line">2643383279</span><br></pre></td></tr></table></figure><p>我们把它保存为<code>pi_digits.txt</code>文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pi_digits.txt&#x27;</span>) <span class="keyword">as</span> file_object: </span><br><span class="line">    contents = file_object.read() </span><br><span class="line">    print(contents)</span><br></pre></td></tr></table></figure><p>我们先来看看函数<code>open()</code>。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开文件，这样才能访问它。函数<code>open()</code>接受一个参数: 要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，假如我们把文件保存为<code>file_reader.py</code>，因此Python在<code>file_reader.py</code>所在的目录中查找<code>pi_digits.txt</code>。函数<code>open()</code>返回一个表示文件的对象。在这里，<code>open(&#39;pi_digits.txt&#39;)</code>返回一个表示文件<code>pi_digits.txt</code>的对象，Python将这个对象存储在我们将在后面使用的变量中。<br>关键字<code>with</code>在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了<code>open()</code>，但没有调用<code>close()</code>，你也可以调用<code>open()</code>和<code>close()</code>来打开和关闭文件，但这样做时，如果程序存在bug，导致<code>close()</code>语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用<code>close()</code>，你会发现需要使用文件时它已关闭，这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定:你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。<br>通过打印<code>contents</code>的值，就可将这个文本文件的全部内容显示出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535 </span><br><span class="line">8979323846 </span><br><span class="line">2643383279</span><br></pre></td></tr></table></figure><h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>当你将类似<code>pi_digits.txt</code>这样的简单文件名传递给函数<code>open()</code>时，Python将在当前执行的文件所在的目录中查找文件。<br>根据你组织文件的方式，有时可能要打开不在程序文件所属目录中的文件。例如，你可能将 程序文件存储在了文件夹<code>python_work</code>中，而在文件夹<code>python_work</code>中，有一个名为<code>text_files</code>的文件夹，用于存储程序文件操作的文本文件。虽然文件夹<code>text_files</code>包含在文件夹<code>python_work</code>中，但仅向<code>open()</code>传递位于该文件夹中的文件的名称也不可行，因为Python只在文件夹<code>python_work</code>中查找，而不会在其子文件夹<code>text_files</code>中查找。要让Python打开不与程序文件位于同一个目录中的文件，需要提供文件路径，它让Python到系统的特定位置去查找。<br>由于文件夹<code>text_files</code>位于文件夹<code>python_work</code>中，因此可使用相对文件路径来打开该文件夹中的文件。相对文件路径让Python到指定的位置去查找，而该位置是相对于当前运行的程序所在目录的。在Linux和OS X中，你可以这样编写代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;text_files/filename.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure><p>这行代码让Python到文件夹<code>python_work</code>下的文件夹<code>text_files</code>中去查找指定的.txt文件。在Windows系统中，在文件路径中使用反斜杠<code>\</code>而不是斜杠<code>/</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;text_files\filename.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure><p>你还可以将文件在计算机中的准确位置告诉Python，这样就不用关心当前运行的程序存储在什么地方了。这称为绝对文件路径。在相对路径行不通时，可使用绝对路径。例如，如果<code>text_files</code>并不在文件夹<code>python_work</code>中，而在文件夹<code>other_files</code>中，则向<code>open()</code>传递路径<code>&#39;text_files/ filename.txt&#39;</code>行不通，因为Python只在文件夹<code>python_work</code>中查找该位置。为明确地指出你希望Python到哪里去查找，你需要提供完整的路径。<br>绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给<code>open()</code>会有所帮助。在Linux和OS X中，绝对路径类似于下面这样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;/home/ehmatthes/other_files/text_files/filename.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure><p>而在Windows系统中，它们类似于下面这样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;C:\Users\ehmatthes\other_files\text_files\filename.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></table></figure><p>通过使用绝对路径，可读取系统任何地方的文件。就目前而言，最简单的做法是，要么将 据文件存储在程序文件所在的目录，要么将其存储在程序文件所在目录下的一个文件夹(如<code>text_files</code>)中。</p><h4 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h4><p>读取文件时，常常需要检查其中的每一行:你可能要在文件中查找特定的信息，或者要以某种方式修改文件中的文本。例如，你可能要遍历一个包含天气数据的文件，并使用天气描述中包含字样<code>sunny</code>的行。在新闻报道中，你可能会查找包含标签<code>&lt;headline&gt;</code>的行，并按特定的格式设置它。<br>要以每次一行的方式检查文件，可对文件对象使用for循环:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object: </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure><p>我们将要读取的文件的名称存储在变量<code>filename</code>中，这是使用文件时一种常见的做法。由于变量<code>filename</code>表示的并非实际文件——它只是一个让Python知道到哪里去查找文件的字符串，因此可轻松地将’pi_digits.txt’替换为你要使用的另一个文件的名称。</p><p>调用<code>open()</code>后，将一个表示文件及其内容的对象存储到了变量<code>file_object</code>中。这里也使用了关键字<code>with</code>，让Python负责妥善地打开和关闭文件。为查看文件的内容，我们通过对文件对象执行循环来遍历文件中的每一行，我们打印每一行时，发现空白行更多了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.1415926535 </span><br><span class="line"></span><br><span class="line">8979323846</span><br><span class="line"></span><br><span class="line">2643383279</span><br></pre></td></tr></table></figure><p>为何会出现这些空白行呢?因为在这个文件中，每行的末尾都有一个看不见的换行符，而<code>print</code>语句也会加上一个换行符，因此每行末尾都有两个换行符:一个来自文件，另一个来自<code>print</code>语句。</p><h4 id="创建一个包含文件各行内容的列表"><a href="#创建一个包含文件各行内容的列表" class="headerlink" title="创建一个包含文件各行内容的列表"></a>创建一个包含文件各行内容的列表</h4><p>使用关键字with时，<code>open()</code>返回的文件对象只在<code>with</code>代码块内可用。如果要在<code>with</code>代码块外访问文件的内容，可在<code>with</code>代码块内将文件的各行存储在一个列表中，并在<code>with</code>代码块外使用该列表:你可以立即处理文件的各个部分，也可推迟到程序后面再处理。<br>下面的示例在<code>with</code>代码块中将文件<code>pi_digits.txt</code>的各行存储在一个列表中，再在<code>with</code>代码块外打印它们:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines() </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line.rstrip())</span><br></pre></td></tr></table></figure><p>我们先使用方法<code>readlines()</code>从文件中读取每一行，并将其存储在一个列表中接下来，该列表被存储到变量<code>lines</code>中;在<code>with</code>代码块外，我们依然可以使用这个变量。我们使用一个简单的for循环来打印<code>lines</code>中的各行。由于列表<code>lines</code>的每个元素都对应于文件中的一行，因此输出 与文件内容完全一致。</p><h4 id="使用文件的内容"><a href="#使用文件的内容" class="headerlink" title="使用文件的内容"></a>使用文件的内容</h4><p>将文件读取到内存中后，就可以以任何方式使用这些数据了。下面以简单的方式使用圆周率 的值。首先，我们将创建一个字符串，它包含文件中存储的所有数字，且没有任何空格:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object: </span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">pi_string = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.rstrip()</span><br><span class="line">print(pi_string) </span><br><span class="line">print(<span class="built_in">len</span>(pi_string))</span><br></pre></td></tr></table></figure><p>就像前一个示例一样，我们首先打开文件，并将其中的所有行都存储在一个列表中。我们创建了一个变量——<code>pi_string</code>，用于存储圆周率的值。接下来，我们使用一个循环将各行都加入<code>pi_string</code>，并删除每行末尾的换行符。接着，我们打印这个字符串及其长度:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926535</span> <span class="number">8979323846</span> <span class="number">2643383279</span></span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure><p>在变量<code>pi_string</code>存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用<code>strip()</code>而不是<code>rstrip()</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;pi_30_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object: </span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">pi_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line">print(pi_string) </span><br><span class="line">print(<span class="built_in">len</span>(pi_string))</span><br></pre></td></tr></table></figure><p>这样，我们就获得了一个这样的字符串:它包含精确到30位小数的圆周率值。这个字符串长32字符，因为它还包含整数部分的3和小数点:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.141592653589793238462643383279</span></span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>保存数据的最简单的方式之一是将其写入到文件中。通过将输出写入文件，即便关闭包含程 序输出的终端窗口，这些输出也依然存在:你可以在程序结束运行后查看这些输出，可与别人分享输出文件，还可编写程序来将这些输出读取到内存中并进行处理。</p><h4 id="写入空文件"><a href="#写入空文件" class="headerlink" title="写入空文件"></a>写入空文件</h4><p>要将文本写入文件，你在调用open()时需要提供另一个实参，告诉Python你要写入打开的文 件。为明白其中的工作原理，我们来将一条简单的消息存储到文件中，而不是将其打印到屏幕上:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个示例中，调用<code>open()</code>时提供了两个实参。第一个实参也是要打开的文件的名称; 第二个实参<code>w</code>告诉Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式<code>r</code>、写入模式<code>w</code>、附加模式<code>a</code>或让你能够读取和写入文件的模式<code>r+</code>。如果 你省略了模式实参，Python将以默认的只读模式打开文件。</p><p>如果你要写入的文件不存在，函数<code>open()</code>将自动创建它。然而，以写入<code>w</code>模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。<br>我们使用文件对象的方法<code>write()</code>将一个字符串写入文件。这个程序没有终端输出，但如果你打开文件<code>programming.txt</code>，将看到其中包含如下一行内容:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love programming.</span><br></pre></td></tr></table></figure><p>相比于你的计算机中的其他文件，这个文件没有什么不同。你可以打开它、在其中输入新文本、复制其内容、将内容粘贴到其中等。</p><h4 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h4><p>函数<code>write()</code>不会在你写入的文本末尾添加换行符，因此如果你写入多行时没有指定换行符，<br>文件看起来可能不是你希望的那样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.&quot;</span>) </span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你打开programming.txt，将发现两行内容挤在一起:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I love programming.I love creating new games.</span><br></pre></td></tr></table></figure><p>要让每个字符串都单独占一行，需要在<code>write()</code>语句中包含换行符:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.\n&quot;</span>) </span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在，输出出现在不同行中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love programming.</span><br><span class="line">I love creating new games.</span><br></pre></td></tr></table></figure><h4 id="追加写入文件"><a href="#追加写入文件" class="headerlink" title="追加写入文件"></a>追加写入文件</h4><p>如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。你以<strong>附加模式</strong>打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python将为你创建一个空文件。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I also love finding meaning in large datasets.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating apps that can run in a browser.\n&quot;</span>)</span><br><span class="line">``` </span><br><span class="line">我们打开文件时指定了实参`a`，以便将内容附加到文件末尾，而不是覆盖文件原来的内容。然后，我们又写入了两行，它们被添加到文件`programming.txt`末尾:</span><br><span class="line">``` bash</span><br><span class="line">I love programming.</span><br><span class="line">I love creating new games.</span><br><span class="line">I also love finding meaning <span class="keyword">in</span> large datasets.</span><br><span class="line">I love creating apps that can run <span class="keyword">in</span> a browser.</span><br></pre></td></tr></table></figure><p>最终的结果是，文件原来的内容还在，它们后面是我们刚添加的内容。 19</p><blockquote><p>小作业<br>17-1 在文本编辑器中新建一个文件，写几句话来总结一下你至<br>此学到的Python知识。将这个文件命名为 learning_python.txt，并将其存储到为完成本章练习而编写的程序所在的目录中。编写一个程序，读取整个文件，并打印。<br>17-2 访客:编写一个程序，提示用户输入其名字;用户作出响应后，将其名字写入到文件 guest.txt中。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a>在文件夹<strong>17-1_17-2</strong>下</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 文件 </tag>
            
            <tag> Python 读写 </tag>
            
            <tag> Python I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-16】Python手把手教程之——类Class的继承、父类、子类</title>
      <link href="python-class-1-16.html"/>
      <url>python-class-1-16.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用 继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法;原有的类称为父类， 而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p><h4 id="子类的方法init"><a href="#子类的方法init" class="headerlink" title="子类的方法init()"></a>子类的方法<strong>init</strong>()</h4><p>创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法<code>__init__()</code>需要继承父类的方法。<br>例如，下面来模拟电动汽车。电动汽车是一种特殊的汽车，因此我们可以在前面创建的Car类的基础上创建新类<code>ElectricCar</code>，这样我们就只需为电动汽车特有的属性和行为编写代码。<br>下面来创建一个简单的<code>ElectricCar</code>类版本，它具备Car类的所有功能:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span> </span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model </span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span> </span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year) </span><br><span class="line">        </span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>首先是Car类的代码。创建子类时，父类必须包含在当前文件中，且位于子类前面。接着我们定义了子类<code>ElectricCar</code>。定义子类时，必须在括号内指定父类的名称。方法<code>__init__()</code> 接受创建Car实例所需的信息。</p><p><code>ElectricCar</code>内部的<code>super()</code>是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用<code>ElectricCar</code>的父类的方法<code>__init__()</code>，让<code>ElectricCar</code>实例包含父类的所有属性。父类也称为超类(<code>superclass</code>)，名称super因此而得名。</p><p>接下来我们测试一下继承的作用，我们尝试创建一辆电动汽车，但提供的信息与创建普通汽车时相同。我们创建<code>ElectricCar</code>类的一个实例，并将其存储在变量<code>my_tesla</code>中。这行代码调用<code>ElectricCar</code>类中定义的方法<code>__init__()</code>，后者让Python调用父类Car中定义的方法 <code>__init__()</code>。我们提供了实参’tesla’、’model s’和2016。<br>除方法<code>__init__()</code>外，电动汽车没有其他特有的属性和方法。当前，我们只想确认电动汽车具备普通汽车的行为，输出结果如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Tesla Model S</span><br></pre></td></tr></table></figure><p>ElectricCar实例的行为与Car实例一样，现在可以开始定义电动汽车特有的属性和方法了。</p><h4 id="给子类定义属性和方法"><a href="#给子类定义属性和方法" class="headerlink" title="给子类定义属性和方法"></a>给子类定义属性和方法</h4><p>让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。<br>下面来添加一个电动汽车特有的属性(电瓶)，以及一个描述该属性的方法。我们将存储电瓶容量，并编写一个打印电瓶描述的方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;电动汽车的独特之处 初始化父类的属性，再初始化电动汽车特有的属性 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year) </span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;This car has a &quot;</span> + <span class="built_in">str</span>(self.battery_size) + <span class="string">&quot;-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>) </span><br><span class="line">print(my_tesla.get_descriptive_name()) </span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure><p>我们添加了新属性<code>self.battery_size</code>，并设置其初始值。根据<code>ElectricCar</code>类创建的所有实例都将包含这个属性，但所有Car实例都不包含它。我们还添加了一个名为<code>describe_battery()</code>的方法，它打印有关电瓶的信息。我们调用这个方法时，将看到一条电动汽车特有的描述:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016 Tesla Model S</span><br><span class="line">This car has a 70-kWh battery.</span><br></pre></td></tr></table></figure><p>对于ElectricCar类的特殊化程度没有任何限制。模拟电动汽车时，你可以根据所需的准确程度添加任意数量的属性和方法。如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到Car类而不是ElectricCar类中。这样，使用Car类的人将获得相应的功能，而 ElectricCar类只包含处理电动汽车特有属性和行为的代码。</p><h4 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h4><p>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。<br>假设<code>Car</code>类有一个名为<code>fill_gas_tank()</code>的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span>():</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;电动汽车没有油箱&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;This car doesn&#x27;t need a gas tank!&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在，如果有人对电动汽车调用方法<code>fill_gas_tank()</code>，Python将忽略Car类中的方法<code>fill_gas_tank()</code>，转而运行上述代码。使用继承时，可让子类保留从父类那里继承的有用的代码，用重写来覆盖不需要的代码。</p><blockquote><p>本篇文章没有作业，下一篇我们讲解函数的高级用法</p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 类 </tag>
            
            <tag> Python Class </tag>
            
            <tag> Python 继承 </tag>
            
            <tag> Python 父类 </tag>
            
            <tag> Python 子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-15】Python手把手教程之——详解类Class以及类的使用</title>
      <link href="python-class-1-15.html"/>
      <url>python-class-1-15.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h3><p>使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类Dog——它表示的不是特定的小狗，而是任何小狗。对于大多数宠物狗，我们都知道些什么呢?它们都有名字和年龄，我们还知道，大多数小狗还会蹲下和打滚。由于大多数小狗都具备上述两项信息(名字和年龄)和两种行为(蹲下和打滚)，我们的Dog类将包含它们。这个类让Python知道如何创建表示小狗的对象。编写这个类后，我们将使用它来创建表示特定小狗的实例。</p><h4 id="创建Dog类"><a href="#创建Dog类" class="headerlink" title="创建Dog类"></a>创建Dog类</h4><p>根据Dog类创建的每个实例都将存储名字和年龄。我们赋予了每条小狗蹲下(<code>sit()</code>)和打滚(<code>roll_over()</code>)的能力:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;</span> </span><br><span class="line">        print(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;</span> </span><br><span class="line">        print(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure><p>首先我们定义了一个名为Dog的类。根据约定，在Python中，首字母大写的名称指的是类。 这个类定义中的括号是空的，因为我们要从空白创建这个类。<br>然后，我们编写了一个文档字符串，对这个类的功能作了描述。</p><h5 id="方法init"><a href="#方法init" class="headerlink" title="方法init()"></a>方法<strong>init</strong>()</h5><p>类中的函数称为方法，我们来第一个，<code>方法__init__()</code>是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种<strong>约定</strong>，旨在避免Python默认方法与普通方法发生名称冲突。  </p><p>我们将方法<code>__init__()</code>定义成了包含三个形参:<code>self</code>、<code>name</code>和<code>age</code>。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面。因为 Python调用这个<code>__init__()</code>方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时，Python将调用Dog类的方法<code>__init__()</code>。我们将通过实参向<code>Dog()</code>传递名字和年龄。self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给最后两个形参(<code>name</code>和<code>age</code>)提供值。</p><p><code>__init__()</code>内的两个变量都有前缀self。以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。<code>self.name = name</code>获取存储在形参<code>name</code>中的值，并将其存储到变量<code>name</code>中，然后该变量被关联到当前创建的实例。<code>self.age = age</code>的作用与此类似。像这样可通过实例访问的变量称为<strong>属性</strong>。   </p><p>Dog类还定义了另外两个方法:<code>sit()</code>和<code>roll_over()</code>。由于这些方法不需要额外的信<br>息，如名字或年龄，因此它们只有一个形参<code>self</code>。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前，<code>sit()</code>和<code>roll_over()</code>所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况:如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作。</p><h4 id="由类生成实例"><a href="#由类生成实例" class="headerlink" title="由类生成实例"></a>由类生成实例</h4><p>可将类视为有关如何创建实例的说明。Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。<br>下面来创建一个表示特定小狗的实例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里使用的是前一个示例中编写的Dog类。我们让Python创建一条名字为’willie’、 年龄为6的小狗。遇到这行代码时，Python使用实参’willie’和6调用Dog类中的方法<code>__init__()</code>。 方法<code>__init__()</code>创建一个表示特定小狗的示例，并使用我们提供的值来设置属性<code>name</code>和<code>age</code>。方法<code>__init__()</code>并未显式地包含<code>return</code>语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量<code>my_dog</code>中。在这里，命名约定很有用，我们通常可以认为首字母大写的名称(如 Dog)指的是类，而小写的名称(如my_dog)指的是根据类创建的实例。</p><h5 id="1-访问属性"><a href="#1-访问属性" class="headerlink" title="1. 访问属性"></a>1. 访问属性</h5><p>要访问实例的属性，可使用句点表示法。我们编写了如下代码来访问<code>my_dog</code>的属性name的值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dog.name</span><br></pre></td></tr></table></figure><p>句点表示法在Python中很常用，这种语法演示了Python如何获悉属性的值。在这里，Python先找到实例<code>my_dog</code>，再查找与这个实例相关联的属性<code>name</code>。在Dog类中引用这个属性时，使用的是<code>self.name</code>。然后我们使用同样的方法来获取属性age的值。<br>输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">My dog<span class="string">&#x27;s name is Willie.</span></span><br><span class="line"><span class="string">My dog is 6 years old.</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string">##### 2. 调用方法</span></span><br><span class="line"><span class="string">根据Dog类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法。下面来让小狗蹲下和打滚:</span></span><br><span class="line"><span class="string">``` py</span></span><br><span class="line"><span class="string">my_dog = Dog(&#x27;</span>willie<span class="string">&#x27;, 6)</span></span><br><span class="line"><span class="string">my_dog.sit()</span></span><br><span class="line"><span class="string">my_dog.roll_over()</span></span><br></pre></td></tr></table></figure><p>要调用方法，可指定实例的名称(这里是my_dog)和要调用的方法，并用句点分隔它们。执行代码my_dog.sit()时，Python在类Dog中查找方法<code>sit()</code>并运行其代码。Python以同样的方式解读代码<code>my_dog.roll_over()</code>。<br>这种语法很有用。如果给属性和方法指定了合适的描述性名称，如<code>name</code>、<code>age</code>、<code>sit()</code>和<code>roll_over()</code>，即便是从未见过的代码块，我们也能够轻松地推断出它是做什么的。</p><h5 id="3-创建多个实例"><a href="#3-创建多个实例" class="headerlink" title="3. 创建多个实例"></a>3. 创建多个实例</h5><p>可按需求根据类创建任意数量的实例。下面再创建一个名为<code>your_dog</code>的实例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">your_dog = Dog(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">print(<span class="string">&quot;\nYour dog&#x27;s name is &quot;</span> + your_dog.name.title() + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">print(<span class="string">&quot;Your dog is &quot;</span> + <span class="built_in">str</span>(your_dog.age) + <span class="string">&quot; years old.&quot;</span>) </span><br><span class="line">your_dog.sit()</span><br></pre></td></tr></table></figure><p>在这个实例中，我们创建了两条小狗，它们分别名为Willie和Lucy。每条小狗都是一个独立的实例，有自己的一组属性，能够执行相同的操作:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">My dog<span class="string">&#x27;s name is Willie. </span></span><br><span class="line"><span class="string">My dog is 6 years old. </span></span><br><span class="line"><span class="string">Willie is now sitting.</span></span><br><span class="line"><span class="string">Your dog&#x27;</span>s name <span class="keyword">is</span> Lucy. </span><br><span class="line">Your dog <span class="keyword">is</span> <span class="number">3</span> years old. </span><br><span class="line">Lucy <span class="keyword">is</span> now sitting.</span><br></pre></td></tr></table></figure><p>就算我们给第二条小狗指定同样的名字和年龄，Python依然会根据Dog类创建另一个实例。 你可按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用 列表或字典的不同位置。</p><h3 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a>使用类和实例</h3><p>你可以使用类来模拟现实世界中的很多情景。类编写好后，你的大部分时间都将花在使用根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。</p><h4 id="Car类"><a href="#Car类" class="headerlink" title="Car类"></a>Car类</h4><p>下面来编写一个表示汽车的类，它存储了有关汽车的信息，还有一个汇总这些信息的方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make </span><br><span class="line">        self.model = model </span><br><span class="line">        self.year = year</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>我们定义了方法<code>__init__()</code>。与前面的Dog类中一样，这个方法的第一个形参为self，我们还在这个方法中包含了另外三个形参:<code>make</code>、<code>model</code>和<code>year</code>。方法<code>__init__()</code>接受这些形参的值，并将它们存储在根据这个类创建的实例的属性中。创建新的Car实例时，我们需要指定其制造商、型号和生产年份。</p><p>然后我们又定义了一个名为<code>get_descriptive_name()</code>的方法，它使用属性<code>year</code>、<code>make</code>和<code>model</code>创建一个对汽车进行描述的字符串，让我们无需分别打印每个属性的值。为在这个方法中访问属性的值，我们使用了<code>self.make</code>、<code>self.model</code>和<code>self.year</code>。我们根据Car类创建了一个实例，并将其存储到变量<code>my_new_car</code>中。接下来，我们调用方法<code>get_descriptive_name()</code>，指出我们拥有的是一辆什么样的汽车:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br></pre></td></tr></table></figure><h4 id="给属性指定默认值"><a href="#给属性指定默认值" class="headerlink" title="给属性指定默认值"></a>给属性指定默认值</h4><p>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<code>__init__()</code>内指定这种初始值是可行的，如果你对某个属性这样做了，就无需包含为它提供初始值的形参。<br>下面来添加一个名为<code>odometer_reading</code>的属性，其初始值总是为0。我们还添加了一个名为<br><code>read_odometer()</code>的方法，用于读取汽车的里程表:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span> </span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>) </span><br><span class="line">print(my_new_car.get_descriptive_name()) </span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>现在，当Python调用方法<code>__init__()</code>来创建新实例时，将像前一个示例一样以属性的方式存储制造商、型号和生产年份。接下来，Python将创建一个名为<code>odometer_reading</code>的属性，并将其初始值设置为0。我们还定义了一个名为<code>read_odometer()</code>的方法，它让你能够轻松地获悉汽车的里程。<br>一开始汽车的里程为0: </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">0</span> miles on it.</span><br></pre></td></tr></table></figure><p>出售时里程表读数为0的汽车并不多，因此我们需要一个修改该属性的值的途径。</p><h4 id="修改属性的值"><a href="#修改属性的值" class="headerlink" title="修改属性的值"></a>修改属性的值</h4><p>可以以三种不同的方式修改属性的值:直接通过实例进行修改;通过方法进行设置;通过方 法进行递增(增加特定的值)。下面依次介绍这些方法。<br><strong>1. 直接修改属性的值</strong><br>要修改属性的值，最简单的方式是通过实例直接访问它。下面的代码直接将里程表读数设置为23:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>) </span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span> </span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>我们使用句点表示法来直接访问并设置汽车的属性<code>odometer_reading</code>。这行代码让 Python在实例<code>my_new_car</code>中找到属性<code>odometer_reading</code>，并将该属性的值设置为23:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><p>有时候需要像这样直接访问属性，但其他时候需要编写对属性进行更新的方法。</p><h5 id="2-通过方法修改属性的值"><a href="#2-通过方法修改属性的值" class="headerlink" title="2. 通过方法修改属性的值"></a>2. 通过方法修改属性的值</h5><p>如果有替你更新属性的方法，将大有裨益。这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新。下面的示例演示了一个名为<code>update_odometer()</code>的方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="comment">#### 前面的代码省略</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>) </span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>) </span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure><p>对Car类所做的唯一修改是，添加了方法<code>update_odometer()</code>。这个方法接受一个里程值，并将其存储到<code>self.odometer_reading</code>中。然后我们调用了<code>update_odometer()</code>，并向它提供了实参23(该实参对应于方法定义中的形参<code>mileage</code>)。它将里程表读数设置为23;而方法<code>read_odometer()</code>打印该读数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">23</span> miles on it.</span><br></pre></td></tr></table></figure><p>可对方法<code>update_odometer()</code>进行扩展，使其在修改里程表读数时做些额外的工作。下面来添加一些逻辑，禁止任何人将里程表读数往回调:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="comment">#### 前面的代码省略</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值 禁止将里程表读数往回调&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading: </span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br></pre></td></tr></table></figure><p>现在，<code>update_odometer()</code>在修改属性前检查指定的读数是否合理。如果新指定的里程 (<code>mileage</code>)大于或等于原来的里程(<code>self.odometer_reading</code>)，就将里程表读数改为新指定的里程，否则就发出警告，指出不能将里程表往回拨。</p><h5 id="3-通过方法对属性的值进行递增"><a href="#3-通过方法对属性的值进行递增" class="headerlink" title="3. 通过方法对属性的值进行递增"></a>3. 通过方法对属性的值进行递增</h5><p>有时候需要将属性值递增特定的量，而不是将其设置为全新的值。假设我们购买了一辆二手<br>车，且从购买到登记期间增加了100英里的里程，下面的方法让我们能够传递这个增量，并相应地增加里程表读数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span>        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span> </span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot;</span> </span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line">my_used_car = Car(<span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;outback&#x27;</span>, <span class="number">2013</span>) </span><br><span class="line">print(my_used_car.get_descriptive_name())</span><br><span class="line">my_used_car.update_odometer(<span class="number">23500</span>) </span><br><span class="line">my_used_car.read_odometer()</span><br><span class="line">my_used_car.increment_odometer(<span class="number">100</span>) </span><br><span class="line">my_used_car.read_odometer()</span><br></pre></td></tr></table></figure><p>新增的方法<code>increment_odometer()</code>接受一个单位为英里的数字，并将其加入到<code>self.odometer_reading</code>中。然后我们创建了一辆二手车——<code>my_used_car</code>。我们调用方法<code>update_odometer()</code>并传入23500，将这辆二手车的里程表读数设置为23500。然后我们调用<code>increment_odometer()</code>并传入100，以增加从购买到登记期间行驶的100英里:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2013</span> Subaru Outback</span><br><span class="line">This car has <span class="number">23500</span> miles on it. </span><br><span class="line">This car has <span class="number">23600</span> miles on it.</span><br></pre></td></tr></table></figure><p>你可以轻松地修改这个方法，以禁止增量为负值，从而防止有人利用它来回拨里程表。</p><blockquote><p> 小作业<br>15-1 用户:创建一个名为 User 的类，其中包含属性 first_name 和 last_name。在类User中定义一个名为 describe_user()的方 法，它打印用户信息摘要，创建多个表示不同用户的实例，并对每个实例都调用上述两个方法。<br>15-2 在为完成练习 15-1 而编写的User类中，添加一个名为login_attempts的属性。编写一个名为increment_login_attempts()的方法，它将属性login_attempts 的值加 1。再编写一个名为 reset_login_attempts()的方法，它将属性login_attempts的值重置为0。<br>根据User类创建一个实例，再调用方法increment_login_attempts()多次。打印属性login_attempts的值，确认它被正确地递增;然后，调用方法 reset_login_attempts()，并再次打印属性 login_attempts 的值，确认它被重置为0。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a>在文件夹<strong>15-1_15-2</strong>下</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 类 </tag>
            
            <tag> Python Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-14】Python手把手教程之——详解函数的高级用法</title>
      <link href="python-functions-1-14.html"/>
      <url>python-functions-1-14.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="传递列表"><a href="#传递列表" class="headerlink" title="传递列表"></a>传递列表</h3><p>你经常会发现，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象(如字典)。将列表传递给函数后，函数就能直接访问其内容。下面使用函数来提高处理列表的效率。  </p><p>假设有一个用户列表，我们要问候其中的每位用户。下面的示例将一个名字列表传递给一个名为<code>greet_users()</code>的函数，这个函数问候列表中的每个人:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;向列表中的每位用户都发出简单的问候&quot;&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        msg = <span class="string">&quot;Hello, &quot;</span> + name.title() + <span class="string">&quot;!&quot;</span> </span><br><span class="line">        print(msg)</span><br><span class="line">        </span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>] </span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure><p>我们将<code>greet_users()</code>定义成接受一个名字列表，并将其存储在形参<code>names</code>中。这个函数遍历收到的列表，并对其中的每位用户都打印一条问候语。然后我们定义了一个用户列表——<code>usernames</code>，然后调用<code>greet_users()</code>，并将这个列表传递给它:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Hannah! </span><br><span class="line">Hello, Ty! </span><br><span class="line">Hello, Margot!</span><br></pre></td></tr></table></figure><p>输出完全符合预期，每位用户都看到了一条个性化的问候语。每当你要问候一组用户时，都可调用这个函数。</p><h4 id="在函数中修改列表"><a href="#在函数中修改列表" class="headerlink" title="在函数中修改列表"></a>在函数中修改列表</h4><p>将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。  </p><p>来看一家为用户提交的设计制作3D打印模型的公司。需要打印的设计存储在一个列表中，打印后移到另一个列表中。下面是在不使用函数的情况下模拟这个过程的代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先创建一个列表，其中包含一些要打印的设计</span></span><br><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>] </span><br><span class="line">completed_models = []</span><br><span class="line"><span class="comment"># 模拟打印每个设计，直到没有未打印的设计为止</span></span><br><span class="line"><span class="comment"># 打印每个设计后，都将其移到列表completed_models中 </span></span><br><span class="line"><span class="keyword">while</span> unprinted_designs:</span><br><span class="line">    current_design = unprinted_designs.pop()</span><br><span class="line">    <span class="comment">#模拟根据设计制作3D打印模型的过程 </span></span><br><span class="line">    print(<span class="string">&quot;Printing model: &quot;</span> + current_design) completed_models.append(current_design)</span><br><span class="line"><span class="comment"># 显示打印好的所有模型</span></span><br><span class="line">print(<span class="string">&quot;\nThe following models have been printed:&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">    print(completed_model)</span><br></pre></td></tr></table></figure><p>这个程序首先创建一个需要打印的设计列表，还创建一个名为<code>completed_models</code>的空列表， 每个设计打印都将移到这个列表中。  </p><p>只要列表<code>unprinted_designs</code>中还有设计，<code>while</code>循环就模拟打印设计的过程:从该列表末尾删除一个设计，将其存储到变量<code>current_design</code>中，并显示一条消息，指出正在打印当前的设计，再将该设计加入到列表<code>completed_models</code>中。循环结束后，显示已打印的所有设计:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Printing model: dodecahedron </span><br><span class="line">Printing model: robot pendant</span><br><span class="line">Printing model: iphone case </span><br><span class="line"></span><br><span class="line">The following models have been printed: </span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">iphone case</span><br></pre></td></tr></table></figure><p>为重新组织这些代码，我们可编写两个函数，每个都做一件具体的工作。大部分代码都与原来相同，只是效率更高。第一个函数将负责处理打印设计的工作，而第二个将概述打印了哪些设计:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_models</span>(<span class="params">unprinted_designs, completed_models</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟打印每个设计，直到没有未打印的设计为止打印每个设计后，都将其移到列表completed_models中</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> unprinted_designs:</span><br><span class="line">        current_design = unprinted_designs.pop()</span><br><span class="line">        <span class="comment"># 模拟根据设计制作3D打印模型的过程</span></span><br><span class="line">        print(<span class="string">&quot;Printing model: &quot;</span> + current_design)</span><br><span class="line">        completed_models.append(current_design)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_completed_models</span>(<span class="params">completed_models</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示打印好的所有模型&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nThe following models have been printed:&quot;</span>) <span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">        print(completed_model)</span><br><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>] </span><br><span class="line">completed_models = []</span><br><span class="line"></span><br><span class="line">print_models(unprinted_designs, completed_models) </span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure><p>首先，我们定义了函数<code>print_models()</code>，它包含两个形参:一个需要打印的设计列表和一个打印好的模型列表。</p><p>给定这两个列表，这个函数模拟打印每个设计的过程:将设计逐个地从未 打印的设计列表中取出，并加入到打印好的模型列表中。</p><p>然后，我们定又义了函数<code>show_completed_models()</code>，它包含一个形参:打印好的模型列表。给定这个列表，函数<code>show_completed_models()</code>显示打印出来的每个模型的名称。<br>这个程序的输出与未使用函数的版本相同，但组织更为有序。完成大部分工作的代码都移到了两个函数中，让主程序更容易理解。只要看看主程序，你就知道这个程序的功能容易看清得多:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>] </span><br><span class="line">completed_models = []</span><br><span class="line">print_models(unprinted_designs, completed_models) </span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure><p>我们创建了一个未打印的设计列表，还创建了一个空列表，用于存储打印好的模型。接下来，由于我们已经定义了两个函数，因此只需调用它们并传入正确的实参即可。我们调用<code>print_models()</code>并向它传递两个列表;像预期的一样，<code>print_models()</code>模拟打印设计的过程。接下来，我们调用<code>show_completed_models()</code>，并将打印好的模型列表传递给它，让其能够指出打印了哪些模型。描述性的函数名让别人阅读这些代码时也能明白，虽然其中没有任何注释。  </p><p>相比于没有使用函数的版本，这个程序更容易扩展和维护。如果以后需要打印其他设计，只需再次调用<code>print_models()</code>即可。如果我们发现需要对打印代码进行修改，只需修改这些代码一次，就能影响所有调用该函数的地方;与必须分别修改程序的多个地方相比，这种修改的效率更高。</p><p>这个程序还演示了这样一种理念，即每个函数都应只负责一项具体的工作。第一个函数打印每个设计，而第二个显示打印好的模型;这优于使用一个函数来完成两项工作。编写函数时，如果你发现它执行的任务太多，请尝试将这些代码划分到两个函数中。别忘了，总是可以在一个函 数中调用另一个函数，这有助于将复杂的任务划分成一系列的步骤。</p><h3 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h3><p>有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。 </p><p>例如，来看一个制作披萨的函数，它需要接受很多配料，但你无法预先确定顾客要多少种配料。下面的函数只有一个形参<code>*toppings</code>，但不管调用语句提供了多少实参，这个形参都将它们统统收入囊中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;</span> </span><br><span class="line">    print(toppings)</span><br><span class="line">    make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">    make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>形参名<code>*toppings</code>中的星号让Python创建一个名为<code>toppings</code>的空元组，并将收到的所有值都封装到这个元组中。函数体内的<code>print</code>语句通过生成输出来证明Python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。<br>它以类似的方式处理不同的调用，注意，Python将实参封装到一个元组中，即便函数只收到一个值也如此:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;pepperoni&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在，我们可以将这条<code>print</code>语句替换为一个循环，对配料列表进行遍历，并对顾客点的披萨进行描述:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nMaking a pizza with the following toppings:&quot;</span>) </span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">&quot;- &quot;</span> + topping)</span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不管收到的是一个值还是三个值，这个函数都能妥善地处理:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Making a pizza <span class="keyword">with</span> the following toppings: </span><br><span class="line">- pepperoni</span><br><span class="line">Making a pizza <span class="keyword">with</span> the following toppings: </span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure><p>不管函数收到的实参是多少个，这种语法都管用。</p><h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><p>函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。<code>import</code>语句允许在当前运行的程序文件中使用模块中的代码。<br>通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。知道如何导入函数还能让你使用其他程序员编写的函数库。<br>导入模块的方法有多种，下面对每种都作简要的介绍。</p><h4 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h4><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。下面来创建一个包含函数<code>make_pizza()</code>的模块。为此，我们将文件<code>pizza.py</code>中除函数<code>make_pizza()</code>之外的其他代码都删除:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size, *toppings</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) + <span class="string">&quot;-inch pizza with the following toppings:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">&quot;- &quot;</span> + topping)</span><br></pre></td></tr></table></figure><p>接下来，我们在<code>pizza.py</code>所在的目录中创建另一个名为<code>making_pizzas.py</code>的文件，这个文件导入刚创建的模块，再调用<code>make_pizza()</code>两次:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Python读取这个文件时，代码行<code>import pizza</code>让Python打开文件<code>pizza.py</code>，并将其中的所有函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时，Python在幕后复制这些代码。你只需知道，在<code>making_pizzas.py</code>中，可以使用<code>pizza.py</code>中定义的所有函数。</p><p>要调用被导入的模块中的函数，可指定导入的模块的名称<code>pizza</code>和函数名<code>make_pizza()</code>，并用句点分隔它们。这些代码的输出与没有导入模块的原始程序相同:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line">Making a 12-inch pizza with the following toppings: </span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure><p>这就是一种导入方法:只需编写一条import语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。如果你使用这种import语句导入了名为<code>module_name.py</code>的整个模块，就可使用下面的语法来使用其中任何一个函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure><h4 id="导入特定的函数"><a href="#导入特定的函数" class="headerlink" title="导入特定的函数"></a>导入特定的函数</h4><p>你还可以导入模块中的特定函数，这种导入方法的语法如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br></pre></td></tr></table></figure><p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2</span><br></pre></td></tr></table></figure><p>对于前面的<code>making_pizzas.py</code>示例，如果只想导入要使用的函数，代码将类似于下面这样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>若使用这种语法，调用函数时就无需使用句点。由于我们在import语句中显式地导入了函数<code>make_pizza()</code>，因此调用它时只需指定其名称。</p><h4 id="使用as给函数指定别名"><a href="#使用as给函数指定别名" class="headerlink" title="使用as给函数指定别名"></a>使用as给函数指定别名</h4><p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名——函数的另一个名称，类似于外号。要给函数指定这种特殊外号，需要在导入它时这样做。<br>下面给函数<code>make_pizza()</code>指定了别名<code>mp()</code>。这是在import语句中使用<code>make_pizza as mp</code>实现的，关键字<code>as</code>将函数重命名为你提供的别名:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line">mp(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">mp(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的import语句将函数make_pizza()重命名为mp();在这个程序中，每当需要调用<code>make_pizza()</code>时，都可简写成<code>mp()</code>，而Python将运行<code>make_pizza()</code>中的代码，这可避免与这个程序可能包含的函数<code>make_pizza()</code>混淆。指定别名的通用语法如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name <span class="keyword">as</span> fn</span><br></pre></td></tr></table></figure><h4 id="使用as给模块指定别名"><a href="#使用as给模块指定别名" class="headerlink" title="使用as给模块指定别名"></a>使用as给模块指定别名</h4><p>你还可以给模块指定别名。通过给模块指定简短的别名(如给模块pizza指定别名p)，让你能够更轻松地调用模块中的函数。相比于<code>pizza.make_pizza()</code>，<code>p.make_pizza()</code>更为简洁:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述import语句给模块<code>pizza</code>指定了别名p，但该模块中所有函数的名称都没变。调用函数<code>make_pizza()</code>时，可编写代码<code>p.make_pizza()</code>而不是<code>pizza.make_pizza()</code>，这样不仅能使代码更简洁，还可以让你不再关注模块名，而专注于描述性的函数名。这些函数名明确地指出了函数的功能，对理解代码而言，它们比模块名更重要。  给模块指定别名的通用语法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import module_name as mn</span><br></pre></td></tr></table></figure><h4 id="导入模块中的所有函数"><a href="#导入模块中的所有函数" class="headerlink" title="导入模块中的所有函数"></a>导入模块中的所有函数</h4><p>使用星号(*)运算符可让Python导入模块中的所有函数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pizza import *</span><br><span class="line">make_pizza(16, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(12, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>import语句中的星号让Python将模块<code>pizza</code>中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法:如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果:Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。</p><p>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写 的代码时，如果遇到类似于下面的import语句，能够理解它们:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h3 id="函数编写指南"><a href="#函数编写指南" class="headerlink" title="函数编写指南"></a>函数编写指南</h3><p>编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下 划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。<br>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字 符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它:他们完全 可以相信代码如描述的那样运行;只要知道函数的名称、需要的实参以及返回值的类型，就能在 自己的程序中使用它。<br>给形参指定默认值时，等号两边不要有空格:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span>(<span class="params">parameter_0, parameter_1=<span class="string">&#x27;default value&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>对于函数调用中的关键字实参，也应遵循这种约定:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(value_0, parameter_1=<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure><p>官方建议代码行的长度不要超过79字符，这样只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一 层的函数体区分开来。<br>大多数编辑器都会自动对齐后续参数列表行，使其缩进程度与你给第一个参数列表行指定的 缩进程度相同:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span>(<span class="params">parameter_0, parameter_1, parameter_2, parameter_3, parameter_4, parameter_5</span>):</span></span><br><span class="line">    function body...</span><br></pre></td></tr></table></figure><p>如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一 个函数在什么地方结束，下一个函数从什么地方开始。所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 函数 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-13】Python手把手教程之——详解函数和函数的使用</title>
      <link href="python-functions-1-13.html"/>
      <url>python-functions-1-13.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>下面是一个打印问候语的简单函数，名为greet_user()：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><p>这个示例演示了最简单的函数结构。使用关键字<code>def</code>来告诉Python你要定义一个<br>函数。在这里，函数名为<code>greet_user()</code>，它不需要任何信息就能完成其工作，因此括号是空的（即便如此，括号也必不可少）。最后，定义以冒号结尾。</p><p>紧跟在<code>def greet_user()</code>:后面的所有缩进行构成了函数体。代码行<code>print(&quot;Hello!&quot;</code>)是函数体内的唯一一行代码，<code>greet_user()</code>只做一项工作：打印Hello!。 </p><p>由于这个函数不需要任何参数，因此调用它时只需输入<code>greet_user()</code>即可。和预期的一样，它打印<code>Hello!</code>。</p><h4 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a>向函数传递信息</h4><p>只需稍作修改，就可以让函数<code>greet_user()</code>不仅向用户显示<code>Hello!</code>，还将用户的名字用作参数。  </p><p>因此，可在函数定义<code>def greet_user()</code>的括号内添加<code>username</code>。通过在这里添加<code>username</code>，就可让函数接受你给<code>username</code>指定的任何值。现在，这个函数要求你调用它时给<code>username</code>指定一个值。调用<code>greet_user()</code>时，可将一个名字传递给它，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;Hello, &quot;</span> + username.title() + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">greet_user(<span class="string">&#x27;Fulade&#x27;</span>) </span><br></pre></td></tr></table></figure><p>代码<code>greet_user(&#39;Fulade&#39;)</code>调用函数<code>greet_user()</code>，并向它提供执行<code>print</code>语句所需的信息。这个函数接受你传递给它的名字，并向这个人发出问候：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Fulade !</span><br></pre></td></tr></table></figure><p>同样，<code>greet_user(&#39;sarah&#39;)</code>调用函数<code>greet_user()</code>并向它传递<code>sarah</code>，打印<code>Hello, Sarah!</code>。<br>你可以根据需要调用函数<code>greet_user()</code>任意次，调用时无论传入什么样的名字，都会生成相应的输出。</p><h4 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h4><p>前面定义函数<code>greet_user()</code>时，要求给变量<code>username</code>指定一个值。调用这个函数并提供这种参数，它将打印相应的问候语。  </p><p>在函数<code>greet_user()</code>的定义中，变量<code>username</code>是一个形参——函数完成其工作所需的一项信息。在代码<code>greet_user(&#39;Fulade&#39;)</code>中，值<code>Fulade</code>是一个实参。</p><p>实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在<code>greet_user(&#39;Fulade&#39;)</code>中，将实参<code>Fulade</code>传递给了函数<code>greet_user()</code>，这个值被存储在形参<code>username</code>中。</p><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><p>鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。下面来依次介绍这些方式。</p><h4 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h4><p>你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。因此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。为明白其中的工作原理，来看一个显示宠物信息的函数。这个函数指出一个宠物属于哪种动物以及它叫什么名字，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个函数的定义表明，它需要一种动物类型和一个名字。调用<code>describe_pet()</code>时，需要按顺序提供一种动物类型和一个名字。</p><p>例如，在前面的函数调用中，实参<code>hamster</code>存储在形参<code>animal_type</code>中，而实参<code>harry</code>存储在形参<code>pet_name</code>中。在函数体内，使用了这两个形参来显示宠物的信息。</p><h5 id="调用函数多次"><a href="#调用函数多次" class="headerlink" title="调用函数多次"></a>调用函数多次</h5><p>你可以根据需要调用函数任意次。要再描述一个宠物，只需再次调用<code>describe_pet()</code>即可：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;willie&#x27;</span>) </span><br></pre></td></tr></table></figure><p>第二次调用<code>describe_pet()</code>函数时，我们向它传递了实参<code>dog</code>和<code>willie</code>。与第一次调用时一样，Python将实参<code>dog</code>关联到形参<code>animal_type</code>，并将实参<code>willie</code>关联到形参<code>pet_name</code>。  </p><p>与前面一样，这个函数完成其任务，但打印的是一条名为<code>Willie</code>的小狗的信息。至此，我们有一只名为<code>Harry</code>的仓鼠，还有一条名为<code>Willie</code>的小狗：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I have a hamster.</span><br><span class="line">My hamster<span class="string">&#x27;s name is Harry.</span></span><br><span class="line"><span class="string">I have a dog.</span></span><br><span class="line"><span class="string">My dog&#x27;</span>s name is Willie. </span><br></pre></td></tr></table></figure><p>调用函数多次是一种效率极高的工作方式。我们只需在函数中编写描述宠物的代码一次，然后每当需要描述新宠物时，都可调用这个函数，并向它提供新宠物的信息。即便描述宠物的代码增加到了10行，你依然只需使用一行调用函数的代码，就可描述一个新宠物。  </p><p>在函数中，可根据需要使用任意数量的位置实参，Python将按顺序将函数调用中的实参关联到函数定义中相应的形参。</p><h5 id="位置实参的顺序很重要"><a href="#位置实参的顺序很重要" class="headerlink" title="位置实参的顺序很重要"></a>位置实参的顺序很重要</h5><p>使用位置实参来调用函数时，如果实参的顺序不正确，结果可能出乎意料：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;harry&#x27;</span>, <span class="string">&#x27;hamster&#x27;</span>) </span><br></pre></td></tr></table></figure><p>在这个函数调用中，我们先指定名字，再指定动物类型。由于实参<code>harry</code>在前，这个值将存储到形参<code>animal_type</code>中；同理，<code>hamster</code>将存储到形参<code>pet_name</code>中。结果是我们得到了一个名为<code>Hamster</code>的<code>harry</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I have a harry.</span><br><span class="line">My harry<span class="string">&#x27;s name is Hamster. </span></span><br></pre></td></tr></table></figure><p>如果结果像上面一样搞笑，请确认函数调用中实参的顺序与函数定义中形参的顺序一致。</p><h4 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h4><p>关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。</p><p>关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。下面来重新编写<code>pets.py</code>，在其中使用关键字实参来调用<code>describe_pet()</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>) </span><br></pre></td></tr></table></figure><p>函数<code>describe_pet()</code>还是原来那样，但调用这个函数时，我们向Python明确地指出了各个实参对应的形参。看到这个函数调用时，Python知道应该将实参<code>hamster</code>和<code>harry</code>分别存储在形参<code>animal_type</code>和<code>pet_name</code>中。输出正确无误，它指出我们有一只名为<code>Harry</code>的仓鼠。  </p><p>关键字实参的顺序无关紧要，因为Python知道各个值该存储到哪个形参中。下面两个函数调用是等效的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>) </span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。  </p><p>例如，如果你发现调用<code>describe_pet()</code>时，描述的大都是小狗，就可将形参<code>animal_type</code>的默认值设置为<code>dog</code>。这样，调用<code>describe_pet()</code>来描述小狗时，就可不提供这种信息：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>) </span><br></pre></td></tr></table></figure><p>这里修改了函数<code>describe_pet()</code>的定义，在其中给形参<code>animal_type</code>指定了默认值<code>dog</code>。这样，调用这个函数时，如果没有给<code>animal_type</code>指定值，Python将把这个形参设置为<code>dog</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I have a dog.</span><br><span class="line">My dog<span class="string">&#x27;s name is Willie. </span></span><br></pre></td></tr></table></figure><p>请注意，在这个函数的定义中，修改了形参的排列顺序。由于给<code>animal_type</code>指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名字。然而，Python依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参。这就是需要将pet_name放在形参列表开头的原因所在。  </p><p>现在，使用这个函数的最简单的方式是，在函数调用中只提供小狗的名字：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(<span class="string">&#x27;willie&#x27;</span>) </span><br></pre></td></tr></table></figure><p>这个函数调用的输出与前一个示例相同。只提供了一个实参——<code>willie</code>，这个实参将关联到函数定义中的第一个形参——<code>pet_name</code>。由于没有给<code>animal_type</code>提供实参，因此Python使用其默认值<code>dog</code>。<br>如果要描述的动物不是小狗，可使用类似于下面的函数调用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>) </span><br></pre></td></tr></table></figure><p>由于显式地给<code>animal_type</code>提供了实参，因此Python将忽略这个形参的默认值。</p><h4 id="等效的函数调用"><a href="#等效的函数调用" class="headerlink" title="等效的函数调用"></a>等效的函数调用</h4><p>由于可混合使用位置实参、关键字实参和默认值，通常有多种等效的函数调用方式。请看下<br>面的函数<code>describe_pets()</code>的定义，其中给一个形参提供了默认值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>):</span> </span><br></pre></td></tr></table></figure><p>基于这种定义，在任何情况下都必须给<code>pet_name</code>提供实参；指定该实参时可以使用位置方式，也可以使用关键字方式。如果要描述的动物不是小狗，还必须在函数调用中给<code>animal_type</code>提供实参；同样，指定该实参时可以使用位置方式，也可以使用关键字方式。</p><p>下面对这个函数的所有调用都可行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一条名为Willie的小狗</span></span><br><span class="line">describe_pet(<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line"><span class="comment"># 一只名为Harry的仓鼠</span></span><br><span class="line">describe_pet(<span class="string">&#x27;harry&#x27;</span>, <span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>) </span><br></pre></td></tr></table></figure><p>这些函数调用的输出与前面的示例相同。</p><h4 id="避免实参错误"><a href="#避免实参错误" class="headerlink" title="避免实参错误"></a>避免实参错误</h4><p>等你开始使用函数后，如果遇到实参不匹配错误，不要大惊小怪。你提供的实参多于或少于函数完成其工作所需的信息时，将出现实参不匹配错误。<br>例如，如果调用函数<code>describe_pet()</code>时没有指定任何实参，结果将如何呢？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet()</span><br></pre></td></tr></table></figure><p>Python发现该函数调用缺少必要的信息，而<code>traceback</code>指出了这一点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">&quot;pets.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> describe_pet()</span><br><span class="line"> TypeError: describe_pet() missing <span class="number">2</span> required positional arguments: <span class="string">&#x27;animal_</span></span><br><span class="line"><span class="string">type&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;pet_name&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。在函数中，可使用<code>return</code>语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。</p><h4 id="返回简单值"><a href="#返回简单值" class="headerlink" title="返回简单值"></a>返回简单值</h4><p>下面来看一个函数，它接受名和姓并返回姓名：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">    musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line">print(musician) </span><br></pre></td></tr></table></figure><p>函数<code>get_formatted_name()</code>的定义通过形参接受名和姓。它将姓和名合而为一，在它们之间加上一个空格，并将结果存储在变量<code>full_name</code>中。然后，将<code>full_name</code>的值转换为首字母大写格式，并将结果返回到函数调用行。调用返回值的函数时，需要提供一个变量，用于存储返回的值。</p><p>在这里，将返回值存储在了变量<code>musician</code>中。输出是姓名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jimi Hendrix </span><br></pre></td></tr></table></figure><h4 id="让实参变成可选的"><a href="#让实参变成可选的" class="headerlink" title="让实参变成可选的"></a>让实参变成可选的</h4><p>有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。<br>例如，假设我们要扩展函数<code>get_formatted_name()</code>，使其还处理中间名。为此，可将其修改成类似于下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def get_formatted_name(first_name, middle_name, last_name):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;返回姓名&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    full_name = first_name + <span class="string">&#x27; &#x27;</span> + middle_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="built_in">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;lee&#x27;</span>, <span class="string">&#x27;hooker&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician) </span><br></pre></td></tr></table></figure><p>只要同时提供名、中间名和姓，这个函数就能正确地运行。它根据这三部分创建一个字符串，在适当的地方加上空格，并将结果转换为首字母大写格式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">John Lee Hooker </span><br></pre></td></tr></table></figure><p>然而，并非所有的人都有中间名，但如果你调用这个函数时只提供了名和姓，它将不能正确地运行。为让中间名变成可选的，可给实参<code>middle_name</code>指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参。<br>为让<code>get_formatted_name()</code>在没有提供中间名时依然可行，可给实参<code>middle_name</code>指定一个默认值——空字符串，并将其移到形参列表的末尾：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot;返回姓名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + middle_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line">print(musician)</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;hooker&#x27;</span>, <span class="string">&#x27;lee&#x27;</span>)</span><br><span class="line">print(musician) </span><br></pre></td></tr></table></figure><p>在这个示例中，姓名是根据三个可能提供的部分创建的。由于人都有名和姓，因此在函数定义中首先列出了这两个形参。中间名是可选的，因此在函数定义中最后列出该形参，并将其默认值设置为空字符串。  </p><p>在函数体中，我们检查是否提供了中间名。Python将非空字符串解读为True，因此如果函数调用中提供了中间名，<code>if middle_name</code>将为<code>True</code>。如果提供了中间名，就将名、中间名和姓合并为姓名，然后将其修改为首字母大写格式，并返回到函数调用行。</p><p>在函数调用行，将返回的值存储在变量<code>musician</code>中；然后将这个变量的值打印出来。如果没有提供中间名，<code>middle_name</code>将为空字符串，导致<code>if</code>测试未通过，进而执行<code>else</code>代码块：只使用名和姓来生成姓名，并将设置好格式的姓名返回给函数调用行。</p><p>在函数调用行，将返回的值存储在变量<code>musician</code>中；然后将这个变量的值打印出来。调用这个函数时，如果只想指定名和姓，调用起来将非常简单。如果还要指定中间名，就必须确保它是最后一个实参，这样Python才能正确地将位置实参关联到形参。<br>这个修改后的版本适用于只有名和姓的人，也适用于还有中间名的人：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jimi Hendrix</span><br><span class="line">John Lee Hooker</span><br></pre></td></tr></table></figure><p>可选值让函数能够处理各种不同情形的同时，确保函数调用尽可能简单。</p><blockquote><p>本篇文章没有作业，下一篇我们讲解函数的高级用法</p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python 函数 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-12】Python手把手教程之——用户输入input函数</title>
      <link href="python-input-12.html"/>
      <url>python-input-12.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="函数input"><a href="#函数input" class="headerlink" title="函数input()"></a>函数input()</h3><p>函数<code>input()</code>让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。<br>例如，下面的程序让用户输入一些文本，再将这些文本呈现给用户:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;Tell me something, and I will repeat it back to you: &quot;</span>)</span><br><span class="line">print(message) </span><br></pre></td></tr></table></figure><p>函数<code>input(</code>)接受一个参数：即要向用户显示的提示或说明，让用户知道该如何做。在这个示例中，用户将看到提示<code>Tell me something, and I will repeat it back to you:</code>。程序等待用户输入，并在用户按回车键后继续运行。<br>输入存储在变量<code>message</code>中，接下来的<code>print(message)</code>将输入呈现给用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tell me something, and I will repeat it back to you: This is Fulade!</span><br><span class="line">This is Fulade! </span><br></pre></td></tr></table></figure><p>每当你使用函数<code>input()</code>时，都应指定清晰而易于明白的提示，准确地指出你希望用户提供什么样的信息——指出用户该输入任何信息的提示都行，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>) </span><br></pre></td></tr></table></figure><p>通过在提示末尾（这里是冒号后面）包含一个空格，可将提示与用户输入分开，让用户清楚地知道其输入始于何处，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter your name: Fulade</span><br><span class="line">Hello, Fulade! </span><br></pre></td></tr></table></figure><h4 id="int-函数"><a href="#int-函数" class="headerlink" title="int()函数"></a>int()函数</h4><p>使用函数<code>input()</code>时，Python将用户输入解读为字符串。请看下面让用户输入其年龄的解释器会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; age = input(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">How old are you? 21</span><br><span class="line">&gt;&gt;&gt; age</span><br><span class="line"><span class="string">&#x27;21&#x27;</span> </span><br></pre></td></tr></table></figure><p>用户输入的是数字21，但我们请求Python提供变量<code>age</code>的值时，它返回的是’21’——用户输入<br>的数值的字符串表示。我们怎么知道Python将输入解读成了字符串呢？因为这个数字用引号括起<br>了。<br>如果我们只想打印输入，这一点问题都没有；但如果你试图将输入作为数字使用，就会引发错误：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="built_in">input</span>(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">How old are you? 21</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age &gt;= <span class="number">18</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unorderable types: <span class="built_in">str</span>() &gt;= <span class="built_in">int</span>()</span><br></pre></td></tr></table></figure><p>你试图将输入用于数值比较时，Python会引发错误，因为它无法将字符串和整数进<br>行比较：不能将存储在<code>age</code>中的字符串’21’与数值18进行比较。<br>为解决这个问题，可使用函数<code>int()</code>，它让Python将输入视为数值。函数<code>int()</code>将数字的字符<br>串表示转换为数值表示，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="built_in">input</span>(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">How old are you? 21</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age &gt;= <span class="number">18</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们在提示时输入21后，Python将这个数字解读为字符串，但随后<code>int()</code>将这个字符串转换成了数值表示。<br>这样Python就能运行条件测试了：将变量age（它现在包含数值21）同18进行比较，看它是否大于或等于18。测试结果为<code>True</code>。<br>如何在实际程序中使用函数<code>int()</code>呢？请看下面的程序，它判断一个人是否满足坐过山车的身高要求:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">input</span>(<span class="string">&quot;How tall are you, in inches? &quot;</span>)</span><br><span class="line">height = <span class="built_in">int</span>(height)</span><br><span class="line"><span class="keyword">if</span> height &gt;= <span class="number">36</span>:</span><br><span class="line">    print(<span class="string">&quot;\nYou&#x27;re tall enough to ride!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    print(<span class="string">&quot;\nYou&#x27;ll be able to ride when you&#x27;re a little older.&quot;</span>) </span><br></pre></td></tr></table></figure><p>在这个程序中，为何可以将height同36进行比较呢？因为在比较前，height = int(height)<br>将输入转换成了数值表示。如果输入的数字大于或等于36，我们就告诉用户他满足身高条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How tall are you, <span class="keyword">in</span> inches? 71</span><br><span class="line">You<span class="string">&#x27;re tall enough to ride! </span></span><br></pre></td></tr></table></figure><p>将数值输入用于计算和比较前，务必将其转换为数值表示。</p><h4 id="使用while推出"><a href="#使用while推出" class="headerlink" title="使用while推出"></a>使用while推出</h4><p>可使用<code>while</code>循环让程序在用户愿意时不断地运行，我们在其中定义了一个退出值，只要用户输入的不是这个值，程序就可以接着运行:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span></span><br><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    print(message) </span><br></pre></td></tr></table></figure><p>我们定义了一条提示消息，告诉用户他有两个选择：要么输入一条消息，要么输<br>入退出值（这里为’quit’）。</p><p>接下来，我们创建了一个变量——<code>message</code>，用于存储用户<br>输入的值。我们将变量<code>message</code>的初始值设置为空字符串””，让Python首次执行<code>while</code>代码行时有可供检查的东西。</p><p>Python首次执行<code>while</code>语句时，需要将<code>message</code>的值与’quit’进行比较，但此时用户还没有输入。如果没有可供比较的东西，Python将无法继续运行程序。  </p><p>为解决这个问题，我们必须给变量<code>message</code>指定一个初始值。虽然这个初始值只是一个空字符串，但符合要求，让Python能够执行<code>while</code>循环所需的比较。只要<code>message</code>的值不是’quit’，这个循就会不断运行。</p><p>首次遇到这个循环时，<code>message</code>是一个空字符串，因此Python进入这个循环。执行到代码行<code>message = input(prompt)</code>时，Python显示提示消息，并等待用户输入。  </p><p>不管用户输入是什么，都 将存储到变量<code>message</code>中并打印出来；接下来，Python重新检查<code>while</code>语句中的条件。只要用户输入的不是单词<code>quit</code>，Python就会再次显示提示消息并等待用户输入。  </p><p>等到用户终于输入<code>quit</code>后，Python停止执行while循环，而整个程序也到此结束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tell me something, and I will repeat it back to you:</span><br><span class="line">Enter <span class="string">&#x27;quit&#x27;</span> to end the program. Hello everyone!</span><br><span class="line">Hello everyone!</span><br><span class="line">Tell me something, and I will repeat it back to you:</span><br><span class="line">Enter <span class="string">&#x27;quit&#x27;</span> to end the program. Hello again. </span><br><span class="line">Hello again.</span><br><span class="line">Tell me something, and I will repeat it back to you:</span><br><span class="line">Enter <span class="string">&#x27;quit&#x27;</span> to end the program. quit</span><br><span class="line">quit </span><br></pre></td></tr></table></figure><p>这个程序很好，唯一美中不足的是，它将单词<code>quit</code>也作为一条消息打印了出来。为修复这种问题，只需使用一个简单的if判断：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span></span><br><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        print(message) </span><br></pre></td></tr></table></figure><p>现在，程序在显示消息前将做简单的检查，仅在消息不是退出值时才打印它。</p><blockquote><p>小作业<br>12.1 编写一个程序，询问用户要咨询什么样的汽车，并打印一条消息，如”Let me see if I can find you a Subaru”。<br>12.2 餐馆订位：编写一个程序，询问用户有多少人用餐。如果超过 8 人，就打印一条消息，指出没有空桌；否则指出有空桌。<br>12.3 让用户输入一个数字，并指出这个数字是否是 10 的整数倍。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a>在文件夹<strong>12-1_12-3</strong>下</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python input语句 </tag>
            
            <tag> Python input </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows下使用Anaconda安装TesnsorFlow 2.x</title>
      <link href="tensorflow-windows-install-anaconda-03.html"/>
      <url>tensorflow-windows-install-anaconda-03.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="下载-Anaconda"><a href="#下载-Anaconda" class="headerlink" title="下载 Anaconda"></a>下载 Anaconda</h3><p>首先打开<a href="https://www.anaconda.com/products/individual#Downloads">Anaconda官网</a>找到网页底部，由于最新的Anaconda支持Python3.8版本，而TesnorFlow最高支持到Python3.7，我特意查了一下Python3.8发布的时间点，所以我们需要点击页面的<code>achrive</code>去找历史版本下载。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_19_conda_0.png" alt="2020_12_19_conda_0"><br>点击后进入到Anaconda的历史版本页面，我们直接搜索2020-10-15，找到<code>Anaconda2-2019.10-Windows-x86_64.exe</code>进行下载即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_19_conda_1.png" alt="2020_12_19_conda_1"></p><h3 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h3><p>下载完成后，我们直接双击安装文件开始安装即可，中间过程一路点击<code>Next</code><br>即可。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_19_conda_2.png" alt="2020_12_19_conda_2"></p><h3 id="设置国内镜像源"><a href="#设置国内镜像源" class="headerlink" title="设置国内镜像源"></a>设置国内镜像源</h3><p>由于网络问题，我这里需要添加国内的清华镜像源，这样会方便我们更快速的下载资源。  </p><p>安装完成后，我们点击<code>Windows</code>按钮，会看到有一个有<code>Anaconda3(64-bit)</code>的文件夹，这就是我们安装好<code>Anaconda</code>，然后我们点击<code>Anaconda Powershell Prompt</code>命令行工具。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_19_conda_3.png" alt="2020_12_19_conda_3"></p><p>进入到命令行工具之后，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"><span class="comment"># 设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>就可以了。<br>更多的<code>conda</code>使用方法，可以查看我的<a href="http://fulade.me/tensorflow-mac-install-anaconda-01.html#conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">上一篇博客的后半部分</a></p><p>可以使用命令<code>conda config --show</code>，在<code>channels</code>字段这里显示已经添加的源</p><h3 id="开始安装TensorFlow"><a href="#开始安装TensorFlow" class="headerlink" title="开始安装TensorFlow"></a>开始安装TensorFlow</h3><p>我们只需要在上一步中打开的命令行工具中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow</span><br></pre></td></tr></table></figure><p>就可以了。<br>由于我们已经配置了国内的镜像源，很快就可以安装完成。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>安装完成后，我们接着在打开的命令行工具中输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.__version__</span><br></pre></td></tr></table></figure><p>看到有输出<code>2.1.0</code>就说明我们的安装是正确的。<br><strong>注意</strong>由于TensorFlow也在不停的升级中，这里输出的不一定非要是<code>2.1.0</code>输出<code>2.x</code>就是争取的。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_19_conda_5.png" alt="2020_12_19_conda_5"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> conda </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-2】Flutter手把手教程UI控件——【多图预警】按钮RaisedButton、FlatButton、OutlineButton、IconButton</title>
      <link href="flutter-ui-button-widget-2-2.html"/>
      <url>flutter-ui-button-widget-2-2.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>Material 风格中常用的按钮有三种<code>RaiseButton</code>、<code>FlatButton</code>、<code>OutlineButton</code>。<br>这三种按钮都是继承了<code>MaterialButton</code>，而<code>MaterialButton</code>又继承自<code>StatelessWidget</code>。</p><p>RaiseButton：<strong>带有阴影效果的按钮，默认带有灰色背景，点击下去会有点击效果和阴影。</strong><br>FlatButton: <strong>扁平风格按钮，点击下去会有背景颜色。</strong><br>OutlineButton: <strong>带有边框的按钮，且边框会在点击时改变颜色。</strong></p><h3 id="1-RaisedButton"><a href="#1-RaisedButton" class="headerlink" title="1. RaisedButton"></a>1. RaisedButton</h3><p>我们先来看<code>RaisedButton</code>的构造方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RaisedButton(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">/// <span class="markdown">点击后的回调方法</span></span></span><br><span class="line">  <span class="meta">@required</span> VoidCallback onPressed,</span><br><span class="line">  <span class="comment">/// <span class="markdown">长按后的回调方法</span></span></span><br><span class="line">  VoidCallback onLongPress,</span><br><span class="line">  <span class="comment">/// <span class="markdown">高亮时候的回调方法</span></span></span><br><span class="line">  ValueChanged&lt;<span class="built_in">bool</span>&gt; onHighlightChanged,</span><br><span class="line">  <span class="comment">/// <span class="markdown">鼠标指针的光标进入或悬停在此按钮(这个用于Web端或PC端)</span></span></span><br><span class="line">  MouseCursor mouseCursor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">文本的主题，这个跟MaterialApp的属性theme有关</span></span></span><br><span class="line">  ButtonTextTheme textTheme,</span><br><span class="line">  <span class="comment">/// <span class="markdown">文本颜色</span></span></span><br><span class="line">  Color textColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">不可点击时的文本颜色</span></span></span><br><span class="line">  Color disabledTextColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">背景颜色</span></span></span><br><span class="line">  Color color,</span><br><span class="line">  <span class="comment">/// <span class="markdown">可点击时的背景颜色</span></span></span><br><span class="line">  Color disabledColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">获取焦点时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">  Color focusColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">指鼠标悬停时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">  Color hoverColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">高亮时的颜色</span></span></span><br><span class="line">  Color highlightColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">水波纹颜色，按下松开会有水波纹效果</span></span></span><br><span class="line">  Color splashColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">按钮主题颜色，默认浅色</span></span></span><br><span class="line">  Brightness colorBrightness,</span><br><span class="line">  <span class="comment">/// <span class="markdown">默认时的 阴影大小</span></span></span><br><span class="line">  <span class="built_in">double</span> elevation,</span><br><span class="line">  <span class="comment">/// <span class="markdown">选中时的 阴影大小</span></span></span><br><span class="line">  <span class="built_in">double</span> focusElevation,</span><br><span class="line">  <span class="comment">/// <span class="markdown">指鼠标悬停时的阴影大小</span></span></span><br><span class="line">  <span class="built_in">double</span> hoverElevation,</span><br><span class="line">  <span class="comment">/// <span class="markdown">高亮时的阴影大小</span></span></span><br><span class="line">  <span class="built_in">double</span> highlightElevation,</span><br><span class="line">  <span class="comment">/// <span class="markdown">不可选中时的阴影大小</span></span></span><br><span class="line">  <span class="built_in">double</span> disabledElevation,</span><br><span class="line">  <span class="comment">/// <span class="markdown">内边距 跟布局有关</span></span></span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  VisualDensity visualDensity,</span><br><span class="line">  <span class="comment">/// <span class="markdown">设置按钮的形状</span></span></span><br><span class="line">  ShapeBorder shape,</span><br><span class="line">  <span class="comment">/// <span class="markdown">切边的样式</span></span></span><br><span class="line">  Clip clipBehavior = Clip.none,</span><br><span class="line">  FocusNode focusNode,</span><br><span class="line">  <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span><br><span class="line">  MaterialTapTargetSize materialTapTargetSize,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画的时间</span></span></span><br><span class="line">  <span class="built_in">Duration</span> animationDuration,</span><br><span class="line">  <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">  Widget child,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p><strong>1.1 一个最简单的RaisedButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;RaisedButton&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br><span class="line">````</span><br><span class="line">效果: </span><br><span class="line">![<span class="number">2020</span>_12_17_rased_button_tap](https:<span class="comment">//cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_tap.gif)</span></span><br><span class="line"></span><br><span class="line">**<span class="number">1.2</span> 不可点击状态**</span><br><span class="line">``` dart</span><br><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;不设置onPressed&quot;</span>),</span><br><span class="line">    disabledColor: Colors.blue,</span><br><span class="line">    disabledTextColor: Colors.red,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果不设置<code>onPressed</code>参数，默认是不可点击的，当然我们依然可以设置不可点击时候的文字颜色和背景颜色。需要注意<code>onPressed</code>是<code>@required</code>参数，不建议不传此参数。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_no_onpressed.png" alt="2020_12_17_rased_button_no_onpressed"><br><strong>1.3 文本颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;textColor红色&quot;</span>),</span><br><span class="line">    textColor: Colors.red,</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>textColor</code>可以设置文字的颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_text_color.png" alt="2020_12_17_rased_button_text_color"></p><p><strong>1.4 设置形状</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    child: Text(<span class="string">&quot;椭圆形&quot;</span>),</span><br><span class="line">    shape: StadiumBorder(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过<code>shape</code>参数可以设置按钮的形状，常见的形状有<code>RoundedRectangleBorder</code>矩形、<code>CircleBorder</code>圆形、<code>StadiumBorder</code>椭圆形、<code>BeveledRectangleBorder</code>八边形。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_shape.png" alt="2020_12_17_rased_button_shape"></p><p><strong>1.5 背景颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;背景颜色&quot;</span>),</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过传入<code>color</code>可以设置按钮的背景颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_back_color.png" alt="2020_12_17_rased_button_back_color"></p><p><strong>1.6 高亮颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    child: Text(<span class="string">&quot;高亮红色&quot;</span>),</span><br><span class="line">    highlightColor: Colors.red,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>传入<code>highlightColor</code>参数来设置选中时候的颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_height_color.gif" alt="2020_12_17_rased_button_height_color"></p><p><strong>1.7 水波纹红色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    child: Text(<span class="string">&quot;水波纹红色&quot;</span>),</span><br><span class="line">    splashColor: Colors.red,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>splashColor</code>可以帮助我们设置点击后的水波纹颜色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_splash_color.gif" alt="2020_12_17_rased_button_splash_color"><br><strong>1.8 高亮回调</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;高亮变化回调&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    onHighlightChanged: (value) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;高亮切换&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>onHighlightChanged</code>可以接收一个回调方法，当按钮被按下并高亮的时候会回调该方法。<br><strong>1.9 长按回调</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;长按回调&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    onLongPress: () &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;长按回调&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>onLongPress</code>可以接收一个长按回调方法，当按钮被长按的时候会回调该方法。</p><p><strong>1.10 设置阴影的大小</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&quot;阴影设置20&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    elevation: <span class="number">20.0</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>elevation</code>参数可以设置阴影的大小，默认的阴影比较小，可以通过此参数设置更大的阴影大小。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_rased_button_elevation.png" alt="2020_12_17_rased_button_elevation"></p><p>想体验以上代码运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>flat_button_page.dart</code>，可以下载下来运行并体验。</p><h3 id="2-FlatButton"><a href="#2-FlatButton" class="headerlink" title="2. FlatButton"></a>2. FlatButton</h3><p><code>FlatButton</code>的构造函数参数跟<code>RaisedButton</code>参数基本一致，设置方式也是一样的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FlatButton(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">/// <span class="markdown">点击后的回调</span></span></span><br><span class="line">  <span class="meta">@required</span> VoidCallback onPressed,</span><br><span class="line">  <span class="comment">/// <span class="markdown">长按后的回调</span></span></span><br><span class="line">  VoidCallback onLongPress,</span><br><span class="line">  <span class="comment">/// <span class="markdown">点击 高亮后的回调</span></span></span><br><span class="line">  ValueChanged&lt;<span class="built_in">bool</span>&gt; onHighlightChanged,</span><br><span class="line">  <span class="comment">/// <span class="markdown">鼠标指针的光标进入或悬停在此按钮(这个用于Web端或PC端)</span></span></span><br><span class="line">  MouseCursor mouseCursor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">文本的主题，这个跟MaterialApp的属性theme有关</span></span></span><br><span class="line">  ButtonTextTheme textTheme,</span><br><span class="line">  <span class="comment">/// <span class="markdown">文字颜色</span></span></span><br><span class="line">  Color textColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">不可点击时的文本颜色</span></span></span><br><span class="line">  Color disabledTextColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">背景颜色</span></span></span><br><span class="line">  Color color,</span><br><span class="line">  <span class="comment">/// <span class="markdown">不可点击时的背景颜色</span></span></span><br><span class="line">  Color disabledColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">获取焦点时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">  Color focusColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">指鼠标悬停时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">  Color hoverColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">高亮时的颜色</span></span></span><br><span class="line">  Color highlightColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">水波纹颜色，按下松开会有水波纹效果</span></span></span><br><span class="line">  Color splashColor,</span><br><span class="line">  <span class="comment">/// <span class="markdown">按钮主题颜色，默认浅色</span></span></span><br><span class="line">  Brightness colorBrightness,</span><br><span class="line">  <span class="comment">/// <span class="markdown">内边距 跟布局有关</span></span></span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  VisualDensity visualDensity,</span><br><span class="line">  <span class="comment">/// <span class="markdown">按钮的形状</span></span></span><br><span class="line">  ShapeBorder shape,</span><br><span class="line">  <span class="comment">/// <span class="markdown">切边的样式</span></span></span><br><span class="line">  Clip clipBehavior = Clip.none,</span><br><span class="line">  FocusNode focusNode,</span><br><span class="line">  <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span><br><span class="line">  MaterialTapTargetSize materialTapTargetSize,</span><br><span class="line">  <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">  <span class="meta">@required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2.1 一个最简单的FlatButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    child: Text(<span class="string">&quot;FlatButton&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_flat_button_normal.gif" alt="2020_12_17_flat_button_normal"><br>我们可以看到相对比于<code>RaisedButton</code>，<code>FlatButton</code>默认扁平化风格的。</p><p><strong>2.2 设置形状</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    onPressed: () &#123;&#125;,   </span><br><span class="line">    child: Text(<span class="string">&quot;椭圆形&quot;</span>),</span><br><span class="line">    shape: StadiumBorder(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过传入<code>shape</code>参数可设置<code>FlatButton</code>的形状。需要注意的是：设置好的形状，只有当点击下去的时候才可以看到效果。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_flat_button_shape.gif" alt="2020_12_17_flat_button_shape"><br>其他的 <strong>不可点击状态、文本颜色、背景颜色、高亮颜色、水波纹红色、高亮回调、长按回调</strong>等状态的设置代码跟<code>RaisedButton</code>的设置方式一样。    </p><p>想体验<code>FlatButton</code>的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>flat_button_page.dart</code>，可以下载下来运行并体验。</p><h3 id="3-OutlineButton"><a href="#3-OutlineButton" class="headerlink" title="3. OutlineButton"></a>3. OutlineButton</h3><p>我们来看<code>OutlineButton</code>的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OutlineButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">/// <span class="markdown">点击后的回调</span></span></span><br><span class="line">    <span class="meta">@required</span> VoidCallback onPressed,</span><br><span class="line">    <span class="comment">/// <span class="markdown">长按后的回调</span></span></span><br><span class="line">    VoidCallback onLongPress,</span><br><span class="line">    <span class="comment">/// <span class="markdown">鼠标指针的光标进入或悬停在此按钮(这个用于Web端或PC端)</span></span></span><br><span class="line">    MouseCursor mouseCursor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">文本的主题，这个跟MaterialApp的属性theme有关</span></span></span><br><span class="line">    ButtonTextTheme textTheme,</span><br><span class="line">    <span class="comment">/// <span class="markdown">文字颜色</span></span></span><br><span class="line">    Color textColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">不可点击时的文本颜色</span></span></span><br><span class="line">    Color disabledTextColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">背景颜色</span></span></span><br><span class="line">    Color color,</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取焦点时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">    Color focusColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">指鼠标悬停时的颜色(用于Web端或PC端)</span></span></span><br><span class="line">    Color hoverColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">高亮时的颜色</span></span></span><br><span class="line">    Color highlightColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">水波纹颜色，按下松开会有水波纹效果</span></span></span><br><span class="line">    Color splashColor,</span><br><span class="line">     <span class="comment">/// <span class="markdown">高亮时的阴影大小</span></span></span><br><span class="line">    <span class="built_in">double</span> highlightElevation,</span><br><span class="line">    <span class="comment">/// <span class="markdown">边框的延时</span></span></span><br><span class="line">    <span class="keyword">this</span>.borderSide,</span><br><span class="line">    <span class="comment">/// <span class="markdown">不可用时 边框的颜色</span></span></span><br><span class="line">    <span class="keyword">this</span>.disabledBorderColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">选中时边框的样色</span></span></span><br><span class="line">    <span class="keyword">this</span>.highlightedBorderColor,</span><br><span class="line">    <span class="comment">/// <span class="markdown">内边距 跟布局有关</span></span></span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    VisualDensity visualDensity,</span><br><span class="line">    <span class="comment">/// <span class="markdown">按钮的形状</span></span></span><br><span class="line">    ShapeBorder shape,</span><br><span class="line">    <span class="comment">/// <span class="markdown">切边的样式</span></span></span><br><span class="line">    Clip clipBehavior = Clip.none,</span><br><span class="line">    FocusNode focusNode,</span><br><span class="line">    <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">/// <span class="markdown">子控件</span></span></span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><strong>3.1 简单的 OutlineButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OutlineButton(</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    child: Text(<span class="string">&quot;OutlineButton&quot;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>它的边框默认是灰色的，点击选中的时候会变为蓝色。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_outline_button_normal.gif" alt="2020_12_17_outline_button_normal"><br><strong>3.2 Border的样式</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutlineButton(</span><br><span class="line">    child: Text(<span class="string">&quot;Border颜色&quot;</span>),</span><br><span class="line">    borderSide: BorderSide(color: Colors.red, width: <span class="number">2</span>),</span><br><span class="line">    highlightColor: Colors.yellow,</span><br><span class="line">    highlightedBorderColor: Colors.green,</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>borderSide</code>可以接收一个<code>BorderSide</code>的对象，该对象可以设置颜色和宽度，同样我们也可以通过设置<code>highlightColor</code>和<code>highlightedBorderColor</code>来设置选中的背景颜色和选中的边框颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_17_outline_button_border.gif" alt="2020_12_17_outline_button_border"></p><p>其他的 <strong>不可点击状态、文本颜色、高亮颜色、水波纹红色、高亮回调、长按回调</strong>等状态的设置代码跟<code>RaisedButton</code>的设置方式一样。    </p><p>想体验<code>FlatButton</code>的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>outline_button_page.dart</code>，可以下载下来运行并体验。</p><h3 id="4-IconButton"><a href="#4-IconButton" class="headerlink" title="4. IconButton"></a>4. IconButton</h3><p><strong>4.1 简单的IconButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    icon: Icon(Icons.local_taxi),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>IconButton</code>可以接收一个<code>Icon</code>类的的参数，Flutter自带了很多<code>Icon</code>详情可见<a href="https://material.io/resources/icons/?style=baseline">这里</a><br><strong>4.1 带有选中提示的IconButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    icon: Icon(Icons.local_cafe),</span><br><span class="line">    tooltip: <span class="string">&quot;Cafe Button&quot;</span>,</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过设置<code>tooltip</code>属性，可以设置按钮按下的弹出提示文字。我们这里设置了<code>Cafe Button</code>的文字。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_18_icon_button_tool.gif" alt="2020_12_18_icon_button_tool"></p><p><strong>4.2 自定义图片的IconButton</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    icon: Image.asset(<span class="string">&quot;images/flutter_icon_100.png&quot;</span>),</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们同样可以提供一个<code>Image</code>类型的<code>Icon</code>，这样就满足我们设置不同的图片按钮。<br>如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_18_icon_button_image.png" alt="2020_12_18_icon_button_image"></p><p>想体验<code>IconButton</code>的运行效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>icon_button_page.dart</code>，可以下载下来运行并体验。</p><p>以上就是Material风格的按钮以及详解，如果你想了解Cupertino风格按钮，可以点击<a href="https://api.flutter.dev/flutter/cupertino/cupertino-library.html">这里</a>。<br>我们日常开发中大多数情况下都会使用Material风格的样式。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 按钮 </tag>
            
            <tag> Flutter RaiseButton </tag>
            
            <tag> FlatButton </tag>
            
            <tag> OutlineButton </tag>
            
            <tag> IconButton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 2-1】Flutter手把手教程UI布局和Widget——文本和样式 Text Widget</title>
      <link href="flutter-ui-text-widget-2-1.html"/>
      <url>flutter-ui-text-widget-2-1.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>我们先来看Text的构造函数都有哪些参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Text( </span><br><span class="line">    <span class="keyword">this</span>.data, &#123; </span><br><span class="line">    <span class="comment">//data 就是我们需要展示的文字 是字符串类型，这个是必传字段，其他的都是可选</span></span><br><span class="line">    Key key,    </span><br><span class="line">    <span class="comment">//widget的标识</span></span><br><span class="line">    <span class="keyword">this</span>.style, </span><br><span class="line">    <span class="comment">//文本样式，类型是TextStyle</span></span><br><span class="line">    <span class="keyword">this</span>.strutStyle, </span><br><span class="line">    <span class="comment">//用来设置最小行高的参数</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign, </span><br><span class="line">    <span class="comment">//文本的对齐方式，类型是TextAlign</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection, </span><br><span class="line">    <span class="comment">// 文字方向，类型是TextDirection</span></span><br><span class="line">    <span class="keyword">this</span>.locale, </span><br><span class="line">    <span class="comment">//选择用户语言和格式的标识符，类型是Locale，主要用于国际化</span></span><br><span class="line">    <span class="keyword">this</span>.softWrap, </span><br><span class="line">    <span class="comment">//bool 类型 ，false标识文本只有一行，水平方向无限</span></span><br><span class="line">    <span class="keyword">this</span>.overflow, </span><br><span class="line">    <span class="comment">//超出显示区域后的展示方式，类型是TextOverflow</span></span><br><span class="line">    <span class="keyword">this</span>.textScaleFactor,</span><br><span class="line">    <span class="comment">//double类型 表示文本相对于当前字体的缩放系数，默认为1.0</span></span><br><span class="line">    <span class="keyword">this</span>.maxLines,</span><br><span class="line">    <span class="comment">// int 类型，显示的最大行数</span></span><br><span class="line">    <span class="keyword">this</span>.semanticsLabel, </span><br><span class="line">    <span class="comment">//String 类型，给文本加上一个语义标签</span></span><br><span class="line">    <span class="keyword">this</span>.textWidthBasis,</span><br><span class="line">    <span class="comment">//一行或多行文本宽度的不同方式，类型是TextWidthBasis</span></span><br><span class="line">  &#125;) </span><br></pre></td></tr></table></figure><p><code>Text</code>我们重点介绍下面几个参数:<code>data</code>、<code>style</code>、<code>textAlign</code>、<code>maxLines</code>、<code>overflow</code>。<br><strong>1. 最简单的示例</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">&quot;Fulade&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2. 放大和缩小</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">&quot;文字放大1.5倍&quot;</span>,textScaleFactor: <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p><code>textScaleFactor</code>是缩放参数，默认是<code>1.0</code>，设置小于1的参数是缩小，设置大约1的参数是放大。<br><strong>3. 居中、居左和居右</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;居右显示&quot;</span> * <span class="number">10</span>,</span><br><span class="line">  textAlign: TextAlign.right,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>textAlign</code>是位置参数，常见的枚举值有<code>TextAlign.right</code>、<code>TextAlign.left</code>和<code>TextAlign.center</code>。<br><strong>4. 单行显示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;最多一行显示超过部分显示...&quot;</span> * <span class="number">10</span>,</span><br><span class="line">  maxLines: <span class="number">1</span>,</span><br><span class="line">  overflow: TextOverflow.ellipsis,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>maxLines</code>表示文字需要几行来显示，如果超过了要显示的行数，文字会被切断。使用<code>overflow</code>来设置切断文字的样式，<code>overflow</code>有以下几个枚举值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextOverflow &#123;</span><br><span class="line">  clip,      <span class="comment">//直接裁剪。</span></span><br><span class="line">  fade,      <span class="comment">// 渐变淡出</span></span><br><span class="line">  ellipsis,  <span class="comment">// 以省略号的方式</span></span><br><span class="line">  visible,   <span class="comment">// 依然显示，此时将会溢出父组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不设置<code>maxLines</code>，文字默认会换行，以全部都展示的方式来显示。  </p><p>以上四种样式效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_16_text.png" alt="2020_11_16_text"></p><h3 id="TextStyle"><a href="#TextStyle" class="headerlink" title="TextStyle"></a>TextStyle</h3><p>如果想要设置更复杂的文字样式，我们需要传入<code>Text</code>的<code>style</code>参数，<code>style</code>参数接收一个 <code>TextStyle</code>的对象，<code>TextStyle</code>可以帮助我们做很多事情。</p><p><strong>5. 粗体</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;粗体&quot;</span>,</span><br><span class="line">  style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>fontWeight</code>用来设置粗体。<code>FontWeight.bold</code>默认是<code>w700</code>。<br><strong>6. 颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;红色&quot;</span>,</span><br><span class="line">  style: TextStyle(color: Colors.red),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>color</code>参数用来设置颜色。<br><strong>7. 字号</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;字号20&quot;</span>,</span><br><span class="line">  style: TextStyle(fontSize: <span class="number">20</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>fontSize</code>用来设置字号。<br><strong>8. 斜体</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;斜体&quot;</span>,</span><br><span class="line">  style: TextStyle(fontStyle: FontStyle.italic),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>fontStyle</code>可以用来设置斜体，<code>FontStyle.italic</code>表示斜体，默认是<code>FontStyle.normal</code>。</p><p><strong>9. 背景颜色</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;背景颜色红色&quot;</span>,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">      background: Paint()..color = Colors.red,</span><br><span class="line">      color: Colors.blue),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>background</code>用来设置背景颜色，它接收一个<code>Paint</code>对象作为参数，<code>Paint</code>对象可以设置<code>color</code>属性。<br><strong>10. 删除线</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;删除线&quot;</span>,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">      decoration: TextDecoration.lineThrough,</span><br><span class="line">      decorationColor: Colors.red),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>decorationColor</code>参数是设置删除线的颜色，<code>TextDecoration.lineThrough</code>是删除线的样式。<br><strong>11. 下划线</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">&quot;下划线&quot;</span>,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    decoration: TextDecoration.underline,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下划线的设置跟<strong>删除线</strong>的设置基本一样，只是枚举值不同，下划线使用的是<code>TextDecoration.underline</code>枚举。</p><p>以上几种样式展示效果如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_16_text_span.png" alt="2020_11_16_text_span"></p><h3 id="RichText-和-TextSpan"><a href="#RichText-和-TextSpan" class="headerlink" title="RichText 和 TextSpan"></a>RichText 和 TextSpan</h3><p>Flutter支持在一行文字里面显示不同颜色的文字，这里我们需要用到<code>RichText</code>和 <code>TextSpan</code>。</p><p><strong>12. 多彩文字</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RichText(</span><br><span class="line">  text: TextSpan(</span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    text: <span class="string">&quot;多彩文字：&quot;</span>,</span><br><span class="line">    style: TextStyle(color: Colors.black),</span><br><span class="line">    children: &lt;TextSpan&gt;[</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">&quot;红色、&quot;</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">&quot;蓝色、&quot;</span>, style: TextStyle(color: Colors.blue)),</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">&quot;绿色 &quot;</span>, style: TextStyle(color: Colors.green)),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>TextSpan</code>的参数<code>children</code>，可以是一个<code>TextSpan</code>对象的数组，这就比较有意思。每一个<code>TextSpan</code>都可以设置颜色和字体，这样我们就可以组合成一个多彩的文字结构。同样<code>RichText</code>也有<code>textAlign</code>参数，它是整个文字的位置参数。</p><p><strong>13. 给文字添加点击事件</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RichText(</span><br><span class="line">  text: TextSpan(</span><br><span class="line">    text: <span class="string">&quot;添加了手势的文字: &quot;</span>,</span><br><span class="line">    style: TextStyle(color: Colors.black),</span><br><span class="line">    children: &lt;TextSpan&gt;[</span><br><span class="line">      TextSpan(</span><br><span class="line">        text: <span class="string">&quot;点击会输出Log&quot;</span>,</span><br><span class="line">        style: TextStyle(color: Colors.blue),</span><br><span class="line">        recognizer: TapGestureRecognizer()</span><br><span class="line">          ..onTap = () &#123;</span><br><span class="line">            tapCount++;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;taped taped &quot;</span> + tapCount.toString());</span><br><span class="line">          &#125;,</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>TextSpan</code>可以给相应的文字添加手势，这样就可以满足我们点击某个文字触发事件的需求，这在日常开发中非常有效。我们就不需要搞一些”文字+按钮+文字+…”的这种组合了。<br><code>TextSpan</code>的参数<code>recognizer</code>可以接收一个手势参数，当然这里的手势不仅有<strong>点击手势</strong>，还有滑动手势等等(具体的手势功能我们后面会讲到)。多种手势更是满足了我们更多的交互需求。  </p><p>多彩文字和点击时间如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_16_text_tap.png" alt="2020_11_16_text_tap"></p><p>想体验点击事件效果，可以到<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目里<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>text_page.dart</code>运行查看。</p><h3 id="DefaultTextStyle"><a href="#DefaultTextStyle" class="headerlink" title="DefaultTextStyle"></a>DefaultTextStyle</h3><p><code>DefaultTextStyle</code>是一个特殊的TextStyle。在<code>DefaultTextStyle</code>下面的所有子元素的文本样式都继承了<code>DefaultTextStyle</code>设置的文本样式。因此，我们只需要定义一个<code>DefaultTextStyle</code>，其下的所有文本样式都是该定义好的<code>DefaultTextStyle</code>的样式。这样就极大的方便我们来写一些统一的样式，而不需要每次都要写繁琐的设置样式的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DefaultTextStyle(</span><br><span class="line">  <span class="comment">// 设置文本默认样式</span></span><br><span class="line">  style: TextStyle(</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    fontSize: <span class="number">20.0</span>,</span><br><span class="line">  ),</span><br><span class="line">  textAlign: TextAlign.start,</span><br><span class="line">  child: Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Text(<span class="string">&quot;DefaultTextStyle &quot;</span>),</span><br><span class="line">      Text(<span class="string">&quot;DefaultTextStyle&quot;</span>),</span><br><span class="line">      Text(</span><br><span class="line">        <span class="string">&quot;改变了的DefaultTextStyle&quot;</span>,</span><br><span class="line">        style: TextStyle(</span><br><span class="line">            inherit: <span class="keyword">false</span>, <span class="comment">// 设置不再继承默认样式</span></span><br><span class="line">            color: Colors.blue),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>首先我们声明了一个<code>DefaultTextStyle</code>的样式，它是红色的，字号是20。<br>注意:这里有一个<code>Text</code>的<code>inherit</code>设置了<code>false</code>，只有设置了<code>false</code>才允许不继承<code>DefaultTextStyle</code>的样式。而其他的两个<code>Text</code>对象，默认使用了<code>DefaultTextStyle</code>的样式。  </p><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_16_default_text.png" alt="2020_11_16_default_text"></p><hr><p>以上所有的代码都在<a href="https://github.com/Johnson8888/learn_flutter">我的Github仓库</a>项目里<code>flutter_app</code>-&gt;<code>lib</code>-&gt;<code>routes</code>-&gt;<code>text_page.dart</code>里面，你可以下载下来运行并体验。</p><p>运行效果图如下：  </p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_16_screen.png" alt="2020_11_16_screen"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter 文本 </tag>
            
            <tag> Flutter 文本样式 </tag>
            
            <tag> Flutter Text </tag>
            
            <tag> Flutter Text Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细数最流行的人工智能、深度学习常用框架，不止有TensorFlow，Java也可以进行人工智能开发</title>
      <link href="tensorflow-list-ai-lib-02.html"/>
      <url>tensorflow-list-ai-lib-02.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。那让我们来看一下都有哪些人工智能开发的框框。</p><h3 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_14_list_ai_theano.jpg" alt="2020_12_14_list_ai_theano"><br>早在2007加拿大的蒙特利尔大学就开始了<a href="https://github.com/Theano/Theano">Theano</a>的开发，它最初是为了用于学术研究而设计的。虽然出身于学术界，但是在过去很长一段时间里面，Theano都是深度学习开发与研究的行业标准。<br>Theano其实是一个比较底层的库，它比较适合数值计算和优化。支持自动函数梯度计算，支持Python接口，并且集成了Numpy。它并不只是专门用来做深度学习的，可以说Theano是Python的一个数值计算库。它也有缺点，就是不支持GPU和水平扩展。<br>由于TensorFlow在谷歌的支持下强势崛起，Theano可以说是日渐式微，这里面的有个标志性的事件就是Theano创始人之一Ian Goodfellow，他放弃了Theano转去Google开发TensorFlow。</p><h3 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_caffe.png" alt="2020_11_14_list_ai_caffe"><br><a href="https://github.com/facebookarchive/caffe2">Caffe</a>是由就读于加州大学伯克利分校的中国籍博士生<strong>贾扬清</strong>在2013年创建的，是一个老牌框架。<br>贾扬清本科和硕士都是清华毕业，他对两个深度学习的框架都有贡献，一个是TensorFlow，他以前是在Google工作。在2016年贾扬清加入到Facebook，开始了Caffe框架的开发。<br>Caffe的全称是”Convolution Architecture For Feature Extraction”，意思是能用于特征提取的卷积架构，它的设计初衷其实是为了针对计算机视觉。缺点是灵活性不足的问题，为了做模型调整会用到C++和CUDA。<br>在2017年4月，Facebook发布了Caffe2，这标志着Caffe有了一个很大的发展。我们可以把它看作是对Caffe更细粒度的重构，在实用的基础上增加了扩展性和灵活性。随着时间的发展，Facebook最后把Caffe2合并到了PyTorch上面了。</p><h3 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_14_list_ai_pytorch.png" alt="2020_12_14_list_ai_pytorch"><br>说<a href="https://pytorch.org/">PyTorch</a>之前，我们得先说一说Torch。Torch是一个非主流的深度学习框架，它是基于Lua语言的。而现在主流的深度学习框架使用的语言基本都是Python，所以用Torch就会显得很非主流。但是Facebook的人工智能研究所使用的就是Torch，Torch非常适用于卷积神经网络，同时它的灵活度也很高。<br>有一个特点就是：它是命令式的，支持动态模型。大多数的机器学习框架都是支持静态图模型，也就是说在进行调试时，我们需要先把模型定义好，然后再进行运行和计算。而Torch它的灵活度更高，它可以在运行的过程中更改图模型，这就叫做支持动态的图模型。在2017年初，Facebook在Torch的基础上，发布了一个全新的机器学习框架叫PyTorch。PyTorch可以说是Torch的Python版，增加了很多特性。<br>2018年4月Facebook宣布将Caffe2并入PyTorch，所以说Caffe2就以PyTorch的形式存在。</p><h3 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet"></a>MXNet</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_mxnet.png" alt="2020_11_14_list_ai_mxnet"><br><a href="https://mxnet.apache.org/versions/1.7.0/">MXNet</a>是亚马逊它支持的深度学习框架。MXNet尝试把两种模式无缝的结合起来，一种是在命令式编程上提供张量运算，一种是在声明式的编程支持符号表达式。这样用户就可以自由的混合来实现他们自己的想法。也就是说，它结合了静态定义计算图和动态定义计算图的优势。另外MXNet支持的语言种类也比较多，除了常见的想Python还有C++，关键的他对R语音也支持的很好，对Go也有支持。但是它的学习曲线会比较高。</p><h3 id="CNTK"><a href="#CNTK" class="headerlink" title="CNTK"></a>CNTK</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_cntk.png" alt="2020_11_14_list_ai_cntk"><br><a href="https://github.com/microsoft/CNTK">CNTK</a>又名：Microsoft Cognitive Toolkit。在2016年的微软宣布在给github上开源CNTK(computational Network ToolKit)。CNTK对语音和图像支持特别好，语音识别和图像识别也比较快。它还有着更为强大的可扩展性，开发者可以使用多台计算机去实现GPU的扩展，从而能够更加灵活地应对大规模的实验。当然它也支持支持C#语言。</p><h3 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_keras.png" alt="2020_11_14_list_ai_keras"><br><a href="https://keras.io/">Keras</a>是一个高级封装的库，同样也非常的受欢迎。它可以跟Theano、CNTK、TensorFlow结合起来工作。它相当于架设在这些框架上的更高一层，因为更高一层，这使得它的使用非常的简单。Keras强调的就是极简主义，你只需要几行代码就能构建一个神经网络。同样它号称为支持快速实验而生，能够把你的想法的迅速转换成为结果。它的语法的也比较明细，文档的也提供的非常好。当然了，它也是支持Python的。</p><h3 id="DL4J"><a href="#DL4J" class="headerlink" title="DL4J"></a>DL4J</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_dl4j.png" alt="2020_11_14_list_ai_dl4j"><br><a href="https://github.com/deeplearning4j">DJF4</a>是一个基于JVM，聚焦行业应用，而且提供商业支持的分布式的深度学习框架。它的宗旨就是：在合理的时间里去解决各类涉及大量数据的问题。<br>从它的名字上不难看出，它其实是 Deep Learning For Java 的缩写，它对Java的支持是它最大的特点。它对使用Java作为开发语言的开发者来说非常友好，它可以与Hadoop和Spark很好的结合起来，也可以使用任意数量的GPU或者CPU运行。</p><h3 id="Chainer"><a href="#Chainer" class="headerlink" title="Chainer"></a>Chainer</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_chainer.png" alt="2020_11_14_list_ai_chainer"><br><a href="https://chainer.org/">Chainer</a>的是一个专门为高效研究和开发深度学习算法而设计的开源框架，它也是基于Python的深度学习框架。Chanier在”实时”使构件计算图，”边运行边定义”的方法使得构建深度学习网络的变得很灵活。也就是说，Chanier是支持动态图定义的。那这种方法可以让用户在每次迭代的时候可以根据条件去更改计算图，也很容易使用标准的调试器和分析器来调试和重构。</p><h3 id="PaddlePaddle"><a href="#PaddlePaddle" class="headerlink" title="PaddlePaddle"></a>PaddlePaddle</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_paddle.jpg" alt="2020_11_14_list_ai_paddle"><br><a href="https://www.paddlepaddle.org.cn/">PaddlePaddle</a>是百度旗下的深度学习开源平台，它支持并行分布式深度学习。在2016年9月1日百度世界大会上，当时百度的首席科学家吴恩达宣布：百度的深度学习平台将对外开放，命名为PaddlePaddle。吴恩达认为PaddlePaddle比一个PaddleP要更容易让人记住，事实上也是，PaddlePaddle 比 Paddle更容易上口。百度的资深科学家，PaddlePaddle的研发负责人徐伟介绍：在PaddlePaddle的帮助下，深度学习模型的设计如同编写伪代码一样容易，工程师只需要关注模型的高层结构，而无需担心任何琐碎的底层问题。</p><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_14_list_ai_tensorflow.jpg" alt="2020_11_14_list_ai_tensorflow"><br><a href="https://github.com/tensorflow/tensorflow">TensorFlow</a>A machine learning platform for everyone to solve real problems。对每个人来解决现实问题的机器学习平台，这也是TensorFlow存在的宗旨。它不但在上层支持神经网络，它还很全面的支持别的机器学习的算法，像K-Means，决策树，向量积等等。它对语言的支持也很多，Python、C++、Java。在硬件层面，它也可以利用CPU，GPU进行计算。<br>另外的谷歌还出了专门的处理器，叫TPU，也就是Tensor处理器，另外它也支持在移动端使用。还提供了一个叫<a href="https://www.tensorflow.org/tensorboard?hl=zh-cn">TensorBoard</a>的可视化工具。这个工具非常强大，它可以基于运行的一些日志和文件，可视化得把模型训练和结果展现出来。<br>TensorFlow提供了不同层次的接口，从低层到高层。越低的层次越灵活，越容易去控制，越高层次是越容易使用。<br>TensorFlow支持的语言也非常多：Go、Python、C++、Java、Swift、R语音、C#、js等。<br>还有运行在Web端的TensorFlow.js，我们可以使用Javascript在网页端进行机器学习的训练和使用。在移动端同样提供支持的是TensorFlowLite，我们可以把在服务器端训练好的模型下发到移动端(Android、iOS、树莓派等)，在移动端通过TensorFlowLite来使用。</p><p>综上所述，如果要进行人工智能开发，你会选择哪个框架入手呢？ </p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> conda </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda和conda命令的安装和使用</title>
      <link href="tensorflow-mac-install-anaconda-01.html"/>
      <url>tensorflow-mac-install-anaconda-01.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h4><p><a href="https://www.anaconda.com/products/enterprise">Anaconda</a>是一个开源的工具，目前拥有超过六百万的用户。Anaconda致力于提供最便捷的方式来使用Python进行数据科学计算和机器学习。目前，Anaconda拥有超过250+的数据科学工具包，conda工具包可用于Windows，MacOS和Linux三种平台的虚拟环境管理系统。Anaconda支持当前比较流行的一些人工智能的库，比如Sklearn，TensorFlow，Scipy。</p><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p>直接去到Anaconda的官网，找到<a href="https://www.anaconda.com/products/individual">下载地址</a>，点击<code>Download</code>按钮，然后找到页面最下方的下载部分。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_11_anaconda_download.png" alt="2020_12_11_anaconda_download"><br>我们可以看到Anaconda提供了两种安装方式，一种是带有图形界面的安装方式<code>Graphical Installer</code>，另一种是 以命令行的方式<code>Command Line Installer</code>安装。<br>我们选择<code>64-Bit Graphical Installer</code>使用图形界面的方式来安装，点击下载。</p><h4 id="安装步骤-基于MacOS"><a href="#安装步骤-基于MacOS" class="headerlink" title="安装步骤(基于MacOS)"></a>安装步骤(基于MacOS)</h4><ol><li><p>双击下载好的安装文件(下载好的安装文件如下图所示)，开始安装。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_11_anaconda_pkg.png" alt="2020_12_11_anaconda_pkg"></p></li><li><p>一路点击<code>继续</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_11_anaconda_install_step_1.png" alt="2020_12_11_anaconda_install_step_1"><br>这里也选择<code>继续</code>即可。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_11_anaconda_install_step_2.png" alt="2020_12_11_anaconda_install_step_2"></p></li><li><p>在Mac里面的<code>启动台</code>找到刚安装好好的<code>Anaconda</code>，名字叫：<code>Anaconda-Navigator</code>，点击启动，启动后的样子如下：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_12_11_anaconda_launch.png" alt="2020_12_11_anaconda_launch"></p></li></ol><h4 id="配置命令行工具"><a href="#配置命令行工具" class="headerlink" title="配置命令行工具"></a>配置命令行工具</h4><p>此时，我们已经安装好的<code>Anaconda</code>的客户端，但是很多情况我们都需要在命令使用<code>conda</code>命令，这个时候在命令行工具输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -version</span><br></pre></td></tr></table></figure><p>显示如下(我电脑配置了zsh，所以会显示zsh):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: command <span class="keyword">not</span> found: conda</span><br></pre></td></tr></table></figure><p>显然我们还不能使用<code>conda</code>命令。</p><h5 id="1-zsh配置流程"><a href="#1-zsh配置流程" class="headerlink" title="1. zsh配置流程"></a>1. zsh配置流程</h5><p>找到<code>.zshrc</code>文件，一般在<code>/Users/&#123;username&#125;/.zshrc</code>，其中<code>&#123;username&#125;</code>是你当前Mac的用户名字哦。<br>用记事本打开<code>.zshrc</code>文件(你也可以使用<code>vim</code>命令来编辑)，在该文件的最后一行添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;opt&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>然后保存<br>命令行工具进入到<code>/Users/&#123;username&#125;</code>目录下，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure><p>接着执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>就可以看到输出的版本号了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda 4.9.2</span><br></pre></td></tr></table></figure><h5 id="2-bash-profile-配置"><a href="#2-bash-profile-配置" class="headerlink" title="2. bash_profile 配置"></a>2. bash_profile 配置</h5><p>找到<code>.bash_profile</code>文件，一般在<code>/Users/&#123;username&#125;/.bash_profile</code>，其中<code>&#123;username&#125;</code>是你当前Mac的用户名字哦。<br>用记事本打开<code>.bash_profile</code>文件(你也可以使用<code>vim</code>命令来编辑)，在该文件的最后一行添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;opt&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>然后保存<br>命令行工具进入到<code>/Users/&#123;username&#125;</code>目录下，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure><p>接着执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>就可以看到输出的版本号了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda 4.9.2</span><br></pre></td></tr></table></figure><h4 id="添加常用源"><a href="#添加常用源" class="headerlink" title="添加常用源"></a>添加常用源</h4><p>由于网络问题，有些时候直接同国外下载库会比较慢，我们可以给<code>conda</code>配置国内的镜像源，添加国内的镜像源命令如下：</p><ol><li>清华源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"><span class="comment"># 设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li>添加中科院源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"><span class="comment"># 设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><p>查看是否添加成功可是用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure><p>在 <code>channels</code>这个字段这里显示已经添加的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">  - defaults</span><br></pre></td></tr></table></figure><h4 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h4><p><strong>升级</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda update conda  <span class="comment"># 更新 conda</span></span><br><span class="line">conda update anaconda <span class="comment"># 更新 anaconda</span></span><br><span class="line">conda update anaconda-navigator    <span class="comment">#update最新版本的anaconda-navigator  </span></span><br><span class="line">conda update python <span class="comment"># 更新 python</span></span><br></pre></td></tr></table></figure><p><strong>管理环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda env list  <span class="comment">#显示所有的虚拟环境</span></span><br><span class="line">conda create --name fulade python=3.7 <span class="comment"># 创建一个名为 fulade 环境，指定Python版本是3.7</span></span><br><span class="line">activate fulade  <span class="comment"># 激活名为 fulade 的环境 (Windows 使用)</span></span><br><span class="line"><span class="built_in">source</span> activate fulade  <span class="comment"># 激活名为 fulade 的环境 (Linux &amp; Mac使用用)</span></span><br><span class="line">deactivate fulade   <span class="comment">#关闭名为 fulade的环境( Windows使用)</span></span><br><span class="line"><span class="built_in">source</span> deactivate fulade  <span class="comment"># 关闭名为 fulade的环境(Linux &amp; Mac使用）</span></span><br><span class="line">conda remove --name fulade --all <span class="comment"># 删除一个名为 fulade 的环境</span></span><br><span class="line">conda create --name newname --<span class="built_in">clone</span> oldname <span class="comment"># 克隆oldname环境为newname环境</span></span><br></pre></td></tr></table></figure><p><strong>package管理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda list  <span class="comment">#查看当前环境下已安装的package</span></span><br><span class="line">conda search numpy <span class="comment"># 查找名为 numpy 的信息 package 的信息</span></span><br><span class="line">conda install numpy  <span class="comment"># 安装名字为 fulade 的package 安装命令使用-n指定环境 --channel指定源地址</span></span><br><span class="line">conda install -n fulade numpy  <span class="comment"># 在fulade的环境中 安装名字为 fulade 的package</span></span><br><span class="line">conda install --channel https://conda.anaconda.org/anaconda tensorflow=1.8.0  <span class="comment"># 使用地址 https://conda.anaconda.org/anaconda 来安装tensorflow</span></span><br><span class="line">conda update numpy   <span class="comment">#更新numpy package</span></span><br><span class="line">conda uninstall numpy   <span class="comment">#卸载numpy package</span></span><br></pre></td></tr></table></figure><p><strong>清理conda</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda clean -p      //删除没有用的包</span><br><span class="line">conda clean -t      //删除tar包</span><br><span class="line">conda clean -y --all //删除所有的安装包及cache</span><br></pre></td></tr></table></figure><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> conda </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-11】Python手把手教程之——字典的用法和对字典的管理</title>
      <link href="python-dict-1-11.html"/>
      <url>python-dict-1-11.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值 <code>key=&gt;value</code>对用冒号<code>:</code>分割，每个键值对之间用逗号<code>,</code>分割，整个字典包括在花括号<code>&#123;&#125;</code>中。</p><h4 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h4><p>在Python中，字典是一系列<strong>键—值</strong>对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。<br>来看一个游戏，其中包含一些外星人，这些外星人的颜色和点数各不相同，如下所示: </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键—值对之间用逗号分隔。在字典中，你想存储多少个键—值对都可以。<br>最简单的字典只有一个键—值对，如下述修改后的字典<code>alien_0</code>所示: </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>这个字典只存储了一项有关<code>alien_0</code>的信息，具体地说是这个外星人的颜色。在这个字典中，字符串<code>color</code>是一个键，与之相关联的值为<code>green</code>。</p><h4 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h4><p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键，如下所示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line">print(alien_0[<span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这将返回字典<code>alien_0</code>中与键<code>color</code>相关联的值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">green</span><br></pre></td></tr></table></figure><p>字典中可包含任意数量的键—值对。例如，下面是最初的字典alien_0，其中包含两个键— 值对:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>现在，你可以访问外星人<code>alien_0</code>的颜色和点数。如果玩家射杀了这个外星人，你就可以使用下面的代码来确定玩家应获得多少个点:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">new_points = alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;You just earned &quot;</span> + <span class="built_in">str</span>(new_points) + <span class="string">&quot; points!&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码首先定义了一个字典，然后从这个字典中获取与键<code>points</code>相关联的值，并将这个值存储在变量<code>new_points</code>中。接下来，将这个整数转换为字符串，并打印一条消息，指出玩家获得了多少个点:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You just earned <span class="number">5</span> points!</span><br></pre></td></tr></table></figure><h4 id="添加键—值对"><a href="#添加键—值对" class="headerlink" title="添加键—值对"></a>添加键—值对</h4><p>字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。<br>下面在字典<code>alien_0</code>中添加两项信息:</p><p>外星人的x坐标和y坐标，让我们能够在屏幕的特定位置显示该外星人。我们将这个外星人放在屏幕左边缘，且离屏幕上边缘25像素的地方。由于屏幕坐标系的原点通常为左上角，因此要将该外星人放在屏幕左边缘，可将x坐标设置为0，要将该外星人放在离屏幕顶部25像素的地方，可将y坐标设置为25，如下所示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien_0)</span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span> </span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure><p>我们首先定义了前面一直在使用的字典，然后打印这个字典，以显示其信息快照。我们在这个字典中新增了一个键—值对，其中的键为<code>x_position</code>，而值为0。接着我们重复这样的操作，但使用的键为<code>y_position</code>。打印修改后的字典时，将看到这两个新增的键—值对:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y_position&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;x_position&#x27;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>这个字典的最终版本包含四个键—值对，其中原来的两个指定外星人的颜色和点数，而新增的两个指定位置。注意，键—值对的排列顺序与添加顺序不同。Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。</p><h4 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h4><p>有时候，在空字典中添加键—值对是为了方便，而有时候必须这样做。为此，可先使用一对空的花括号定义一个字典，再分行添加各个键—值对。例如，下例演示了如何以这种方式创建字典<code>alien_0</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;&#125;</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;green&#x27;</span> </span><br><span class="line">alien_0[<span class="string">&#x27;points&#x27;</span>] = <span class="number">5</span></span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure><p>这里首先定义了空字典<code>alien_0</code>，再在其中添加颜色和点数，得到前述示例一直在使用的字典:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>使用字典来存储用户提供的数据或在编写能自动生成大量键—值对的代码时，通常都需要先定义一个空字典。</p><h4 id="修改字典中的值"><a href="#修改字典中的值" class="headerlink" title="修改字典中的值"></a>修改字典中的值</h4><p>要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。<br>例如，假设随着游戏的进行，需要将一个外星人从绿色改为黄色:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line">print(<span class="string">&quot;The alien is &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">print(<span class="string">&quot;The alien is now &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们首先定义了一个表示外星人<code>alien_0</code>的字典，其中只包含这个外星人的颜色。接下来，我们将与键<code>color</code>相关联的值改为<code>yellow</code>。输出表明，这个外星人确实从绿色变成了黄色:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The alien <span class="keyword">is</span> green.</span><br><span class="line">The alien <span class="keyword">is</span> now yellow.</span><br></pre></td></tr></table></figure><p>来看一个更有趣的例子，对一个能够以不同速度移动的外星人的位置进行跟踪。我们将存储该外星人的当前速度，并据此确定该外星人将向右移动多远:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;x_position&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;y_position&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;medium&#x27;</span>&#125; </span><br><span class="line">print(<span class="string">&quot;Original x-position: &quot;</span> + <span class="built_in">str</span>(alien_0[<span class="string">&#x27;x_position&#x27;</span>]))</span><br><span class="line"><span class="comment"># 向右移动外星人</span></span><br><span class="line"><span class="comment"># 据外星人当前速度决定将其移动多远 </span></span><br><span class="line"><span class="keyword">if</span> alien_0[<span class="string">&#x27;speed&#x27;</span>] == <span class="string">&#x27;slow&#x27;</span>:</span><br><span class="line">    x_increment = <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> alien_0[<span class="string">&#x27;speed&#x27;</span>] == <span class="string">&#x27;medium&#x27;</span>:</span><br><span class="line">    x_increment = <span class="number">2</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 这个外星人的速度一定很快 </span></span><br><span class="line">    x_increment = <span class="number">3</span></span><br><span class="line"><span class="comment"># 新位置等于老位置加上增量</span></span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = alien_0[<span class="string">&#x27;x_position&#x27;</span>] + x_increment</span><br><span class="line">print(<span class="string">&quot;New x-position: &quot;</span> + <span class="built_in">str</span>(alien_0[<span class="string">&#x27;x_position&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>我们首先定义了一个外星人，其中包含初始的x坐标和y坐标，还有速度<code>medium</code>。出于简化考虑，我们省略了颜色和点数，但即便包含这些键值对，这个示例的工作原理也不会有任何变化。我们还打印了<code>x_position</code>的初始值，这让用户知道这个外星人向右移动了多远。<br>然后，使用了一个<code>if-elif-else</code>结构来确定外星人应向右移动多远，并将这个值存储在变量<code>x_increment</code>中。如果外星人的速度为<code>slow</code>，它将向右移动一个单位，如果速度为<code>medium</code>，将向右移动两个单位，如果为<code>fast</code>，将向右移动三个单位。确定移动量后，将其与<code>x_position</code>的当前值相加，再将结果关联到字典中的键<code>x_position</code>。<br>由于这是一个速度中等的外星人，因此其位置将向右移动两个单位:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original x-position: <span class="number">0</span></span><br><span class="line">New x-position: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>通过修改外星人字典中的值，可改变外星人的行为。例如，要将这个速度中等的外星人变成速度很快的外星人，可添加如下代码行: </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0[<span class="string">&#x27;speed&#x27;</span>] = fast </span><br></pre></td></tr></table></figure><p>这样，再次运行这些代码时，其中的<code>if-elif-else</code>结构将把一个更大的值赋给变量<br><code>x_increment</code>。</p><h4 id="删除键—值对"><a href="#删除键—值对" class="headerlink" title="删除键—值对"></a>删除键—值对</h4><p>对于字典中不再需要的信息，可使用<code>del</code>语句将相应的键—值对彻底删除。使用<code>del</code>语句时，必须指定字典名和要删除的键。<br>例如，下面的代码从字典<code>alien_0</code>中删除键<code>points</code>及其值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien_0)</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>] </span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure><p>上述代码将键<code>points</code>从字典<code>alien_0</code>中删除，同时删除与这个键相关联的值。输出表明，键<code>points</code>及其值5已从字典中删除，但其他键—值对不受影响:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>一个Python字典可能只包含几个键—值对，也可能包含数百万个键—值对。鉴于字典可能包含大量的数据，Python支持对字典遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的方式，可遍历字典的所有键—值对、键或值。</p><h4 id="遍历所有的键—值对"><a href="#遍历所有的键—值对" class="headerlink" title="遍历所有的键—值对"></a>遍历所有的键—值对</h4><p>探索各种遍历方法前，先来看一个新字典，它用于存储有关网站用户的信息。下面的字典存储一名用户的用户名、名和姓:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: </span><br><span class="line">    <span class="string">&#x27;efermi&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: </span><br><span class="line">    <span class="string">&#x27;enrico&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: </span><br><span class="line">    <span class="string">&#x27;fermi&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用一个for循环来遍历这个字典:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items(): </span><br><span class="line">    print(<span class="string">&quot;\nKey: &quot;</span> + key)</span><br><span class="line">    print(<span class="string">&quot;Value: &quot;</span> + value)</span><br></pre></td></tr></table></figure><p>要实现遍历字典的for循环，可声明两个变量，用于存储键—值对中的键和值。 对于这两个变量，可使用任何名称。下面的代码使用了简单的变量名，这完全可行:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> user_0.items()</span><br></pre></td></tr></table></figure><p>for语句的第二部分包含字典名和方法<code>items()</code>，它返回一个键—值对列表。接下来，for循环依次将每个键—值对存储到指定的两个变量中。我们使用这两个变量来打印每个键及其相关联的值。第一条<code>print</code>语句中的”\n”确保在输出每个键—值对前都插入一个空行:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key: last </span><br><span class="line">Value: fermi</span><br><span class="line"></span><br><span class="line">Key: first </span><br><span class="line">Value: enrico</span><br><span class="line"></span><br><span class="line">Key: username </span><br><span class="line">Value: efermi</span><br></pre></td></tr></table></figure><p>即便遍历字典时，键—值对的返回顺序也与存储顺序不同。Python不关心键—值对的存储顺序，而只跟踪键和值之间的关联关系。</p><h4 id="遍历字典中的所有键"><a href="#遍历字典中的所有键" class="headerlink" title="遍历字典中的所有键"></a>遍历字典中的所有键</h4><p>在不需要使用字典中的值时，方法keys()很有用。下面来遍历字典<code>favorite_languages</code>，并将每个被调查者的名字都打印出来:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">                     <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, </span><br><span class="line">                     <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys(): </span><br><span class="line">    print(name.title())</span><br></pre></td></tr></table></figure><p><code>.keys()</code>方法提取字典<code>favorite_languages</code>中的所有键，并依次将它们存储到变量<code>name</code>中。输出列出了每个被调查者的名字:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jen </span><br><span class="line">Sarah </span><br><span class="line">Phil </span><br><span class="line">Edward</span><br></pre></td></tr></table></figure><p>遍历字典时，会默认遍历所有的键，因此，如果将上述代码中的<code>for name in favorite_ languages.keys():</code>替换为<code>for name in favorite_languages:</code>，输出将不变。如果显式地使用方法<code>keys()</code>可让代码更容易理解，你可以选择这样做，也可省略它。在这种循环中，可使用当前键来访问与之相关联的值。</p><p>下面来打印两条消息，指出两位朋友喜欢的语言。我们像前面一样遍历字典中的名字，但在名字为指定朋友的名字时，打印一条消息，指出其喜欢的语言:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123; <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">                        <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, </span><br><span class="line">                        <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">friends = [<span class="string">&#x27;phil&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line">        print(<span class="string">&quot; Hi &quot;</span> + name.title() + <span class="string">&quot;, I see your favorite language is &quot;</span> + favorite_languages[name].title() + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们创建了一个列表，其中包含我们要通过打印消息，指出其喜欢的语言的朋友。 在循环中，我们打印每个人的名字，并检查当前的名字是否在列表<code>friends中</code>。<br>如果在列表中，就打印一句特殊的问候语，其中包含这位朋友喜欢的语言。为访问喜欢的语言，我们使用了字典名，并将变量<code>name</code>的当前值作为键。每个人的名字都会被打印，但只对朋友打印特殊消息:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line"> Hi Sarah, I see your favorite language <span class="keyword">is</span> C!</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br><span class="line"> Hi Phil, I see your favorite language <span class="keyword">is</span> Python!</span><br></pre></td></tr></table></figure><h4 id="按顺序遍历字典中的所有键"><a href="#按顺序遍历字典中的所有键" class="headerlink" title="按顺序遍历字典中的所有键"></a>按顺序遍历字典中的所有键</h4><p>字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。<br>要以特定的顺序返回元素，一种办法是在<code>for</code>循环中对返回的键进行排序。可使用函数<code>sorted()</code>来获得按特定顺序排列的键列表的副本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123; <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,<span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):</span><br><span class="line">    print(name.title() + <span class="string">&quot;, thank you for taking the poll.&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个示例中，对方法<code>dictionary.keys()</code>的结果调用了函数<code>sorted()</code>。 这让Python列出字典中的所有键，并在遍历前对这个列表进行排序。输出表明，按顺序显示了所有被调查者的名字:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Edward, thank you <span class="keyword">for</span> taking the poll. </span><br><span class="line">Jen, thank you <span class="keyword">for</span> taking the poll. </span><br><span class="line">Phil, thank you <span class="keyword">for</span> taking the poll. </span><br><span class="line">Sarah, thank you <span class="keyword">for</span> taking the poll.</span><br></pre></td></tr></table></figure><h4 id="遍历字典中的所有值"><a href="#遍历字典中的所有值" class="headerlink" title="遍历字典中的所有值"></a>遍历字典中的所有值</h4><p>如果你只想知道字典包含的值，可使用方法<code>values()</code>，它返回一个值列表，而不包含任何键。<br>例如，如果我们想获得一个这样的列表，即其中只包含被调查者选择的各种语言，而不包含被调查者的名字，可以这样做:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123; <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">print(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    print(language.title())</span><br></pre></td></tr></table></figure><p>这条for语句提取字典中的每个值，并将它们依次存储到变量<code>language</code>中。通过打印这些值，就获得了一个列表，其中包含被调查者选择的各种语言:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The following languages have been mentioned: </span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Python</span><br><span class="line">Ruby</span><br></pre></td></tr></table></figure><p>这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，我们可使用集合<code>set</code>。 集合类似于列表，但每个元素都必须是独一无二的:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123; <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, &#125;</span><br><span class="line">print(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()): </span><br><span class="line">        print(language.title())</span><br></pre></td></tr></table></figure><p>通过对包含重复元素的列表调用<code>set()</code>，可以帮我们找出列表中独一无二的元素，并使用这些元素来创建一个集合。我们使用了<code>set()</code>来提取<code>favorite_languages.values()</code>中不同的语言。<br>结果是一个不重复的列表，其中列出了被调查者提及的所有语言:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following languages have been mentioned: </span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为<strong>嵌套</strong>。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典，嵌套是一项强大的功能。</p><h4 id="字典列表"><a href="#字典列表" class="headerlink" title="字典列表"></a>字典列表</h4><p>字典<code>alien_0</code>包含一个外星人的各种信息，但无法存储第二个外星人的信息，更别说屏幕上全部外星人的信息了。如何管理成群结队的外星人呢?一种办法是创建一个外星人列表，其中每个外星人都是一个字典，包含有关该外星人的各种信息。<br>例如，下面的代码创建一个包含三个外 星人的列表:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">alien_1 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">alien_2 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">15</span>&#125;</span><br><span class="line">aliens = [alien_0, alien_1, alien_2]</span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    print(alien)</span><br></pre></td></tr></table></figure><p>我们首先创建了三个字典，其中每个字典都表示一个外星人。我们将这些字典都放到一个名为<code>aliens</code>的列表中。最后，我们遍历这个列表，并将每个外星人都打印出来:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>&#125; </span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure><p>更符合现实的情形是，外星人不止三个，且每个外星人都是使用代码自动生成的。在下面的示例中，我们使用<code>range()</code>生成了30个外星人:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个用于存储外星人的空列表 </span></span><br><span class="line">aliens = []</span><br><span class="line"><span class="comment"># 创建30个绿色的外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    new_alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125; </span><br><span class="line">    aliens.append(new_alien)</span><br><span class="line"><span class="comment"># 显示前五个外星人 </span></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">5</span>]:</span><br><span class="line">    print(alien) </span><br><span class="line">    <span class="comment"># 显示创建了多少个外星人</span></span><br><span class="line">print(<span class="string">&quot;Total number of aliens: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(aliens)))</span><br></pre></td></tr></table></figure><p>在这个示例中，首先创建了一个空列表，用于存储接下来将创建的所有外星人。<code>range()</code>返回一系列数字，其用途是告诉Python我们要重复这个循环多少次。每次执行这个循环时，都创建一个外星人，并将其附加到列表<code>aliens</code>末尾。然后使用一个切片来打印前五个外星人，然后打印列表的长度，以证明确实创建了30个外星人</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">Total number of aliens: <span class="number">30</span></span><br></pre></td></tr></table></figure><p>这些外星人都具有相同的特征，但在Python看来，每个外星人都是独立的，这让我们能够独立地修改每个外星人。<br>在什么情况下需要处理成群结队的外星人呢？想象一下，可能随着游戏的进行，有些外星人会变色且移动速度会加快。必要时，我们可以使用<code>for</code>循环和<code>if</code>语句来修改某些外星人的颜色。<br>例如，要将前三个外星人修改为黄色的、速度为中等且值10个点，可以这样做:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个用于存储外星人的空列表 </span></span><br><span class="line">aliens = []</span><br><span class="line"><span class="comment"># 创建30个绿色的外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,<span class="number">30</span>):</span><br><span class="line">    new_alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125; </span><br><span class="line">    aliens.append(new_alien)</span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">if</span> alien[<span class="string">&#x27;color&#x27;</span>] == <span class="string">&#x27;green&#x27;</span>:</span><br><span class="line">        alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span> </span><br><span class="line">        alien[<span class="string">&#x27;speed&#x27;</span>] = <span class="string">&#x27;medium&#x27;</span> </span><br><span class="line">        alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示前五个外星人</span></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[<span class="number">0</span>:<span class="number">5</span>]:</span><br><span class="line">    print(alien) </span><br></pre></td></tr></table></figure><p>由于我们要修改前三个外星人，需要遍历一个只包含这些外星人的切片。当前，所有外星人都是绿色的，但情况并非总是如此，因此我们编写了一条<code>if</code>语句来确保只修改绿色外星人。如果外星人是绿色的，我们就将其颜色改为<code>yellow</code>，将其速度改为<code>medium</code>，并将其点数改为<code>10</code>， 如下面的输出所示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;medium&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;medium&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;medium&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>你可以进一步扩展这个循环，在其中添加一个<code>elif</code>代码块，将黄色外星人改为移动速度快且值15个点的红色外星人，如下所示(这里只列出了循环，而没有列出整个程序):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">if</span> alien[<span class="string">&#x27;color&#x27;</span>] == <span class="string">&#x27;green&#x27;</span>:</span><br><span class="line">        alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">        alien[<span class="string">&#x27;speed&#x27;</span>] = <span class="string">&#x27;medium&#x27;</span></span><br><span class="line">        alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">elif</span> alien[<span class="string">&#x27;color&#x27;</span>] == <span class="string">&#x27;yellow&#x27;</span>: </span><br><span class="line">        alien[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;red&#x27;</span> </span><br><span class="line">        alien[<span class="string">&#x27;speed&#x27;</span>] = <span class="string">&#x27;fast&#x27;</span> </span><br><span class="line">        alien[<span class="string">&#x27;points&#x27;</span>] = <span class="number">15</span></span><br></pre></td></tr></table></figure><h4 id="在字典中存储列表"><a href="#在字典中存储列表" class="headerlink" title="在字典中存储列表"></a>在字典中存储列表</h4><p>有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢?如果使用列表，只能存储要添加的比萨配料，但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。<br>在下面的示例中，存储了比萨的两方面信息，外皮类型和配料列表。其中的配料列表是一个与键<code>toppings</code>相关联的值。要访问该列表，我们使用字典名和键<code>toppings</code>，就像访问字典中的其他值一样。这将返回一个配料列表，而不是单个值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储所点比萨的信息 </span></span><br><span class="line">pizza = &#123;</span><br><span class="line"><span class="string">&#x27;crust&#x27;</span>: <span class="string">&#x27;thick&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;toppings&#x27;</span>: [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]&#125;</span><br><span class="line"><span class="comment"># 概述所点的比萨</span></span><br><span class="line">print(<span class="string">&quot;You ordered a &quot;</span> + pizza[<span class="string">&#x27;crust&#x27;</span>] + <span class="string">&quot;-crust pizza &quot;</span> +</span><br><span class="line"><span class="string">&quot;with the following toppings:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]: </span><br><span class="line">    print(<span class="string">&quot;\t&quot;</span> + topping)</span><br></pre></td></tr></table></figure><p>我们首先创建了一个字典，其中存储了有关顾客所点比萨的信息。在这个字典中，一个键是<code>crust</code>，与之相关联的值是字符串<code>thick</code>，下一个键是<code>toppings</code>，与之相关联的值是一个列表，其中存储了顾客要求添加的所有配料。制作前我们概述了顾客所点的比萨。为打印配料，我们编写了一个for循环。为访问配料列表，我们使用了键<code>toppings</code>，这样Python将从字典中提取配料列表。<br>  下面的输出概述了要制作的比萨:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You ordered a thick-crust pizza <span class="keyword">with</span> the following  toppings: </span><br><span class="line">    mushrooms</span><br><span class="line">    extra cheese</span><br></pre></td></tr></table></figure><p>每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。在前面有关喜欢的编程语言的示例中，如果将每个人的回答都存储在一个列表中，被调查者就可选择多种喜欢的语言。在这种情况下，当我们遍历字典时，与每个被调查者相关联的都是一个语言列表，而不是一种语言，因此，在遍历该字典的<code>for</code>循环中，我们需要再使用一个<code>for</code>循环来遍历与被调查者相关联的语言列表:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>], </span><br><span class="line">                    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>], &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(<span class="string">&quot;\n&quot;</span> + name.title() + <span class="string">&quot;&#x27;s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages: </span><br><span class="line">        print(<span class="string">&quot;\t&quot;</span> + language.title())</span><br></pre></td></tr></table></figure><p>现在与每个名字相关联的值都是一个列表。请注意，有些人喜欢的语言只有一种，而有些人有多种。遍历字典时，我们使用了变量<code>languages</code>来依次存储字典中的每个值，因为我们知道这些值都是列表。在遍历字典的主循环中，我们又使用了一个<code>for</code>循环来遍历每个人喜欢的语言列表。现在，每个人想列出多少种喜欢的语言都可以:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Jen<span class="string">&#x27;s favorite languages are:</span></span><br><span class="line"><span class="string">    Python</span></span><br><span class="line"><span class="string">    Ruby</span></span><br><span class="line"><span class="string">Sarah&#x27;</span>s favorite languages are:</span><br><span class="line">    C</span><br><span class="line">Phil<span class="string">&#x27;s favorite languages are:</span></span><br><span class="line"><span class="string">    Python</span></span><br><span class="line"><span class="string">    Haskell</span></span><br><span class="line"><span class="string">Edward&#x27;</span>s favorite languages are:</span><br><span class="line">    Ruby</span><br><span class="line">    Go</span><br></pre></td></tr></table></figure><h4 id="在字典中存储字典"><a href="#在字典中存储字典" class="headerlink" title="在字典中存储字典"></a>在字典中存储字典</h4><p>可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。例如，如果有多个网站用户，每个都有独特的用户名，可在字典中将用户名作为键，然后将每位用户的信息存储在一个字典中，并将该字典作为与用户名相关联的值。<br>在下面的程序中，对于每位用户，我们都存储了其三项信息:名、姓和居住地，为访问这些信息，我们遍历所有的用户名，并访问与每个用户名相关联的信息字典:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;<span class="string">&#x27;aeinstein&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;albert&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;einstein&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;mcurie&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>&#125;&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    print(<span class="string">&quot;\nUsername: &quot;</span> + username)</span><br><span class="line">    full_name = user_info[<span class="string">&#x27;first&#x27;</span>] + <span class="string">&quot; &quot;</span> + user_info[<span class="string">&#x27;last&#x27;</span>]</span><br><span class="line">    location = user_info[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line">    print(<span class="string">&quot;\tFull name: &quot;</span> + full_name.title()) </span><br><span class="line">    print(<span class="string">&quot;\tLocation: &quot;</span> + location.title())</span><br></pre></td></tr></table></figure><p>我们首先定义了一个名为<code>users</code>的字典，其中包含两个键:用户名<code>aeinstein</code>和<code>mcurie</code>，与每个键相关联的值都是一个字典，其中包含用户的名、姓和居住地。我们先遍历字典<code>users</code>，让Python依次将每个键存储在变量<code>username</code>中，并依次将与当前键相关联的字典存储在变量<code>user_info</code>中。<br>在主循环内部，我们将用户名打印出来。接着我们开始访问内部的字典。变量<code>user_info</code>包含用户信息字典，而该字典包含三个键:<code>first</code>、<code>last</code>和<code>location</code>，对于每位用户，我们都使用这些键来生成整洁的姓名和居住地，然后打印有关用户的简要信息:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Username: aeinstein</span><br><span class="line">Full name: Albert Einstein Location: Princeton</span><br><span class="line">Username: mcurie</span><br><span class="line">Full name: Marie Curie Location: Paris</span><br></pre></td></tr></table></figure><blockquote><p>小作业<br>11-1 请想出5个人的名字，并将这些名字用作字典中的键，想出每个人喜欢的一个数字，并将这些数字作为值存储在字典中。打印每个人的名字和喜欢的数字。<br>11-2 创建一个字典，在其中存储三条大河流及其流经的国家。其中一个键—值对可能是’nile’:’egypt’。使用循环为每条河流打印一条消息，如”The Nile runs through Egypt.”。使用循环将该字典中每条河流的名字都打印出来。使用循环将该字典包含的每个国家的名字都打印出来。<br>11-3 创建多个字典，对于每个字典，都使用一个宠物的名称来给它命名;在每个字典中，包含宠物的类型及其主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，并将宠物的所有信息都打印出来。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a>在文件夹(11-1——11-3)</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python dict </tag>
            
            <tag> Python 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-10】Python手把手教程之——一篇讲透if语句以及if语句的特殊用法</title>
      <link href="python-if-control-1-10.html"/>
      <url>python-if-control-1-10.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="if-简单示例"><a href="#if-简单示例" class="headerlink" title="if 简单示例"></a>if 简单示例</h3><p>假设你有一个汽车列表，并想将其中每辆汽车的名称打印出来。对于大多数汽车，都应以首字母大写的方式打印其名称，但对于汽车名’bmw’，应以全大写的方式打印。<br>下面的代码遍历一个列表，并以首字母大写的方式打印其中的汽车名，但对于汽车名’bmw’，以全大写的方式打印:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car_list = [<span class="string">&#x27;bmw&#x27;</span>,<span class="string">&#x27;audi&#x27;</span>,<span class="string">&#x27;toyota&#x27;</span>,<span class="string">&#x27;honda&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> car_list:</span><br><span class="line">    <span class="keyword">if</span> car == <span class="string">&#x27;bmw&#x27;</span>:</span><br><span class="line">        print(car.upper())</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        print(car.title())</span><br></pre></td></tr></table></figure><p>这个实例中，如果<code>car</code>的名字等于<code>bmw</code>就会调用<code>upper()</code>方法以大写的方式来输出结果，如果不等于<code>bmw</code>就以首字母大写的方式输出。<br>输出结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BMW</span><br><span class="line">Audi</span><br><span class="line">Toyota</span><br><span class="line">Honda</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>每条if语句的核心都是一个值为<code>True</code>或<code>False</code>的表达式，这种表达式被称为<strong>条件语句</strong>。Python根据条件判断的值为<code>True</code>还是<code>False</code>来决定是否执行if语句中的代码。如果条件判断的值为<code>True</code>， Python就执行紧跟在if语句后面的代码;如果为<code>False</code>，Python就不会执行这些代码。</p><h4 id="检查是否相等"><a href="#检查是否相等" class="headerlink" title="检查是否相等"></a>检查是否相等</h4><p>大多数条件判断都将一个变量的当前值同特定值进行比较。最简单的条件判断检查变量的值是否与某个值相等:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;bmw&#x27;</span></span><br><span class="line">print(car == <span class="string">&#x27;bmw&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>我们首先使用一个等号将car的值设置为<code>bmw</code>。接下来，使用两个等号<code>==</code>检查<code>car</code>的值是否为<code>bmw</code>。这个相等运算符在它两边的值相等时返回<code>True</code>，否则返回<code>False</code>。在这个示例中，两边的值相等，因此返回<code>True</code>。<br>如果变量<code>car</code>的值不是<code>bmw</code>，上述判断将返回<code>False</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;audi&#x27;</span></span><br><span class="line">print(car == <span class="string">&#x27;bmw&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>一个第一个等号将将变量car的值设置为<code>audi</code>。两个等号是发问”变量car的值是<code>bmw</code>吗?”。大多数编程语言使用等号的方式都与这里示例的相同。</p><h4 id="使用if时不考虑大小写"><a href="#使用if时不考虑大小写" class="headerlink" title="使用if时不考虑大小写"></a>使用if时不考虑大小写</h4><p>在Python中检查是否相等时区分大小写，例如，两个大小写不同的值会被视为不相等:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;Audi&#x27;</span> </span><br><span class="line">print(car == <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>如果大小写很重要，这种行为有其优点。但如果大小写无关紧要，而只想检查变量的值，可将变量的值转换为小写，再进行比较:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;Audi&#x27;</span></span><br><span class="line">print(car.lower() == <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>无论值<code>Audi</code>的大小写如何，上述判断都将返回<code>True</code>，因为该判断不区分大小写。函数<code>lower()</code>不会修改存储在变量<code>car</code>中的值，因此进行这样的比较时不会影响原来的变量:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;Audi&#x27;</span></span><br><span class="line">print(car.lower() == <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="literal">True</span> </span><br><span class="line">print(car)</span><br><span class="line"><span class="string">&#x27;Audi&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="检查不相等"><a href="#检查不相等" class="headerlink" title="检查不相等"></a>检查不相等</h4><p>要判断两个值是否不等，可结合使用叹号和等号<code>!=</code>，其中的叹号表示<strong>不</strong>，在很多编程语言中都如此。<br>下面再使用一条if语句来演示如何使用不等运算符。我们将把<code>苹果</code>(Apple)存储在一个变量中，而顾客想要购买的是<code>橘子</code>(Orange)，输出顾客不需要<code>苹果</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&#x27;Apple&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (fruit != <span class="string">&#x27;Orange&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;do not need &#x27;</span> + fruit)</span><br></pre></td></tr></table></figure><p>将<code>fruit</code>的值与<code>Orange</code>进行比较，如果它们不相等，Python 将返回<code>True</code>，进而执行紧跟在if语句后面的代码;如果这两个值相等，Python将返回<code>False</code>，因此 不执行紧跟在if语句后面的代码。<br>由于<code>fruit</code>的值不是<code>Orange</code>，因此执行了<code>print</code>语句。<br>我们编写的大多数条件表达式都检查两个值是否相等，但有时候检查两个值是否不等的效率更高。</p><h4 id="比较数字"><a href="#比较数字" class="headerlink" title="比较数字"></a>比较数字</h4><p>检查数值非常简单，例如，下面的代码检查一个人是否是18:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">print(age == <span class="number">18</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>你还可以检查两个数字是否不等，例如，下面的代码在提供的答案不正确时打印一条消息:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">answer = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> answer != <span class="number">42</span>:</span><br><span class="line">    print(<span class="string">&quot;That is not the correct answer. Please try again!&quot;</span>)</span><br></pre></td></tr></table></figure><p>条件语句中可包含各种数学比较，如<strong>小于</strong>、<strong>小于等于</strong>、<strong>大于</strong>、<strong>大于等于</strong>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line">print(age &lt; <span class="number">21</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line">print(age &lt;= <span class="number">21</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line">print(age &gt; <span class="number">21</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">print(age &gt;= <span class="number">21</span>) </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在if语句中可使用各种数学比较，使用起来也很简单。</p><h4 id="检查多个条件"><a href="#检查多个条件" class="headerlink" title="检查多个条件"></a>检查多个条件</h4><p>你可能想同时检查多个条件，例如，我们需要在两个条件都为<code>True</code>时才执行相应的操作，而有时候你只要求一个条件为True时就执行相应的操作。在这些情况下，关键字<code>and</code>和<code>or</code>可以帮助我们省去很多事情。<br><strong>1. 使用and检查多个条件</strong><br>要检查是否两个条件都为<code>True</code>，可使用关键字<code>and</code>将两个条件判断合而为一；如果每个判断都通过了，整个表达式就为<code>True</code>；如果至少有一个判断没有通过，整个表达式就为<code>False</code>。例如，要检查是否两个人都不小于21岁，可使用下面的判断:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age_0 = <span class="number">22</span> </span><br><span class="line">age_1 = <span class="number">18</span></span><br><span class="line">print(age_0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">age_1 = <span class="number">22</span></span><br><span class="line">print(age_0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>我们定义了两个用于存储年龄的变量<code>age_0</code>和<code>age_1</code>。首先我们检查这两个变量是否都大于或等于21，左边的判断通过了，但右边的判断没有通过，因此整个条件表达式的结果为<code>False</code>。<br>接下来我们将<code>age_1</code>改为22，这样<code>age_1</code>的值大于21，因此两个判断都通过了，导致整个条件表达式的结果为<code>True</code>。<br>为改善可读性，可将每个判断都分别放在一对括号内，但并非必须这样做。如果你使用括号，判断将类似于下面这样:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(age_0 &gt;= <span class="number">21</span>) <span class="keyword">and</span> (age_1 &gt;= <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p><strong>2.使用or检查多个条件</strong><br>关键字<code>or</code>也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个判断。仅当两个判断都没有通过时，使用<code>or</code>的表达式才为<code>False</code>。<br>下面再次检查两个人的年龄，但检查的条件是至少有一个人的年龄不小于21岁:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age_0 = <span class="number">22</span> </span><br><span class="line">age_1 = <span class="number">18</span></span><br><span class="line">print(age_0 &gt;= <span class="number">21</span> <span class="keyword">or</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">age_0 = <span class="number">18</span></span><br><span class="line">print(age_0 &gt;= <span class="number">21</span> <span class="keyword">or</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>同样，我们首先定义了两个用于存储年龄的变量。对<code>age_0</code>的判断通过了， 因此整个表达式的结果为<code>True</code>。接下来，我们将<code>age_0</code>更改为18，在接下来的判断中，两个判断都没有通过，因此整个表达式的结果为<code>False</code>。</p><h4 id="检查特定值是否包含在列表中"><a href="#检查特定值是否包含在列表中" class="headerlink" title="检查特定值是否包含在列表中"></a>检查特定值是否包含在列表中</h4><p>有时候，执行操作前必须检查列表是否包含特定的值。要判断特定的值是否已包含在列表中，可使用关键字<code>in</code>。你可能为水果店编写代码，首先创建一个列表，其中包含用户要买的水果，然后检查特定的水果是否包含在该列表中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;apple&#x27;</span> <span class="keyword">in</span> fruits)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">print(<span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> fruits)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>关键字<code>in</code>可以帮助我们检查<code>fruits</code>是否包含<code>apple</code>和 <code>orange</code>。这种判断很有用，它可以帮助我们能够在创建一个列表后，轻松地检查其中是否包含特定的值。</p><h4 id="检查特定值是否不包含在列表中"><a href="#检查特定值是否不包含在列表中" class="headerlink" title="检查特定值是否不包含在列表中"></a>检查特定值是否不包含在列表中</h4><p>还有些时候，确定特定的值未包含在列表中很重要。在这种情况下，可使用关键字<code>not in</code>。 例如，如果有一个列表，其中包含被禁止在论坛上发表评论的用户，就可在允许用户提交评论前检查他是否被禁言:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banned_users = [<span class="string">&#x27;andrew&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>, <span class="string">&#x27;david&#x27;</span>] </span><br><span class="line">user = <span class="string">&#x27;marie&#x27;</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> banned_users:</span><br><span class="line">    print(user.title() + <span class="string">&quot;, you can post a response if you wish.&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果<code>user</code>的值未包含在列表<code>banned_users</code>中，<code>Python</code>将返回<code>True</code>，进而执行缩进的代码行。<br>用户<code>marie</code>未包含在列表<code>banned_users</code>中，因此她将看到一条邀请她发表评论的消息:<br><code>Marie, you can post a response if you wish.</code></p><h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><p>与条件表达式一样，布尔表达式的结果要么为<code>True</code>，要么为<code>False</code>。<br>布尔值通常用于记录条件，如游戏是否正在运行，或用户是否可以编辑网站的特定内容:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game_active = <span class="literal">True</span> </span><br><span class="line">can_edit = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>布尔值判断是一种高效的判断方式。</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>理解条件语句后，就可以开始编写if语句了。前面讨论条件语句时，列举了多个if语句示例，下面更深入地讨论这个主题。</p><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h4><p>经常需要在条件语句通过了时执行一个操作，并在没有通过时执行另一个操作。在这种情况 下，可使用Python提供的<code>if-else</code>语句。<code>if-else</code>语句块类似于简单的if语句，但其中的else语句让你能够指定条件不满足时要执行的操作。<br>下面的代码在一个人够投票的年龄时显示与前面相同的消息，同时在这个人不够投票的年龄时也显示一条消息:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&quot;You are old enough to vote!&quot;</span>)  </span><br><span class="line">    print(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;Sorry, you are too young to vote.&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;Please register to vote as soon as you turn 18!&quot;</span>)</span><br></pre></td></tr></table></figure><p>条件语句通过了，就执行第一个缩进的print语句块。如果判断结果为<code>False</code>，就执行后面的<code>else</code>代码块。这次<code>age</code>小于<code>18</code>，条件判断未通过，因此执行<code>else</code>代码块中的代码。<br>上述代码之所以可行，是因为只存在两种情形:要么够投票的年龄，要么不够。<code>if-else</code>结构非常适合用于要让<code>Python</code>执行两种操作之一的情形。在这种简单的<code>if-else</code>结构中，总是会执行两个操作中的一个。</p><h4 id="if-elif-else-结构"><a href="#if-elif-else-结构" class="headerlink" title="if-elif-else 结构"></a>if-elif-else 结构</h4><p>经常需要检查超过两个的情形，为此可使用Python提供的<code>if-elif-else</code>结构。Python只执行<code>if-elif-else</code>结构中的一个代码块，它依次检查每个条件判断，直到遇到通过了的条件判断。判断通过后，Python将执行紧跟在它后面的代码，并跳过余下的判断。<br>在现实世界中，很多情况下需要考虑的情形都超过两个。例如，来看一个根据年龄段收费的 游乐场:</p><ol><li>4岁以下免费;</li><li>4-18岁收费5元;</li><li>18岁(含z以上收费10元。  </li></ol><p>如果只使用一条if语句，如何确定门票价格呢?下面的代码确定一个人所属的年龄段，并打印一条包含门票价格的消息:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    print(<span class="string">&quot;Your admission cost is ¥0.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&quot;Your admission cost is ¥5.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;Your admission cost is ¥10.&quot;</span>)</span><br></pre></td></tr></table></figure><p>首先if判断一个人是否不满4岁，如果是这样，就打印一条合适的消息，并跳过余下的判断。<code>elif</code>代码行其实是另一个if判断，它仅在前面的判断未通过时才会运行。在这里，我们知道这个人不小于4岁，因为第一个判断未通过。如果这个人未满18岁，Python将打印相应的消息，并跳过<code>else</code>代码块。如果if判断和elif判断都未通过，Python将运行最后一个<code>else</code>代码块中的代码。<br>在这个示例中，第一个<code>if</code>的结果为False，因此不执行其代码块。然而，第二个判断的结果为<code>True</code>(12小于18)，因此将执行其代码块。输出为一个句子，向用户指出了门票价格:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your admission cost <span class="keyword">is</span> ¥<span class="number">5.</span></span><br></pre></td></tr></table></figure><p>只要年龄超过17岁，前两个判断就都不能通过。在这种情况下，将执行<code>else</code>代码块，指出门票价格为10元。为让代码更简洁，可不在<code>if-elif-else</code>代码块中打印门票价格，而只在其中设置门票价格， 并在它后面添加一条简单的print语句:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line">print(<span class="string">&quot;Your admission cost is ¥&quot;</span> + <span class="built_in">str</span>(price) + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="使用多个elif代码块"><a href="#使用多个elif代码块" class="headerlink" title="使用多个elif代码块"></a>使用多个elif代码块</h4><p>可根据需要使用任意数量的<code>elif</code>代码块，例如，假设前述游乐场要给老年人打折，可再添加 一个条件判断，判断顾客是否符合打折条件。下面假设对于65岁(含)以上的老人，可以半价(即5元)购买门票:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line">print(<span class="string">&quot;Your admission cost is ¥&quot;</span> + <span class="built_in">str</span>(price) + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>这些代码大都未变。第二个<code>elif</code>代码块通过检查确定年龄不到65岁后，才将门票价格设置为全票价格——10元。</p><h4 id="省略else代码块"><a href="#省略else代码块" class="headerlink" title="省略else代码块"></a>省略else代码块</h4><p>Python并不要求<code>if-elif</code>结构后面必须有else代码块。在有些情况下，<code>else</code>代码块很有用,而在其他一些情况下，使用一条<code>elif</code>语句来处理特定的情形更清晰:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>: </span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>: </span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>: </span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">65</span>: </span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line">print(<span class="string">&quot;Your admission cost is ¥&quot;</span> + <span class="built_in">str</span>(price) + <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure><p>第三个<code>elif</code>代码块在顾客的年龄超过65(含)时，将价格设置为5元，这比使用<code>else</code>代码块更清晰些。经过这样的修改后，每个代码块都仅在通过了相应的判断时才会执行。 </p><p><code>else</code>是一条包罗万象的语句，只要不满足任何<code>if</code>或<code>elif</code>中的条件判断，其中的代码就会执行，这可能会引入无效甚至恶意的数据。如果知道最终要的条件，应考虑使用一个<code>elif</code>代码块来代替<code>else</code>代码块。这样，你就可以肯定，仅当满足相应的条件时，你的代码才会执行。</p><h4 id="判断多个条件"><a href="#判断多个条件" class="headerlink" title="判断多个条件"></a>判断多个条件</h4><p><code>if-elif-else</code>结构功能强大，但仅适合用于只有一个条件满足的情况，遇到通过了的判断后，Python就跳过余下的判断。这种行为很好，效率很高。<br>然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含<code>elif</code>和<code>else</code>代码块的简单if语句。在可能有多个条件为<code>True</code>，且你需要在每个条件为<code>True</code>时都采取相应措施时，适合使用这种方法。<br>下面再来看前面的水果店示例。如果顾客要了两种水果，就需要确保在货架上包含这些水果:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requested_fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;apple&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding apple.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;pear&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding pear.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;banana&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding banana.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\nFinished adding your fruits!&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们首先创建了一个列表，其中包含顾客要的水果。第一个if语句检查顾客是否要了<code>apple</code>，如果要了，就打印一条确认消息。第二个if检查水果<code>pear</code>的代码也是一个简单的if语句，而不是<code>elif</code>或<code>else</code>语句，因此不管前一个判断是否通过，都将进行这个判断。第三个if的代码检查顾客是否要了<code>banana</code>;不管前两个判断的结果如何，都会执行这些代码。每当这个程序运行时，都会进行这三个独立的判断。 3<br>在这个示例中，会检查每个条件，因此将在列表中添加<code>pear</code>和<code>banana</code>输出结果:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Adding pear.</span><br><span class="line">Adding banana.</span><br><span class="line"></span><br><span class="line">Finished adding your fruits!</span><br></pre></td></tr></table></figure><p>如果像下面这样转而使用<code>if-elif-else</code>结构，代码将不能正确地运行，因为有一个判断通过:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requested_fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;apple&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding apple.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;pear&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding pear.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;banana&#x27;</span> <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding banana.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\nFinished adding your fruits!&quot;</span>)</span><br></pre></td></tr></table></figure><p>第一个判断检查列表中是否包含<code>apple</code>，它通过了，因此在购物车里面添加<code>apple</code>。然而，Python将跳过<code>if-elif-else</code>结构中余下的判断，不再检查列表中是否包含<code>pear</code>和 <code>banana</code>。其结果是，将添加顾客要的第一种水果，但不会添加其他的水果:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Adding pear.</span><br><span class="line"></span><br><span class="line">Finished adding your fruits!</span><br></pre></td></tr></table></figure><p>总之，如果你只想执行一个代码块，就使用<code>if-elif-else</code>结构，如果要运行多个代码块，就使用一系列独立的if语句。</p><h3 id="使用if语句处理列表"><a href="#使用if语句处理列表" class="headerlink" title="使用if语句处理列表"></a>使用if语句处理列表</h3><p>通过结合使用if语句和列表，可完成一些有趣的任务:对列表中特定的值做特殊处理;高效地管理不断变化的情形，如餐馆是否还有特定的食材;证明代码在各种情形下都将按预期那样运行。</p><h4 id="检查特殊元素"><a href="#检查特殊元素" class="headerlink" title="检查特殊元素"></a>检查特殊元素</h4><p>在我们开头通过一个简单示例演示了如何处理特殊值<code>bmw</code>——它需要采用不同的格式进行打印。既然你对条件判断和if语句有了大致的认识，下面来进一步研究如何检查列表中的特殊值，并对其做合适的处理。<br>继续使用前面的比水果列表示例。每添加一种水果刀购物车都打印一条消息。通过创建一个列表，在其中包含顾客需要购买的水果，并使用一个循环来指出添加到购物车中的谁，可以以极高的效率编写这样的代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requested_fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    print(<span class="string">&quot;Adding &quot;</span> + fruit + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\nFinished adding your fruits!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出很简单，因为上述代码不过是一个简单的for循环:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Adding apple.</span><br><span class="line">Adding pear.</span><br><span class="line">Adding banana.</span><br><span class="line"></span><br><span class="line">Finished adding your fruits!</span><br></pre></td></tr></table></figure><p>然而，如果水果店的<code>apple</code>卖完了，该如何处理呢?为妥善地处理这种情况，可在for循环中包含一条if语句:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requested_fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> requested_fruits: </span><br><span class="line">    <span class="keyword">if</span> fruit == <span class="string">&#x27;apple&#x27;</span>:</span><br><span class="line">        print(<span class="string">&quot;Sorry, we are apple right now.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;Adding &quot;</span> + fruit + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\nFinished adding your fruits!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里在往购物车里面添加的每种水果都进行检查。if代码判断顾客想要的是不是<code>apple</code>，如果是，就显示一条消息，已经没有<code>apple</code>了。else代码块确保其他水果都能添加到购物车内:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sorry, we are apple right now.</span><br><span class="line">Adding pear.</span><br><span class="line">Adding banana.</span><br><span class="line"></span><br><span class="line">Finished adding your fruits!</span><br></pre></td></tr></table></figure><h4 id="确定列表不是空的"><a href="#确定列表不是空的" class="headerlink" title="确定列表不是空的"></a>确定列表不是空的</h4><p>到目前为止，对于处理的每个列表都做了一个简单的假设，即假设它们都至少包含一个元素。但是在运行for循环前确定列表是否为空很重要。<br>下面在给顾客添加购物车时，先判断线上商品列表是不是空的。如果列表是空的，就向顾客确认他是否要点蔬菜，如果列表不为空，就像前面的示例那样添加到购物车:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requested_fruits = []</span><br><span class="line"><span class="keyword">if</span> requested_fruits:</span><br><span class="line">    <span class="keyword">for</span> fruit <span class="keyword">in</span> requested_fruits:</span><br><span class="line">        print(<span class="string">&quot;Adding &quot;</span> + fruit + <span class="string">&quot;.&quot;</span>) </span><br><span class="line">        print(<span class="string">&quot;\nFinished adding your fruits!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;Are you sure you want some vegetables?&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这里，我们首先创建了一个空列表，其中不包含任何水果。首先我们进行了判断，而不是直接执行for循环。当我们直接判断一个列表是，Python将在列表至少包含一个元素时返回<code>True</code>，并在列表为空时返回<code>False</code>。如果<code>requested_fruits</code>不为空，就运行与前一个示例相同的for循环，否则，就打印一条消息<br>在这里，这个列表为空，因此输出如下——询问顾客是否需要蔬菜: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want some vegetables?</span><br></pre></td></tr></table></figure><p>如果这个列表不为空，则会将水果添加到购物车中。</p><blockquote><p>小作业:<br>10-1 检查两个数字相等、不等、大于、小于、大于等于和小于等于。<br>10-2 请创建一个名为 brush_color 的画笔变量，并将其设置为’green’、’yellow’或’red’。编写一条if语句，检查画笔是否是绿色的，如果是，就打印一条消息。<br>10-3 像练习 10-2 那样设置画笔的颜色，并编写一个if-else结构。如果画笔是绿色的，就打印一条消息。如果画笔不是绿色的，就打印另一条消息。<br>10-4 将练习 10-3 中的 if-else 结构改为 if-elif-else 结构。实现以下逻辑<br>如果画笔是绿色的，就打印一条消息，这是绿色。<br>如果画笔是黄色的，就打印一条消息，这是黄色。<br>如果画笔是红色的，就打印一条消息，这是红色。<br>10-5 人生的不同阶段:设置变量 age 的值，再编写一个if-elif-else 结构，根据 age的值判断处于人生的哪个阶段。<br>如果一个人的年龄小于 2 岁，就打印一条消息，指出他是婴儿。<br>如果一个人的年龄为 2(含)-4 岁，就打印一条消息，指出他正蹒跚学步。<br>如果一个人的年龄为 4(含)-13 岁，就打印一条消息，指出他是儿童。<br>如果一个人的年龄为 13(含)-20 岁，就打印一条消息，指出他是青少年。<br>如果一个人的年龄为 20(含)-65 岁，就打印一条消息，指出他是成年人。<br>如果一个人的年龄超过 65(含)岁，就打印一条消息，指出他是老年人。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python if语句 </tag>
            
            <tag> Python 控制语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-9】Python手把手教程之——元组和元组的使用技巧</title>
      <link href="python-tuple-1-9.html"/>
      <url>python-tuple-1-9.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网 站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素， 元组可以满足这种需求。Python将不能修改的值称为<strong>不可变</strong>的，而不可变的列表被称为<strong>元组</strong>。</p><h4 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h4><p>元组看起来跟列表很想，但使用<strong>圆括号</strong>而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。<br>例如，如果有一个大小不应改变的矩形，可将其长度和宽度存储在一个元组中，从而确保它们是不能修改的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rectangle = (<span class="number">200</span>, <span class="number">50</span>) </span><br><span class="line">print(rectangle[<span class="number">0</span>]) </span><br><span class="line">print(rectangle[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>我们首先定义了元组rectangle，为此我们使用了圆括号而不是方括号。接下来，我们分别打印该元组的各个元素。<br>输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p>下面来尝试修改元组rectangle中的一个元素，看看结果如何:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rectangle[<span class="number">0</span>] = <span class="number">250</span></span><br></pre></td></tr></table></figure><p>如果我们运行一下上面的代码，就会发现Python返回类型错误消息。因为元组是<strong>不允许被修改的</strong>，因此会出现如下错误：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>需要记住的是：元组是不可以被修改的，所以使用过程中不能修改元组的值。</p><h4 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h4><p>像列表一样，也可以使用for循环来遍历元组中的所有值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rectangle = (<span class="number">200</span>, <span class="number">50</span>) </span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rectangle:</span><br><span class="line">    print(r)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> </span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><h4 id="给元组重新赋值"><a href="#给元组重新赋值" class="headerlink" title="给元组重新赋值"></a>给元组重新赋值</h4><p>虽然我们不能修改元组内部的值，但是我们可以通过给元组重新赋值的方式来来改变元组的值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rectangle = (<span class="number">200</span>, <span class="number">50</span>) </span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rectangle:</span><br><span class="line">    print(r)</span><br><span class="line">rectangle = (<span class="number">400</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> rectangle:</span><br><span class="line">    print(r)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">400</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都 不变，可使用元组。</p><blockquote><p>小作业<br>9-1 有一个菜摊，提供五种蔬菜。请想出五种简单的蔬菜，并将其存储在一个元组中。<br>9-2 使用一个 for 循环将该菜摊提供的五种蔬菜都打印出来。<br>9-3给元组变量赋值，修改其中一种蔬菜为新品种，并使用一个 for 循环将新元组的每个元素都打印出来。<br>9-4尝试修改其中的一个元素，核实 运行时会报错。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python元组 </tag>
            
            <tag> Python数据管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-15】Flutter手把手教程Dart语言——包管理工具Pub详解、pub get,pub cache使用</title>
      <link href="dart-pub-command-1-15.html"/>
      <url>dart-pub-command-1-15.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="什么是Pub工具"><a href="#什么是Pub工具" class="headerlink" title="什么是Pub工具"></a>什么是Pub工具</h4><p>Dart 生态系统使用包来管理共享软件，比如：库和工具。我们使用Pub包管理工具 来获取Dart包。在<a href="https://pub.flutter-io.cn/">Pub</a>上，可以找到公开可用的包。或者从本地文件系统或其他的位置，比如Git仓库，加载可用的包。无论包是从什么途径加载的， Pub 都会进行版本依赖管理，从而帮助我们获得版本兼容的软件包以及SDK。<br><strong>pub工具</strong>包含管理 Package 、部署 Package 和部署命令行应用的命令。<br>Dart 包目录中至少包含一个pubspec文件。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_06_pubspec.png" alt="2020_12_06_pubspec"><br>pubspec 文件记录一些关于项目的依赖数据。此外还有一些其他数据比如：Dart 库，应用，资源，测试，图片，以及示例。</p><p>下面是一个 pubspec 的示例，示例中声明依赖了在 Pub 站点上托管的两个包（ js 和 intl ）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">my_app</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">^0.6.0</span></span><br><span class="line">  <span class="attr">intl:</span> <span class="string">^0.15.8</span></span><br></pre></td></tr></table></figure><h4 id="pub-get"><a href="#pub-get" class="headerlink" title="pub get"></a>pub get</h4><p>在项目中配置了pubspec文件后，就可以在项目根目录中执行<code>pub get</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;path-to-my_app&gt;</span><br><span class="line">pub get</span><br></pre></td></tr></table></figure><p><code>pub get</code>命令确定当前应用所依赖的包，并将它们保存到中央系统缓存（central system cache）中。如果当前应用依赖了一个公开包，Pub会从Pub站点下载该包。对于一个Git依赖，Pub会Clone该Git仓库。<br>同样包括包的相关依赖也会被下载。例如，如果 js 包依赖 test 包， pub 会同时获取js包和test包。</p><p>Pub 会创建一个.packages 文件（位于应用程序的根目录下），该文件将应用程序所依赖的每个包名相应的映射到系统缓存中的包。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_06_packages.png" alt="2020_12_06_packages"></p><h4 id="pub-upgrade"><a href="#pub-upgrade" class="headerlink" title="pub upgrade"></a>pub upgrade</h4><p>第一次获取依赖时，Pub 会下载依赖及其兼容的最新版本。然后通过创建<code>lockfile</code> 锁定依赖，以始终使用这个版本。 Pub会在<code>pubspec</code>旁创建并存储一个名为<code>pubspec.lock</code>文件。它列出了使用的每个依赖包的指定版本（当前包或传递包的版本）。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_12_06_pubspec_lock.png" alt="2020_12_06_pubspec_lock"><br>在开发项目中的每个人都能够使用所有相同版本的包。同样加入到 lockfile 可以保证部署的应用使用的是同一版本的代码。</p><p>如果已经准备更新依赖到最新版本，使用命令 pub upgrade ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub upgrade</span><br></pre></td></tr></table></figure><p>上面的命令用于重新生成 lockfile 文件，并使用最新可用版本的依赖包。如果仅升级某个依赖，可以在命令中指定需要升级的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub upgrade intl</span><br></pre></td></tr></table></figure><p>上面的命令升级<code>intl</code>到最新版本，其它包不变。</p><p><strong>注意</strong><code>pub upgrade</code> 命令并非总是可以将所有的package更新到最新版本，原因是pubspec文件中的一些package之间有版本限制的冲突。</p><h4 id="pub-cache"><a href="#pub-cache" class="headerlink" title="pub cache"></a>pub cache</h4><p>用于管理 Pub 的本地 Package 缓存。使用该命令你可以将一个 Package 添加至缓存，或者清除所有缓存的 Package 并重新安装。<br>你可以使用<code>pub cache add</code>命令将新的 Package 添加至缓存。也可以使用<code>pub cache repair</code> 命令将Package从缓存中清除并重新安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub cache add &lt;package&gt; [--version &lt;constraint&gt;] [--all]</span><br><span class="line">pub cache repair</span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">add &lt;package&gt;    <span class="comment"># 在你的缓存中安装一个库。</span></span><br><span class="line"></span><br><span class="line">--all   <span class="comment"># 可选的选项。与 pub add 结合使用用于安装某个库的所有版本。</span></span><br><span class="line"></span><br><span class="line">--version &lt;constraint&gt;  <span class="comment"># 可选的选项。与 pub add 结合使用根据限制条件安装最适合的版本。</span></span><br><span class="line"><span class="comment"># 例如：pub cache add barback --version &quot;&lt;=0.8.0 &lt;0.110&quot;  如果省略掉 --version，Pub 会从已知的版本中挑选一个最适合的进行安装。</span></span><br><span class="line"></span><br><span class="line">repair <span class="comment"># 如果 Pub 缓存中的 Package 被修改坏了的。例如，有人不小心修改了依赖内的文件，但是不知道该如何修改回来。pub cache repair 命令可以对系统缓存中的所有 Package 执行重安装以修正篡改的问题。</span></span><br></pre></td></tr></table></figure><h4 id="pub-deps"><a href="#pub-deps" class="headerlink" title="pub deps"></a>pub deps</h4><p>该命令可以将 Package 的依赖图示打印输出到控制台。该图示中包括 Package 声明在 pubspec 文件中的<strong>直接依赖</strong>以及这些直接依赖所依赖的<strong>间接依赖</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub deps [--style=&lt;style&gt;] [--dev] [--no-dev] [--executables]</span><br></pre></td></tr></table></figure><p>依赖信息默认以树状的形式打印输出。<br>例如，有个项目的pubspec文件中声明了如下依赖信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  barback: ^0.15.2</span><br><span class="line">  markdown: ^0.7.2</span><br></pre></td></tr></table></figure><p>当你执行 pub deps 命令时则会看到项目的依赖图示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">markdown_converter 0.0.0</span><br><span class="line">|-- barback 0.15.2+6</span><br><span class="line">|   |-- collection 1.1.2</span><br><span class="line">|   |-- path 1.3.6</span><br><span class="line">|   |-- pool 1.1.0</span><br><span class="line">|   |   <span class="string">&#x27;-- stack_trace...</span></span><br><span class="line"><span class="string">|   |-- source_span 1.2.0</span></span><br><span class="line"><span class="string">|   |   &#x27;</span>-- path...</span><br><span class="line">|   <span class="string">&#x27;-- stack_trace 1.4.2</span></span><br><span class="line"><span class="string">|       &#x27;</span>-- path...</span><br><span class="line"><span class="string">&#x27;-- markdown 0.7.2</span></span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--style=&lt;style&gt; 或 -s &lt;style&gt; <span class="comment">## 指定的样式输出格式。用于指定依赖项打印输出的样式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 共有 简洁、树状 和 列表 三种，默认是树状样式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tree 以树状的形式打印依赖信息。这是默认格式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 以列表的形式打印依赖信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compact 以紧凑列表的形式打印依赖信息。</span></span><br><span class="line"></span><br><span class="line">--dev <span class="comment"># 打印所有包依赖信息，包括开发时期依赖。它是默认选项。</span></span><br><span class="line"></span><br><span class="line">--no-dev <span class="comment">#打印除了开发期依赖之外的所有包依赖。</span></span><br><span class="line"></span><br><span class="line">--executables <span class="comment">#打印所有可用的可执行文件。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pub-downgrade"><a href="#pub-downgrade" class="headerlink" title="pub downgrade"></a>pub downgrade</h4><p>在没有其它额外参数的情况下，<code>pub downgrade</code>命令会获取当前工作目录下 pubspec.yaml 文件中列出的所有依赖项以及它们间接依赖项的<strong>最低</strong>版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub downgrade [--[no-]offline] [-n|--dry-run] [dependencies...]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pub downgrade</span><br><span class="line">Resolving dependencies... (1.2s)</span><br><span class="line">+ barback 0.13.0</span><br><span class="line">+ collection 0.9.1</span><br><span class="line">+ path 1.2.0</span><br><span class="line">+ source_maps 0.9.0</span><br><span class="line">+ source_span 1.0.0</span><br><span class="line">+ stack_trace 0.9.1</span><br><span class="line">Changed 6 dependencies!</span><br></pre></td></tr></table></figure><p><code>pub downgrade</code> 命令会创建一个<code>lockfile</code>文件。如果<code>lockfile</code>文件已经存在，Pub 则会忽略该文件并生成一个新的<code>lockfile</code> 文件，然后所有依赖项都会使用最低版本。</p><p><strong>降级指定依赖项</strong><br>你可以指定<code>pub downgrade</code>命令只将某个依赖项的版本降至最低且不影响其余依赖项。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pub downgrade <span class="built_in">test</span></span><br><span class="line">Resolving dependencies...</span><br><span class="line">  barback 0.15.2+2</span><br><span class="line">  bot 0.27.0+2</span><br><span class="line">  browser 0.10.0+2</span><br><span class="line">  chrome 0.6.5</span><br><span class="line">  collection 1.1.0</span><br><span class="line">  path 1.3.0</span><br><span class="line">  pool 1.0.1</span><br><span class="line">  source_span 1.0.2</span><br><span class="line">&lt; stack_trace 0.9.2 (was 1.1.1)</span><br><span class="line">  stagexl 0.10.2</span><br><span class="line">&lt; <span class="built_in">test</span> 0.10.0 (was 0.11.4)</span><br><span class="line">These packages are no longer being depended on:</span><br><span class="line">- matcher 0.11.3</span><br><span class="line">Changed 3 dependencies!</span><br></pre></td></tr></table></figure><p>如果你降低指定依赖项的版本，且该依赖项还有间接依赖项，那么在版本变更后这些间接依赖项可能不适配降低后的新版依赖项。此时，Pub 会尝试在新版本依赖项可接受的范围内查找版本最高的该依赖项所依赖的间接依赖项。因此，通常而言，降低某个依赖项的版本后，其间接依赖项的版本也会随之降低。<br><strong>获取新的依赖项</strong><br>如果在执行<code>pub downgrade</code>命令前将某个依赖添加至 pubspec 文件中，则在执行该命令后会将该新的依赖项以及其间接依赖的其它依赖项下载并将其放到 .packages 文件中。这点与 <code>pub get</code> 命令一致。</p><p><strong>移除依赖项</strong><br>如果在 <code>pub downgrade</code> 命令前从 pubspec 文件移除了某个依赖项，则在执行该命令后会将该依赖项从 .packages 文件中移除，且代码使用到该依赖项的相关导入将变得不可用。所有该依赖项依赖的间接依赖项也同时会被移除，只要这些间接依赖项没有没其它的依赖项所依赖。这点也与<code>pub get</code> 命令一致。</p><p><strong>离线降级</strong><br>在没有网络的情况下你也依然可以运行<code>pub downgrade</code> 命令。因为 Pub 会将 Package 下载到一个统一的缓存区并将其与系统上其它的 Package 进行共享，如果你所需的 Package 是一个使用频率很高的 Package，那么很有可能它已经被其它 Package 在使用时下载到统一缓存区中了，此时你可以直接依赖使用它。</p><p>但是，默认情况下，<code>pub downgrade</code> 命令会总是尝试获取线上的依赖版本，因此 Pub 可以确定依赖项是否有更新的版本。如果你不想 Pub 去线上检查，可以使用 <code>--offline</code> 命令参数让该命令在离线模式下执行。在离线模式下，Pub 只会从本地缓存区查找已经下载到的可用 Package。</p><p><strong>选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--[no-]offline <span class="comment"># 默认情况下，pub 将会通过网络检查（--no-offline）。要使用缓存的包，请使用 --offline。</span></span><br><span class="line">--dry-run 或 -n <span class="comment">#报告将要改变的依赖项，但不会真的改变它。</span></span><br></pre></td></tr></table></figure><h4 id="pub-publish"><a href="#pub-publish" class="headerlink" title="pub publish"></a>pub publish</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub publish [--dry-run] [--force]</span><br></pre></td></tr></table></figure><p>该命令用于将你的 Package 发布到<a href="https://pub.dev/">pub.dev</a>网站以供其他人下载和依赖。<br><strong>选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--dry-run 或 -n <span class="comment">#该选项可以让你运行上传 Package 的整个流程但不会真正地上传任何文件到 pub.dev 网站。此操作可以让你在真正上传到 pub.dev 网站前检查你的上传等相关配置是否有误。</span></span><br><span class="line"></span><br><span class="line">--force 或 -f  <span class="comment">#该选项让 Pub 在上传时不再向你进行确认。正常情况下，它会在你上传时向你显示 Package 的内容以及向你进行确认。</span></span><br></pre></td></tr></table></figure><p>如果 Package 存在错误，Pub 则会退出且不继续进行上传。如果出现的是警告，则 Package 会依旧被上传。如果你想确保你的 Package 在上传前没有警告，请确保不要使用 <code>--force</code> 和 <code>--dry-run</code> 选项。</p><h4 id="pub-uploader"><a href="#pub-uploader" class="headerlink" title="pub uploader"></a>pub uploader</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub uploader [options] &#123;add/remove&#125; &lt;email&gt;</span><br></pre></td></tr></table></figure><p>该命令允许<code>pub.dev</code>网站上某个 Package的上传者为该Package添加或删除其它的上传者。其有两个子命令<code>add</code>和<code>remove</code>，可以将邮件地址作为某个上传者的标识以此来添加或删除上传者。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub uploader add bob@example.com <span class="comment"># 我们已经向 bob@example.com 发送了一份邀请函，在他/她确认后就会成被加入上传者（权限）</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub uploader remove bob@example.com <span class="comment"># // 成功将该上传者从 package 中移除</span></span><br></pre></td></tr></table></figure><p>如果 Package 有且只有一个上传者，则该上传者不能再被删除。你可以将自己从上传者列表中删除（只要 Package 中还有其它的上传者即可），但是一旦你删除了自己后则不能再将自己添加回去。</p><p>默认情况下，你修改的是当前工作目录中 Package 的上传者。你可以通过 –package 标识来指定修改哪个 Package 的上传者。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub uploader --package=transmogrify add bob@example.com </span><br><span class="line"> <span class="comment"># // 我们已经向 bob@example.com 发送了一份邀请函，在他/她确认后就会成被加入上传者（权限）</span></span><br></pre></td></tr></table></figure><p>通过 <code>pub uploader add &lt;email&gt;</code> 命令发送邀请，被邀请的用户必须<strong>接受</strong>。</p><h4 id="其他不常用的命令可参考："><a href="#其他不常用的命令可参考：" class="headerlink" title="其他不常用的命令可参考："></a>其他不常用的命令可参考：</h4><p><strong>pub outdated</strong> 使用方法参考：<a href="https://zhuanlan.zhihu.com/p/138638020">https://zhuanlan.zhihu.com/p/138638020</a><br><strong>pub global</strong> 使用方法参考：<a href="https://www.jianshu.com/p/8a7f2cbac7a1">https://www.jianshu.com/p/8a7f2cbac7a1</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart pub </tag>
            
            <tag> Flutter pub使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-14】Flutter手把手教程Dart语言——Dart语言引用、import、package使用</title>
      <link href="dart-package-1-14.html"/>
      <url>dart-package-1-14.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p><code>import</code> 关键字可以帮助你创建一个模块化和可共享的代码库，代码库不仅只是提供 API 而且还起到了封装的作用：以下划线（_）开头的成员仅在代码库中可见。</p><h4 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h4><p>使用<code>import</code>来指定命名空间以便其它库可以访问。比如你可以导入代码库 <code>dart:html</code>来使用<code>Dart Web</code>中相关 API：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>的唯一参数是用于指定代码库的<code>URI</code>，对于<code>Dart</code>内置的库，使用 <code>dart:xxxxxx</code>的形式。而对于其它的库，你可以使用一个文件系统路径或者以 <code>package:xxxxxx</code> 的形式。<code>package:xxxxxx</code> 指定的库通过包管理器（比如 pub 工具）来提供：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:test/test.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h4><p>如果你导入的两个代码库有冲突的标识符，你可以为其中一个指定前缀。比如如果 <code>library1</code>和<code>library2</code> 都有<code>Element</code> 类，那么可以这么处理：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// 使用 lib1 的 Element 类。</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"><span class="comment">// 使用 lib2 的 Element 类。</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><h4 id="导入库的一部分"><a href="#导入库的一部分" class="headerlink" title="导入库的一部分"></a>导入库的一部分</h4><p>如果你只想使用代码库中的一部分，你可以有选择地导入代码库。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入 lib1 中的 foo。(Import only foo).</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"><span class="comment">// 导入 lib2 中除了 foo 外的所有。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br></pre></td></tr></table></figure><h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p><strong>延迟加载</strong>（也常称为懒加载）允许应用在需要时再去加载代码库，下面是可能使用到延迟加载的场景：</p><ul><li><p>为了减少应用的初始化时间。</p></li><li><p>处理 A/B 测试，比如测试各种算法的不同实现。</p></li><li><p>加载很少会使用到的功能，比如可选的屏幕和对话框。</p></li></ul><p>使用<code>deferred as</code>关键字来标识需要延时加载的代码库：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:greetings/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure><p>当实际需要使用到库中API时先调用<code>loadLibrary</code>函数加载库：</p><pre><code class="dart">Future greet() async &#123;  await hello.loadLibrary();  hello.printGreeting();&#125;</code></pre><p>在前面的代码，使用 await 关键字暂停代码执行直到库加载完成。更多关于 async 和 await 的信息请参考异步支持。<br><code>loadLibrary</code> 函数可以调用多次也没关系，代码库只会被加载一次。<br>当你使用延迟加载的时候需要牢记以下几点：</p><ul><li>延迟加载的代码库中的常量需要在代码库被加载的时候才会导入，未加载时是不会导入的。</li><li>导入文件的时候无法使用延迟加载库中的类型。如果你需要使用类型，则考虑把接口类型转移到另一个库中然后让两个库都分别导入这个接口库。</li><li><code>Dart</code>会隐式地将<code>loadLibrary</code>方法导入到使用了<code>deferred as</code>命名空间 的类中。<code>loadLibrary</code>函数返回的是一个<code>Future</code>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart import </tag>
            
            <tag> Dart 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-13】Flutter手把手教程Dart语言——异步、Future、Stream、async、await详解</title>
      <link href="dart-asynchronous-1-13.html"/>
      <url>dart-asynchronous-1-13.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Dart 代码库中有大量返回<code>Future</code>或<code>Stream</code>对象的函数，这些函数都是<strong>异步</strong>的，它们会在耗时操作执行完毕前直接返回而不会等待耗时操作执行完毕。<br><code>async</code>和<code>await</code>关键字用于实现异步编程，并且让你的代码看起来就像是同步的一样。</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>可以通过下面两种方式，获得<code>Future</code>执行完成的结果：</p><ul><li>使用<code>async</code>和<code>await</code>；</li><li>使用<code>Future API</code>；</li></ul><p>使用<code>async</code>和<code>await</code>的代码是异步的，但是看起来有点像同步代码。例如，下面的代码使用<code>await</code>等待异步函数的执行结果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure><p>必须在带有<code>async</code>关键字的<strong>异步函数</strong>中使用 <code>await</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// 使用 version 继续处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管异步函数可以处理耗时操作，但是它并不会等待这些耗时操作完成，异步函数执行时会在其遇到第一个 <code>await</code>表达式的时候返回一个<code>Future</code>对象，然后等待<code>await</code>表达式执行完毕后继续执行。</p><p>使用<code>try</code>、<code>catch</code>以及<code>finally</code>来处理使用<code>await</code>导致的异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 无法找到版本时做出的反应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在异步函数中多次使用<code>await</code>关键字。例如，下面代码中等待了三次函数结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure><p><code>await</code>表达式的返回值通常是一个<code>Future</code>对象；<br>如果不是的话也会自动将其包裹在一个<code>Future</code>对象里。<code>Future</code>对象代表一个”承诺”,<code>await</code>表达式会阻塞直到需要的对象返回。</p><p>如果在使用<code>await</code>时导致编译错误，请确保<code>await</code>在一个异步函数中使用。例如，如果想在<code>main()</code>函数中使用<code>await</code>，那么<code>main()</code>函数就必须使用<code>async</code>关键字标识。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;在 Main 函数中执行：版本是 <span class="subst">$&#123;await lookUpVersion()&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h4><p>定义<strong>异步函数</strong>只需在普通方法上加上<code>async</code>关键字即可。<br>将关键字<code>async</code>添加到函数并让其返回一个<code>Future</code> 对象。假设有如下返回<code>String</code>对象的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将其改为异步函数，返回值是<code>Future</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意，函数体不需要使用<code>Future API</code>。如有必要，<code>Dart</code>会创建<code>Future</code>对象。<br>如果函数没有返回有效值，需要设置其返回类型为 <code>Future&lt;void&gt;</code></p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p><code>Stream</code>也是用于接收异步事件数据，和<code>Future</code>不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。<code>Stream</code>常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stream.fromFutures([</span><br><span class="line">  <span class="comment">// 1秒后返回结果</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello 1&quot;</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 抛出一个异常</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),()&#123;</span><br><span class="line">    <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 3秒后返回结果</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello 3&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">]).listen((data)&#123;</span><br><span class="line">   <span class="built_in">print</span>(data);</span><br><span class="line">&#125;, onError: (e)&#123;</span><br><span class="line">   <span class="built_in">print</span>(e.message);</span><br><span class="line">&#125;,onDone: ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码依次会输出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="number">1</span></span><br><span class="line">Error</span><br><span class="line">hello <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Dart异步 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart Future </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-12】Flutter手把手教程Dart语言——什么是泛型和泛型的使用场景</title>
      <link href="dart-generic-1-12.html"/>
      <url>dart-generic-1-12.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>如果你查看数组的API文档，你会发现数组<code>List</code>的实际类型为<code>List&lt;E&gt;</code>。<code>&lt;&gt;</code> 符号表示数组是一个泛型（或参数化类型）通常使用一个字母来代表类型参数，比如E、T、S、K 和 V 等等。</p><h4 id="为什么使用泛型？"><a href="#为什么使用泛型？" class="headerlink" title="为什么使用泛型？"></a>为什么使用泛型？</h4><p>泛型常用于需要要求类型安全的情况，但是它对代码运行也有好处：</p><ul><li>适当地指定泛型可以更好地帮助代码生成。</li><li>使用泛型可以减少代码重复。</li></ul><p>比如你想声明一个只能包含<code>String</code>类型的数组，你可以将该数组声明为<code>List&lt;String&gt;</code>，这表示只能包含字符串类型的数组。这样的话就可以很容易避免因为在该数组放入非<code>String</code>类变量而导致的诸多问题，同时编译器以及其他阅读代码的人都可以很容易地发现并定位问题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 这样写就会报错</span></span><br><span class="line">``` </span><br><span class="line">另一个使用泛型的原因是可以减少重复代码。泛型可以让你在多个不同类型实现之间共享同一个接口声明，比如下面的例子中声明了一个类用于缓存对象的接口：</span><br><span class="line">``` dart</span><br><span class="line"><span class="comment">/// <span class="markdown">定义一个 抽象类</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不久后你可能又会想专门为<code>String</code>类对象做一个缓存，于是又有了专门为<code>String</code>做缓存的类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">另外一个抽象类</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果过段时间你又想为数字类型也创建一个类，那么就会有很多诸如此类的代码。<br>这时候可以考虑使用泛型来声明一个类，让不同类型的缓存实现该类做出不同的具体实现即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>T</code>是一个替代类型。其相当于类型占位符，在开发者调用该接口的时候会指定具体类型。</p><h4 id="使用集合字面量"><a href="#使用集合字面量" class="headerlink" title="使用集合字面量"></a>使用集合字面量</h4><p><code>List、Set</code>以及<code>Map</code>字面量也可以是参数化的。定义参数化的<code>List</code>只需在中括号前添加<code>&lt;type&gt;</code>；定义参数化的<code>Map</code>只需要在大括号前添加 <code>&lt;keyType, valueType&gt;</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>: <span class="string">&#x27;主页&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>: <span class="string">&#x27;网页机器人提示&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>: <span class="string">&#x27;我们是人类，不是机器&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用类型参数化的构造函数"><a href="#使用类型参数化的构造函数" class="headerlink" title="使用类型参数化的构造函数"></a>使用类型参数化的构造函数</h4><p>在调用构造方法时也可以使用泛型，只需在类名后用尖括号<code>&lt;...&gt;</code>将一个或多个类型包裹即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSet = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure><p>下面代码创建了一个键为<code>Int</code>类型，值为<code>View</code>类型的<code>Map</code>对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> views = <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br></pre></td></tr></table></figure><h4 id="泛型集合以及它们所包含的类型"><a href="#泛型集合以及它们所包含的类型" class="headerlink" title="泛型集合以及它们所包含的类型"></a>泛型集合以及它们所包含的类型</h4><p>Dart的泛型类型是固化的，这意味着即便在运行时也会保持类型信息：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;小芸&#x27;</span>, <span class="string">&#x27;小芳&#x27;</span>, <span class="string">&#x27;小民&#x27;</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h4><p>有时使用泛型的时候可能会想限制泛型的类型范围，这时候可以使用<code>extends</code>关键字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 具体实现……</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;&#x27;Foo&lt;<span class="subst">$T</span>&gt;&#x27; 的实例&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这时候就可以使用<code>SomeBaseClass</code>或者它的子类来作为泛型参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure><p>这时候也可以指定无参数的泛型，这时无参数泛型的类型则为 <code>Foo&lt;SomeBaseClass&gt;</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Foo();</span><br><span class="line"><span class="built_in">print</span>(foo); <span class="comment">// &#x27;Foo&lt;SomeBaseClass&gt;&#x27; 的例   </span></span><br></pre></td></tr></table></figure><p>将非<code>SomeBaseClass</code>的类型作为泛型参数则会导致编译错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">这样写是会报错的</span></span></span><br><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;(); </span><br></pre></td></tr></table></figure><h4 id="使用泛型方法"><a href="#使用泛型方法" class="headerlink" title="使用泛型方法"></a>使用泛型方法</h4><p>起初<code>Dart</code>只支持在类的声明时指定泛型，现在同样也可以在方法上使用泛型，称之为<code>泛型方法</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// 处理一些初始化工作或错误检测……</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 处理一些额外的检查……</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 <code>first&lt;T&gt;</code> 的泛型<code>T</code>可以在如下地方使用：</p><ul><li>函数的返回值类型 <code>T</code>。</li><li>参数的类型 <code>List&lt;T&gt;</code>。</li><li>局部变量的类型 <code>T tmp</code>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart运算符 </tag>
            
            <tag> Dart Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-11】Flutter手把手教程Dart语言——类、类的的成员变量和方法、类的构造函数</title>
      <link href="dart-class-1-11.html"/>
      <url>dart-class-1-11.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Dart是一种面向对象的语言，所有对象都是一个类的实例，而所有的类都继承自<code>Object</code>类。每个除了<code>Object</code>类之外的类都只有一个超类，一个类的代码可以在其它多个类继承中重复使用。</p><h4 id="类的实例变量"><a href="#类的实例变量" class="headerlink" title="类的实例变量"></a>类的实例变量</h4><p>下面是声明实例变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x; <span class="comment">// 声明 double 变量 x 并初始化为 null。</span></span><br><span class="line">  <span class="built_in">double</span> y; <span class="comment">// 声明 double 变量 y 并初始化为 null</span></span><br><span class="line">  <span class="built_in">double</span> z = <span class="number">0</span>; <span class="comment">// 声明 double 变量 z 并初始化为 0。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有未初始化的实例变量其值均为<code>null</code>。</p><p>所有实例变量均会隐式地声明一个<code>Getter</code> 方法，非<code>final</code>类型的实例变量还会隐式地声明一个<code>Setter</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x;</span><br><span class="line">  <span class="built_in">double</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point();</span><br><span class="line">  point.x = <span class="number">4</span>; <span class="comment">// 使用 x 的 Setter 方法。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// 使用 x 的 Getter 方法。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// 默认值为 null。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在声明一个实例变量的时候就将其初始化（而不是在构造函数或其它方法中），那么该实例变量的值就会在对象实例创建的时候被设置，该过程会在构造函数以及它的初始化器列表执行前。</p><h5 id="访问类的成员"><a href="#访问类的成员" class="headerlink" title="访问类的成员"></a>访问类的成员</h5><p>对象的成员由函数和数据（即方法和实例变量）组成。方法的调用要通过对象来完成，这种方式可以访问对象的函数和数据。<br>使用<code>.</code>来访问对象的实例变量或方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 获取 y 值</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 调用变量 p 的 distanceTo() 方法。</span></span><br><span class="line"><span class="built_in">double</span> distance = p.distanceTo(Point(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>使用 <code>?.</code> 代替<code>.</code>可以避免因为左边表达式为<code>null</code> 而导致的问题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If p is non-null, set a variable equal to its y value.</span></span><br><span class="line"><span class="keyword">var</span> a = p?.y;</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>方法是对象提供行为的函数。</p><p>对象的实例方法可以访问实例变量和<code>this</code>。下面的<code>distanceTo()</code>方法就是一个实例方法的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重写类成员"><a href="#重写类成员" class="headerlink" title="重写类成员"></a>重写类成员</h5><p>子类可以重写父类的实例方法（包括操作符）、 <code>Getter</code> 以及 <code>Setter</code> 方法。你可以使用 <code>@override</code>注解来表示你重写了一个成员：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="noSuchMethod-方法"><a href="#noSuchMethod-方法" class="headerlink" title="noSuchMethod 方法"></a>noSuchMethod 方法</h5><p>如果调用了对象中不存在的方法或实例变量将会触发<code>noSuchMethod</code> 方法，你可以重写<code>noSuchMethod</code>方法来追踪和记录这一行为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除非你重写 noSuchMethod，否则调用一个不存在的成员会导致 NoSuchMethodError。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你尝试使用一个不存在的成员：&#x27;</span> + <span class="string">&#x27;<span class="subst">$&#123;invocation.memberName&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不能调用一个未实现的方法除非满足下面其中的一个条件：</p><ul><li>接收方是静态的<code>dynamic</code> 类型。</li><li>接收方具有静态类型，定义了未实现的方法，并且接收方的动态类型实现了<code>noSuchMethod</code>方法且具体的实现与<code>Object</code>中的不同。</li></ul><h4 id="类的静态变量和静态方法"><a href="#类的静态变量和静态方法" class="headerlink" title="类的静态变量和静态方法"></a>类的静态变量和静态方法</h4><p>使用关键字<code>static</code>可以声明类变量或类方法。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量（即类变量）常用于声明类范围内所属的状态变量和常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> initialCapacity = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Queue.initialCapacity == <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量在其首次被使用的时候才被初始化。</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法（即类方法）不能被一个类的实例访问，同样地，静态方法内也不可以使用关键字<code>this</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">double</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="number">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class="number">2.9</span>);</span><br><span class="line">  <span class="built_in">print</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用构造函数构建对象"><a href="#使用构造函数构建对象" class="headerlink" title="使用构造函数构建对象"></a>使用构造函数构建对象</h4><p>可以使用构造函数来创建一个对象。构造函数的命名方式可以为类名或类名<code>.</code>标识符的形式。例如下述代码分别使用<code>Point()</code>和<code>Point.fromJson()</code>两种构造器来创建<code>Point</code>对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>以下代码具有相同的效果，构造函数名前面的的<code>new</code>关键字是可选的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>一些类提供了常量构造函数。使用常量构造函数，在构造函数名之前加 <code>const</code>关键字，来创建编译时常量时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">const</span> ImmutablePoint(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>两个使用相同构造函数相同参数值构造的编译时常量是同一个对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// 它们是同一个实例 (They are the same instance!)</span></span><br></pre></td></tr></table></figure><p>根据使用常量上下文的场景，你可以省略掉构造函数或字面量前的<code>const</code> 关键字。例如下面的例子中我们创建了一个常量<code>Map</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里有很多 const 关键字</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">&#x27;point&#x27;</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">&#x27;line&#x27;</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), <span class="keyword">const</span> ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上下文，你可以只保留第一个<code>const</code>关键字，其余的全部省略：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要一个 const 关键字，其它的则会隐式地根据上下文进行关联。</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">&#x27;point&#x27;</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">&#x27;line&#x27;</span>: [ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是如果无法根据上下文判断是否可以省略<code>const</code>，则不能省略掉 <code>const</code>关键字，否则将会创建一个<strong>非</strong>常量对象 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 创建一个常量 (Creates a constant)</span></span><br><span class="line"><span class="keyword">var</span> b = ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 不会创建一个常量</span></span><br><span class="line"><span class="keyword">assert</span>(!identical(a, b)); <span class="comment">// 这两变量并不相同 </span></span><br></pre></td></tr></table></figure><h4 id="获取对象的类型"><a href="#获取对象的类型" class="headerlink" title="获取对象的类型"></a>获取对象的类型</h4><p>可以使用<code>Object</code>对象的<code>runtimeType</code>属性在运行时获取一个对象的类型，该对象类型是<code>Type</code>的实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>声明一个与类名一样的函数即可声明一个构造函数（对于命名式构造函数 还可以添加额外的标识符)。大部分的构造函数形式是生成式构造函数，其用于创建一个类的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  Point(<span class="built_in">double</span> x, <span class="built_in">double</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还会有更好的方式来实现此逻辑，敬请期待。</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>this</code> 关键字引用当前实例。<br>对于大多数编程语言来说在构造函数中为实例变量赋值的过程都是类似的，而<code>Dart</code>则提供了一种特殊的语法糖来简化该步骤：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line">  <span class="comment">// 在构造函数体执行前用于设置 x 和 y 的语法糖。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h5><p>如果你没有声明构造函数，那么<code>Dart</code>会自动生成一个无参数的构造函数并且该构造函数会调用其父类的无参数构造方法。</p><h5 id="构造函数不被继承"><a href="#构造函数不被继承" class="headerlink" title="构造函数不被继承"></a>构造函数不被继承</h5><p>子类不会继承父类的构造函数，如果子类没有声明构造函数，那么只会有一个默认无参数的构造函数。</p><h5 id="命名式构造函数"><a href="#命名式构造函数" class="headerlink" title="命名式构造函数"></a>命名式构造函数</h5><p>可以为一个类声明多个命名式构造函数来表达更明确的意图：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名式构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数是不能被继承的，这将意味着子类不能继承父类的命名式构造函数，如果你想在子类中提供一个与父类命名构造函数名字一样的命名构造函数，则需要在子类中显式地声明。</p><h5 id="调用父类非默认构造函数"><a href="#调用父类非默认构造函数" class="headerlink" title="调用父类非默认构造函数"></a>调用父类非默认构造函数</h5><p>默认情况下，子类的构造函数会调用父类的匿名无参数构造方法，并且该调用会在子类构造函数的函数体代码执行前，如果子类构造函数还有一个初始化列表，那么该初始化列表会在调用父类的该构造函数之前被执行，总的来说，这三者的调用顺序如下：</p><ol><li>初始化列表</li><li>父类的无参数构造函数</li><li>当前类的构造函数</li></ol><p>如果父类没有匿名无参数构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定一个父类的构造函数只需在构造函数体前使用<code>:</code>指定。</p><p>因为参数会在子类构造函数被执行前传递给父类的构造函数，因此该参数也可以是一个表达式，比如一个函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(defaultData);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>除了调用父类构造函数之外，还可以在构造函数体执行之前初始化实例变量。每个实例变量之间使用逗号分隔。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用初始化列表在构造函数体执行前设置实例变量。</span></span><br><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">double</span>&gt; json)</span><br><span class="line">    : x = json[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">      y = json[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发模式下，你可以在初始化列表中使用<code>assert</code>来验证输入数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.withAssert(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : <span class="keyword">assert</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.withAssert(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h5><p>有时候类中的构造函数会调用类中其它的构造函数，该重定向构造函数没有函数体，只需在函数签名后使用<code>:</code>指定需要重定向到的其它构造函数即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该类的主构造函数。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 委托实现给主构造函数。</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">double</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h5><p>如果类生成的对象都是不会变的，那么可以在生成这些对象时就将其变为编译时常量。你可以在类的构造函数前加上<code>const</code>关键字并确保所有实例变量均为<code>final</code>来实现该功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造函数创建的实例并不总是常量。</p><h5 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h5><p>使用<code>factory</code>关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是会返回新的实例对象。例如，工厂构造函数可能会从缓存中返回一个实例，或者返回一个子类型的实例。</p><p>在如下的示例中，<code>Logger</code>的工厂构造函数从缓存中返回对象，和 <code>Logger.fromJson</code>工厂构造函数从<code>JSON</code>对象中初始化一个最终变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache 变量是库私有的，因为在其名字前面有下划线。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache.putIfAbsent(</span><br><span class="line">        name, () =&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; json) &#123;</span><br><span class="line">    <span class="keyword">return</span> Logger(json[<span class="string">&#x27;name&#x27;</span>].toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂构造函的调用方式与其他构造函数一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logMap = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;UI&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> loggerJson = Logger.fromJson(logMap);</span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>使用关键字<code>abstract</code> 标识类可以让该类成为抽象类，抽象类将无法被实例化。抽象类常用于声明接口方法、有时也会有具体的方法实现。如果想让抽象类同时可被实例化，可以为其定义工厂构造函数。</p><p>抽象类常常会包含抽象方法。下面是一个声明具有抽象方法的抽象类示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类被声明为抽象的，因此它不能被实例化。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义构造函数、字段、方法等……</span></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h4><p>每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。如果想要创建一个<code>A</code>类支持调用<code>B</code>类的API且不想继承<code>B</code>类，则可以实现<code>B</code>类的接口。</p><p>一个类可以通过关键字<code>implements</code>来实现一个或多个接口并实现每个接口定义的 API：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 类的隐式接口中包含 greet() 方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// _name 变量同样包含在接口中，但它只是库内可见的。</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数不在接口中。</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// greet() 方法在接口中。</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;你好，<span class="subst">$who</span>。我是<span class="subst">$_name</span>。&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口的一个实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;你好<span class="subst">$who</span>。你知道我是谁吗？&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;小芳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">&#x27;小芸&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要实现多个类接口，可以使用逗号分割每个接口类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展一个类"><a href="#扩展一个类" class="headerlink" title="扩展一个类"></a>扩展一个类</h4><p>使用<code>extends</code>关键字来创建一个子类，并可使用<code>super</code>关键字引用一个父类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Mixin-为类添加功能"><a href="#使用-Mixin-为类添加功能" class="headerlink" title="使用 Mixin 为类添加功能"></a>使用 Mixin 为类添加功能</h4><p><code>Mixin</code>是一种在多重继承中复用某个类中代码的方法模式。<br>使用<code>with</code>关键字并在其后跟上<code>Mixin</code>类的名字来使用<code>Mixin</code>模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个类继承自<code>Object</code>并且不为该类定义构造函数，这个类就是 <code>Mixin</code>类，除非你想让该类与普通的类一样可以被正常地使用，否则可以使用关键字<code>mixin</code>替代<code>class</code>让其成为一个单纯的<code>Mixin</code>类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用关键字<code>on</code>来指定哪些类可以使用该<code>Mixin</code>类，比如有 <code>Mixin</code>类 <code>A</code>，但是<code>A</code>只能被<code>B</code>类使用，则可以这样定义 `A：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musician &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerDancer</span> <span class="keyword">extends</span> <span class="title">Musician</span> <span class="title">with</span> <span class="title">MusicalPerformer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Extension-方法"><a href="#Extension-方法" class="headerlink" title="Extension 方法"></a>Extension 方法</h4><p>Dart 2.7 中引入的<code>Extension</code>方法是向现有库添加功能的一种方式。<br>这里是一个在 String 中使用 <code>extension </code>方法的样例，我们取名为 <code>parseInt()</code>，它在 <code>string_apis.dart</code> 中定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> NumberParsing <span class="keyword">on</span> <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> parseInt() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> parseDouble() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">double</span>.parse(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>string_apis.dart</code>里面的<code>parseInt()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;string_apis.dart&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.padLeft(<span class="number">5</span>)); <span class="comment">// Use a String method.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.parseInt()); <span class="comment">// Use an extension method.</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart类 </tag>
            
            <tag> Dart运算符 </tag>
            
            <tag> Dart Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费送书啦！细数Github大神们的开源书籍！[二]</title>
      <link href="tips-github-free-books-4.html"/>
      <url>tips-github-free-books-4.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="计算机软件设计"><a href="#计算机软件设计" class="headerlink" title="计算机软件设计"></a>计算机软件设计</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_3.jpeg" /></p><p align="center">《软件设计的哲学》</p><blockquote><p>《软件设计的哲学》斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。按照 IT 图书出版的惯例，如果冠名为“实践”，书中内容关注的是某项技术的细节和技巧；冠名为“艺术”，内容可能是记录一件优秀作品的设计过程和经验；而冠名为“哲学”，则是一些通用的原则和方法论，这些原则方法论串起来，能够形成一个体系。正如”知行合一”、“世界是由原子构成的”、“我思故我在”，这些耳熟能详的句子能够一定程度上代表背后的人物和思想。用一句话概括《A Philosophy of Software Design》，软件设计的核心在于降低复杂性。<br><a href="https://github.com/gdut-yy/A-Philosophy-of-Software-Design-zh">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_17.jpeg" /></p><p align="center">《设计数据密集型应用》</p><blockquote><p>《设计数据密集型应用》现今，尤其是在互联网领域，大多数应用都属于数据密集型应用。本书从底层数据结构到顶层架构设计，将数据系统设计中的精髓娓娓道来。其中的宝贵经验无论是对架构师，DBA、还是后端工程师、甚至产品经理都会有帮助。这是一本理论结合实践的书，书中很多问题，译者在实际场景中都曾遇到过，读来让人击节扼腕。如果能早点读到这本书，该少走多少弯路啊！这也是一本深入浅出的书，讲述概念的来龙去脉而不是卖弄定义，介绍事物发展演化历程而不是事实堆砌，将复杂的概念讲述的浅显易懂，但又直击本质不失深度。每章最后的引用质量非常好，是深入学习各个主题的绝佳索引。<br><a href="https://github.com/Vonng/ddia">领取地址</a></p></blockquote><p align="center">《操作系统的基本原理与简单实现》</p><blockquote><p>《操作系统的基本原理与简单实现》<br>早期开放开源的UNIX操作系统和MIT教授 Frans Kaashoek 等基于UNIX v6设计的xv6操作系统给了我们启发：对一个计算机专业的本科生而言，设计实现一个操作系统有挑战但是可行！但x86相对封闭&amp;复杂和有一定历史包袱的CPU硬件接口给OS学习带来了一定的挑战。1980年前后，UC Berkeley的Dave Patterson主导了Berkeley RISC项目并设计了其第一代的处理器RISC I，并在2014年发展到了开放&amp;开源的第五代指令集架构RISC-V。本书想进行这样的教学尝试，以操作系统基本原理为教学引导，以简洁的RISC-V CPU为底层硬件基础，设计并实现一个微型但全面的“麻雀”操作系统—ucore。期望能够采用简化的计算机硬件为基础，以操作系统的基本概念和核心原理为实践指导，逐步解析操作系统各种知识点和对应的实验，做到有“理”可循和有“码”可查，最终让读者了解和掌握操作系统的原理、设计与实现。<br><a href="https://github.com/chyyuu/simple_os_book">领取地址</a></p></blockquote><h3 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_7.jpeg" /></p><p align="center">《Real-Time Communication with WebRTC》</p><blockquote><p>《Real-Time Communication with WebRTC》<br>在浏览器中提供丰富的音频和视频实时通信和点对点数据交换，不需要私有插件。这个简明的实践指南向您展示了如何使用新兴的Web实时通信(WebRTC)技术来构建一个浏览器到浏览器的应用程序。<br>作者通过实例学习的方法非常适合那些希望理解实时通信的 web 程序员，以及不熟悉 HTML5 和基于 javascript 的客户端-服务器 web 编程的电信架构师。<br><a href="https://github.com/a-wing/webrtc-book-cn">领取地址</a></p></blockquote><p align="center">《SDN网络指南》</p><blockquote><p>SDN（Software Defined Networking）作为当前最重要的热门技术之一，目前已经普遍得到大家的共识。有关SDN的资料和书籍非常丰富，但入门和学习SDN依然是非常困难。本书整理了SDN实践中的一些基本理论和实践案例心得，希望能给大家带来启发，也欢迎大家关注和贡献。<br><a href="https://github.com/feiskyer/sdn-handbook">领取地址</a></p></blockquote><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_17.jpeg" /></p><p align="center">《Prometheus 操作指南》</p><blockquote><p>这里假定你已经对Linux系统以及Docker技术有一定的基本认识，也可能使用过像Java，Golang这样的编程语言，在本书中我们不会事无巨细的讲述所有事。<br><a href="https://github.com/yunlzheng/prometheus-book">领取地址</a></p></blockquote><h4 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h4><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_12.png" /></p><p align="center">《Python Data Science Handbook》</p><blockquote><p>英文原版《Python Data Science Handbook》，该书对于希望或已经从事数据科学相关工作的 Python 工程师而言是重要的学习手册。<br><a href="https://github.com/jakevdp/PythonDataScienceHandbook">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_13.png" /></p><p align="center">《You-Dont-Know-JS》</p>  <blockquote><p>深入探讨 JavaScript 语言核心机制的书籍，适用于深入学习 JS。<br><a href="https://github.com/getify/You-Dont-Know-JS">领取地址</a></p></blockquote><h4 id="获取更多"><a href="#获取更多" class="headerlink" title="获取更多"></a>获取更多</h4><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_10.jpg" /></p><p align="center">《JAVA编程思想 第五版》</p><blockquote><p>本书原作者为 [美] Bruce Eckel，即《Java 编程思想》的作者。<br>本书是事实上的 《Java 编程思想》第五版。《Java 编程思想》第四版基于 JAVA 5 版本；《On Java 8》 基于 JAVA 8 版本。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>Java5</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_11.jpg" /></p><p align="center">《渗透测试实战第三版》</p><blockquote><p>这本书是 《The Hacker Playbook》 的第三版，通常我们也说它是红队版。因为本书是以红蓝对抗中红队的视角来撰写的。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>Hacker</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_14.png" /></p><p align="center">《动手学深度学习》</p><blockquote><p>本开源项目代表了我们的一种尝试：我们将教给读者概念、背景知识和代码；我们将在同一个地方阐述剖析问题所需的批判性思维、解决问题所需的数学知识，以及实现解决方案所需的工程技能。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>深度学习</strong></p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-10】Flutter手把手教程Dart语言——运算符</title>
      <link href="dart-operator-1-10.html"/>
      <url>dart-operator-1-10.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。Dart语言内置了丰富的运算符，并提供了以下类型的运算符：<strong>算术运算符、关系运算符、类型判断运算符、赋值运算符、逻辑运算符、按位和移位运算符、条件表达式、级联运算符以及其他运算符</strong>。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th>算数运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>- 表达式</td><td>一元负, 也可以作为反转（反转表达式的符号）</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>~/</td><td>除并取整</td></tr><tr><td>%</td><td>取模</td></tr><tr><td>示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> + <span class="number">3</span> == <span class="number">5</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> - <span class="number">3</span> == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> * <span class="number">3</span> == <span class="number">6</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> / <span class="number">2</span> == <span class="number">2.5</span>); <span class="comment">// 结果是一个浮点数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> ~/ <span class="number">2</span> == <span class="number">2</span>); <span class="comment">// 结果是一个整数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> % <span class="number">2</span> == <span class="number">1</span>); <span class="comment">// 取余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;5/2 = <span class="subst">$&#123;<span class="number">5</span> ~/ <span class="number">2</span>&#125;</span> r <span class="subst">$&#123;<span class="number">5</span> % <span class="number">2</span>&#125;</span>&#x27;</span> == <span class="string">&#x27;5/2 = 2 r 1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Dart 还支持自增自减运算符：</p><table><thead><tr><th>自增自减运算符</th><th>描述</th></tr></thead><tbody><tr><td>++ var</td><td>var = var + 1 (表达式的值为 var + 1)</td></tr><tr><td>var ++</td><td>var = var + 1 (表达式的值为 var)</td></tr><tr><td>– var</td><td>var = var – 1 (表达式的值为 var – 1)</td></tr><tr><td>var –</td><td>var = var – 1 (表达式的值为 var)</td></tr><tr><td>示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = ++a; <span class="comment">// 在 b 赋值前将 a 增加 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// 1 == 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a++; <span class="comment">// 在 b 赋值后将 a 增加 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// 1 != 0</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = --a; <span class="comment">// 在 b 赋值前将 a 减少 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// -1 == -1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a--; <span class="comment">// 在 b 赋值后将 a 减少 1。</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// -1 != 0</span></span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th>关系运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>相等</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>要判断两个对象 x 和 y 是否表示相同的事物使用 <code>==</code> 即可。（在极少数情况下，可能需要使用 <code>identical()</code> 函数来确定两个对象是否完全相同）。</td><td></td></tr><tr><td>下面是 <code>==</code> 运算符的一些规则：</td><td></td></tr></tbody></table><ol><li><p>假设有变量 <code>x</code> 和 <code>y</code>，且 <code>x</code> 和 <code>y</code> 至少有一个为 <code>null</code>，则当且仅当 <code>x</code> 和 <code>y</code> 均为 <code>null</code> 时 <code>x == y</code> 才会返回 <code>true</code>，否则只有一个为 <code>null</code> 则返回 <code>false</code>。</p></li><li><p><code>x.==(y)</code> 将会返回值，这里不管有没有<code>y</code>，即 <code>y</code> 是可选的。也就是说 <code>==</code> 其实是 <code>x</code> 中的一个方法，并且可以被重写。</p></li></ol><p>下面的代码给出了每一种关系运算符的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> == <span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> != <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">3</span> &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> &lt; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">3</span> &gt;= <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> &lt;= <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="类型判断运算符"><a href="#类型判断运算符" class="headerlink" title="类型判断运算符"></a>类型判断运算符</h4><p><code>as</code>、<code>is</code>、<code>is!</code> 运算符是在运行时判断对象类型的运算符。<br>|  类型判断运算符   | 描述  |<br>|  —-  | —-  |<br>|as|类型转换（也用作指定类前缀)）|<br>|is    |如果对象是指定类型则返回 true|<br>|is! |如果对象是指定类型则返回 false|</p><p>当且仅当 obj对象 实现了 <code>T</code> 的接口，obj对象 <code>is T</code> 才是 <code>true</code>。例如 obj对象 <code>is Object</code> 总为 <code>true</code>，因为所有类都是 <code>Object</code> 的子类。</p><p>仅当你确定这个对象是该类型的时候，你才可以使用 <code>as</code> 操作符可以把对象转换为特定的类型。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果你不确定这个对象类型是不是 <code>T</code>，请在转型前使用 <code>is T</code> 检查类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">  <span class="comment">// 类型检查</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 <code>as</code> 运算符进行缩写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>可以使用 <code>=</code> 来赋值，同时也可以使用 <code>??=</code> 来为值为 <code>null</code> 的变量赋值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 value 赋值给 a (Assign value to a)</span></span><br><span class="line">a = value;</span><br><span class="line"><span class="comment">// 当且仅当 b 为 null 时才赋值</span></span><br><span class="line">b ??= value;</span><br></pre></td></tr></table></figure><p>像 <code>+=</code> 这样的赋值运算符将算数运算符和赋值运算符组合在了一起。<br>|         |      |       |       |       |       |<br>|  —-  | —-  | —-  | —-  | —-  | —-  |<br>|=    |–=    |/=|%=|    &gt;&gt;=|    ^=|<br>|+=    |*=| ~/=|&lt;&lt;=    |&amp;=|    =|<br>下面的例子展示了如何使用赋值以及复合赋值运算符：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a += b  <span class="comment">//就 等同于 a = a + b</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 使用 = 赋值 (Assign using =)</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// 赋值并做乘法运算 Assign and multiply: a = a * 3</span></span><br><span class="line"><span class="keyword">assert</span>(a == <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>类型判断运算符</th><th>描述</th></tr></thead><tbody><tr><td>!表达式</td><td>对表达式结果取反（即将 true 变为 false，false 变为 true）</td></tr><tr><td>&#124;&#124;</td><td>逻辑或</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>下面是使用逻辑表达式的示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!done &amp;&amp; (col == <span class="number">0</span> || col == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按位和移位运算符"><a href="#按位和移位运算符" class="headerlink" title="按位和移位运算符"></a>按位和移位运算符</h4><table><thead><tr><th>按位和移位运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>&#124;</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>~ 表达式</td><td>按位取反（即将 “0” 变为 “1”，“1” 变为 “0”）</td></tr><tr><td>&lt;&lt;</td><td>位左移</td></tr><tr><td>&gt;&gt;</td><td>位右移</td></tr><tr><td>下面是使用按位和移位运算符的示例：</td><td></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> value = <span class="number">0x22</span>;</span><br><span class="line"><span class="keyword">final</span> bitmask = <span class="number">0x0f</span>;</span><br><span class="line"><span class="keyword">assert</span>((value &amp; bitmask) == <span class="number">0x02</span>); <span class="comment">// 按位与 (AND)</span></span><br><span class="line"><span class="keyword">assert</span>((value &amp; ~bitmask) == <span class="number">0x20</span>); <span class="comment">// 取反后按位与 (AND NOT)</span></span><br><span class="line"><span class="keyword">assert</span>((value | bitmask) == <span class="number">0x2f</span>); <span class="comment">// 按位或 (OR)</span></span><br><span class="line"><span class="keyword">assert</span>((value ^ bitmask) == <span class="number">0x2d</span>); <span class="comment">// 按位异或 (XOR)</span></span><br><span class="line"><span class="keyword">assert</span>((value &lt;&lt; <span class="number">4</span>) == <span class="number">0x220</span>); <span class="comment">// 位左移 (Shift left)</span></span><br><span class="line"><span class="keyword">assert</span>((value &gt;&gt; <span class="number">4</span>) == <span class="number">0x02</span>); <span class="comment">// 位右移 (Shift right)</span></span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p><code>条件 ? 表达式 1 : 表达式 2</code> ：如果条件为 <code>true</code>，执行<code>表达式 1</code>并返回执行结果，否则执行<code>表达式 2</code> 并返回执行结果。<br><code>表达式 1 ?? 表达式 2</code>：如果<code>表达式 1</code> 为非 null 则返回其值，否则执行<code>表达式 2</code> 并返回其值。<br>如果赋值是根据布尔表达式则考虑使用 <code>?:</code>  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visibility = isPublic ? <span class="string">&#x27;public&#x27;</span> : <span class="string">&#x27;private&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果赋值是根据判定是否为 <code>null</code> 则考虑使用 <code>??</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">&#x27;Guest&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述示例还可以写成至少下面两种不同的形式，只是不够简洁：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对使用 ?: 运算符来说稍微长了点。(Slightly longer version uses ?: operator).</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name != <span class="keyword">null</span> ? name : <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 if-else 则更长。</span></span><br><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="级联运算符"><a href="#级联运算符" class="headerlink" title="级联运算符"></a>级联运算符</h4><p>级联运算符<code>（..）</code>可以让你在同一个对象上连续调用多个对象的变量或方法。<br>比如下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>) <span class="comment">// 获取对象 (Get an object).</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span> <span class="comment">// 使用对象的成员 (Use its members).</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure><p>第一个方法 <code>querySelector</code> 返回了一个 <code>Selector</code> 对象，后面的级联操作符都是调用这个 <code>Selector</code> 对象的成员并忽略每个操作的返回值。</p><p>上面的代码相当于：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#confirm&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure><p>级联运算符可以嵌套，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>在返回对象的函数中谨慎使用级联操作符。例如，下面的代码是错误的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb.write(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  ..write(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 出错：void 对象中没有方法 write (Error: method &#x27;write&#x27; isn&#x27;t defined for &#x27;void&#x27;).</span></span><br></pre></td></tr></table></figure><p>上述代码中的 <code>sb.write()</code> 方法返回的是 <code>void</code>，返回值为 <code>void</code> 的方法则不能使用级联运算符。</p><h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>大多数其它的运算符，已经在其它的示例中使用过：<br>| 运算符   | 名字  |  描述 |<br>| —   | —  |  — |<br>|()    |使用方法    |代表调用一个方法|<br>|[]    |访问 List    |访问 List 中特定位置的元素|<br>|.    |访问成员|    成员访问符|<br>|?.    |条件访问成员|    与上述成员访问符类似，但是左边的操作对象不能为 null，例如 foo?.bar，如果 foo 为 null 则返回 null ，否则返回 bar|</p><p>更多关于 <code>., ?.</code> 和 <code>..</code> 运算符介绍，会在下一章<strong>Flutter手把手教程Dart语言——类</strong>中讲解.</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart语言 </tag>
            
            <tag> Flutter教程 </tag>
            
            <tag> Dart运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>artipub点击&quot;更新cookie状态&quot;无任何反应</title>
      <link href="tips-artipub-cookies-6.html"/>
      <url>tips-artipub-cookies-6.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="artipub"><a href="#artipub" class="headerlink" title="artipub"></a>artipub</h3><p><a href="https://github.com/crawlab-team/artipub">ArtiPub</a> (Article Publisher 的简称，意为 “文章发布者”) 是一款开源的一文多发平台，可以帮助文章作者将编写好的文章自动发布到掘金、SegmentFault、CSDN、知乎、开源中国等技术媒体平台。</p><p>点击”更新cookie状态”按钮之后错误如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 954)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 956)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 958)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 960)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 962)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 964)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 966)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 968)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 970)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 972)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 974)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 976)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 978)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 980)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 982)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 984)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 400</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 986)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 988)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 990)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 992)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 994)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 996)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 998)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503</span><br><span class="line">    at createError (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/createError.js:16:15)</span><br><span class="line">    at settle (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/core/settle.js:17:12)</span><br><span class="line">    at IncomingMessage.handleStreamEnd (/Users/Joker/Desktop/artipub/artipub/node_modules/axios/lib/adapters/http.js:244:11)</span><br><span class="line">    at IncomingMessage.emit (events.js:228:7)</span><br><span class="line">    at endReadableNT (_stream_readable.js:1185:12)</span><br><span class="line">    at processTicksAndRejections (internal/process/task_queues.js:81:21)</span><br><span class="line">(node:72715) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="keyword">function</span> without a catch block, or by rejecting a promise <span class="built_in">which</span> was not handled with .catch(). (rejection id: 1000)</span><br></pre></td></tr></table></figure><h4 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h4><ul><li>macOS 10.15.5</li><li>已安装mogodb并已启动</li><li>已启动<code>npm run start:frontend</code></li><li>登录助手已安装正确<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4>这是因为执行<code>npm run start:backend</code>命令时没有添加<code>sudo</code>权限的问题。<br>使用<code>sudo npm run start:backend</code>启动，然后再点击”更新cookies”状态就可以了。</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-8】Python手把手教程之——管理列表List</title>
      <link href="python-handle-list-1-8.html"/>
      <url>python-handle-list-1-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><p>在<a href="http://fulade.me/python-list-7.html">上一节</a>我们学习了如何创建一个列表，在列表里面插入、删除数据等操作。<br>本节我们学习如何管理列表。</p><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>在日常开发中，我们经常需要遍历列表的所有元素，对每个元素执行相同的操作。例如，在管理商场的蔬菜时候，需要给所有的蔬菜商品都打7折，并重新生成价格。当我们需要对列表中的每个元素都执行相同的操作时，可使用Python中的<code>for</code>循环。</p><p>假设我们有一个蔬菜名单，需要将其中每种蔬菜的名字都打印出来。为此，我们可以采用元素下标的方式分别获取名单中的每个名字，但这种做法会导致多个问题。例如，如果名单很长，将包含大量重复的代码。另外，每当名单的长度发生变化时，都必须修改代码。通过使用<code>for</code>循环，可让<code>Python</code>去处理这些问题。<br>下面使用for循环来打印蔬菜单中的所有名字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>这行代码让Python从列表<code>vegetables</code>中取出一个名字，并将其存储在变量<code>name</code>中。最后，我们让Python打印前面存储的变量<code>name</code>中的名字。这样，对于列表中的每个名字，Python都将重复执行<code>print(name)</code>代码。你可以这样解读这些代码：对于列表<code>vegetables</code>中的每种蔬菜，都将其名字打印出来。输出很简单，就是列表中所有蔬菜的姓名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">potato</span><br><span class="line">tomato</span><br><span class="line">onion</span><br></pre></td></tr></table></figure><h5 id="详解遍历列表执行过程"><a href="#详解遍历列表执行过程" class="headerlink" title="详解遍历列表执行过程"></a>详解遍历列表执行过程</h5><p>循环这种概念很重要，因为它是让计算机自动完成重复工作的常见方式之一。例如，在前面的代码中使用的简单循环中，Python将首先读取其中的第一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br></pre></td></tr></table></figure><p>这行代码让Python获取列表<code>vegetables</code>中的第一个值<code>potato</code>，并将其存储到变量<code>name</code> 中。接下来，Python读取下一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name) </span><br></pre></td></tr></table></figure><p>它让Python打印<code>vegetables</code>的值<code>potato</code>。由于该列表还包含其他值，Python返回到循环的第一行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br></pre></td></tr></table></figure><p>Python获取列表中的下一个名字<code>tomato</code>，并将其存储到变量<code>name</code>中，再执行下面这行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(name) </span><br></pre></td></tr></table></figure><p>Python再次打印变量<code>vegetables</code>的值<code>tomato</code>。<br>接下来，Python再次执行整个循环，对列表中的最后一个值<code>onion</code>进行处理。<br>至此，列表中没有其他的值了，因此Python接着执行程序的下一行代码。在这个示例中，<code>for</code>循环后面没有其他的代码，因此程序就此结束。<br>刚开始使用循环时需要牢记，对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python就重复执行指定的步骤一百万次，且通常速度非常快。<br>另外，编写<code>for</code>循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。比如说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dog <span class="keyword">in</span> dogs:</span><br><span class="line"><span class="keyword">for</span> cat <span class="keyword">in</span> cats:</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br></pre></td></tr></table></figure><p>这些写法都是可以的。</p><h5 id="在For循环中做更多操作"><a href="#在For循环中做更多操作" class="headerlink" title="在For循环中做更多操作"></a>在For循环中做更多操作</h5><p>在for循环中，可以获取到每一个元素，可对每个元素执行任何操作。比如说我们对每一种蔬菜都输出一句话。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br></pre></td></tr></table></figure><p>相比于前一个示例，唯一的不同是对于每种蔬菜，都打印了一条以其名字为抬头的消息。这个循环第一次迭代时，变量<code>name</code>的值为<code>potato</code>，因此Python打印的第一条消息的抬头为<code>potato</code>。第二次迭代时，消息的抬头为<code>tomato</code>，而第三次迭代时，抬头为<code>onion</code>。<br>下面的输出表明，对于列表中的每种蔬菜，都打印了一条个性化消息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br></pre></td></tr></table></figure><p>在for循环中，想包含多少行代码都可以。在代码行<code>for name in vegetables</code>后面，每个<strong>缩进的</strong>代码行都是循环的一部分，且将针对列表中的每个值都执行一次。因此，可对列表中的每个值执行任意次数的操作。<br>下面再添加一行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">    print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>由于两条<code>print</code>语句都缩进了，因此它们都将针对列表中的每位蔬菜都执行一次。输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">potato <span class="keyword">is</span> a vegetable!</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> a vegetable!</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中，想包含多少行代码都可以。这种方式在开发过程中很有用。</p><h3 id="避免缩进错误"><a href="#避免缩进错误" class="headerlink" title="避免缩进错误"></a>避免缩进错误</h3><p>Python根据<strong>缩进</strong>来判断代码行与前一个代码行的关系。在前面的示例中，对每种蔬菜的输出代码行是<code>for</code>循环的一部分，因为它们缩进了。Python通过使用缩进让代码更易读。<br>简单地说，它要求你使用缩进让代码整洁而结构清晰。在较长的Python程序中，你将看到缩进程度各不相同的代码块，这让你对程序的组织结构有大致的认识。 当你开始使用缩进时，需要注意一些常见的缩进错误。<br>例如，有时候，程序员会将不需要缩进的代码块缩进，而对于必须缩进的代码块却忘了缩进。通过查看这些错误示例，有助于我们以后避开它们，以及在它们出现在程序中时进行修复。下面来看一些较为常见的缩进错误。</p><h5 id="忘记缩进"><a href="#忘记缩进" class="headerlink" title="忘记缩进"></a>忘记缩进</h5><p>对于位于<code>for</code>语句后面且属于循环组成部分的代码行，一定要缩进。如果你忘记缩进，运行会直接报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><p><code>print</code>语句应缩进却没有缩进。Python没有找到期望缩进的代码块时，会让你知道哪行代码有问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span></span><br><span class="line">    print(name)</span><br><span class="line">        ^</span><br><span class="line">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure><p>通常，将紧跟在for语句后面的代码行缩进，可消除这种缩进错误。</p><h5 id="忘记缩进额外的代码行"><a href="#忘记缩进额外的代码行" class="headerlink" title="忘记缩进额外的代码行"></a>忘记缩进额外的代码行</h5><p>有时候，循环能够运行而不会报告错误，但结果可能会出乎意料。试图在循环中执行多项任务，却忘记缩进其中的一些代码行时，就会出现这种情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第二个<code>print</code>语句原本需要缩进，但Python发现<code>for</code>语句后面有一行代码是缩进的，因此它没有报告错误。最终的结果是，对于列表中的每种蔬菜，都执行了第一条<code>print</code>语句，因为它缩进了；而第二条<code>print</code>语句没有缩进，因此它只在循环结束后执行一次。由于变量 <code>name</code> 的终值为<code>onion</code>，因此只有一条输出了<code>onion is a vegetable!</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br></pre></td></tr></table></figure><p>这是一个逻辑错误。从语法上看，这些代码是没问题的，但由于存在逻辑错误，结果并不符合预期。如果你预期某项操作将针对每个列表元素都执行一次，但它却只执行了一次，请确定是否需要将一行或多行代码缩进。</p><h5 id="不必要的缩进"><a href="#不必要的缩进" class="headerlink" title="不必要的缩进"></a>不必要的缩进</h5><p>如果你不小心缩进了无需缩进的代码行，同样运行的时候也会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span></span><br><span class="line">    print(message)</span><br></pre></td></tr></table></figure><p><code>print</code>语句无需缩进，因为它并不属于前一行代码，运行的时候会帮我们指出这种错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    print(message)</span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure><p>为避免意外缩进错误，请只缩进需要缩进的代码。在前面编写的程序中，只有要在<code>for</code>循环中对每个元素执行的代码就需要缩进。</p><h5 id="循环后不必要的缩进"><a href="#循环后不必要的缩进" class="headerlink" title="循环后不必要的缩进"></a>循环后不必要的缩进</h5><p>如果我们不小心缩进了应在循环结束后执行的代码，这些代码将针对每个列表元素重复执行。 在有些情况下，这可能导致Python报告语法错误，但在大多数情况下，这只会导致逻辑错误。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables:</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br><span class="line">    print(name + <span class="string">&#x27; is a vegetable!&#x27;</span>)</span><br><span class="line">    <span class="comment">## 这一行代码被缩进</span></span><br><span class="line">    print(<span class="string">&#x27;There are three kinds of vegetables.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么输出就会变成以下这个样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">potato <span class="keyword">is</span> good !</span><br><span class="line">potato <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables</span><br><span class="line">tomato <span class="keyword">is</span> good !</span><br><span class="line">tomato <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables</span><br><span class="line">onion <span class="keyword">is</span> good !</span><br><span class="line">onion <span class="keyword">is</span> a vegetable!</span><br><span class="line">There are three kinds of vegetables.</span><br></pre></td></tr></table></figure><p>这也是一个逻辑错误。Python不知道你的本意，只要代码符合语法，它就会运行。所以我们应该时刻保持警惕，不要用错了缩进。</p><h5 id="遗漏了冒号"><a href="#遗漏了冒号" class="headerlink" title="遗漏了冒号"></a>遗漏了冒号</h5><p><code>for</code>语句末尾的冒号告诉Python，下一行是循环的第一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables</span><br><span class="line">    print(name + <span class="string">&#x27; is good !&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> vegetables</span><br><span class="line">                         ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>如果你不小心遗漏了冒号，如上所示，将导致语法错误，因为Python不知道你意欲何为。这种错误虽然易于消除，但并不那么容易发现。</p><h3 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h3><p>Python函数<code>range()</code>让你能够轻松地生成一系列的数字。例如，可以像下面这样使用函数<code>range()</code>来打印一系列的数字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>上述代码好像应该打印数字1~5，但实际上它不会打印数字5:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>range()</code>只是打印数字1<del>4，这是你在编程语言中经常看到的差一行为的结果。函数<code>range()</code>让Python从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值(这里为5)。<br>要打印数字1</del>5，需要使用<code>range(1,6)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>这样，输出将从1开始，到5结束:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>使用<code>range()</code>时，如果输出不符合预期，请尝试将指定的值加<code>1</code>或减<code>1</code>。</p><h5 id="使用range-创建数字列表"><a href="#使用range-创建数字列表" class="headerlink" title="使用range()创建数字列表"></a>使用range()创建数字列表</h5><p>要创建数字列表，可使用函数<code>list()</code>将<code>range()</code>的结果直接转换为列表。如果将<code>range()</code>作为<code>list()</code>的参数，输出将为一个数字列表。<br>在上面的示例中，我们打印了一系列数字。要将这些数字转换为一个列表，可使用<code>list():</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>使用函数<code>range()</code>时，还可指定<strong>步长</strong>。例如，下面的代码打印1~10内的偶数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>)) </span><br><span class="line">print(even_numbers)</span><br></pre></td></tr></table></figure><p>在这个示例中，函数<code>range()</code>从2开始数，然后不断地加2，直到达到或超过终值(11)，因此 输出如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>使用函数<code>range()</code>几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数(即1~10)的平方呢？在Python中，两个星号<code>**</code>表示乘方运算。下面的代码演示如何将前10个整数的平方加入到一个列表中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    square = value**<span class="number">2</span></span><br><span class="line">    squares.append(square)</span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure><p>首先，我们创建了一个空列表；接下来，使用函数<code>range()</code>让Python遍历1~10的值。在循环中，计算当前值的平方，并将结果存储到变量square中。然后，将新计算得到的平方值附加到列表<code>squares</code>末尾。最后，循环结束后，打印列表<code>squares</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h5 id="对数字列表执行简单的统计计算"><a href="#对数字列表执行简单的统计计算" class="headerlink" title="对数字列表执行简单的统计计算"></a>对数字列表执行简单的统计计算</h5><p>有几个专门用于处理数字列表的Python函数。例如，你可以轻松地找出数字列表的最大值、最小值和总和:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>] </span><br><span class="line"><span class="comment">### 输出最小值</span></span><br><span class="line">print(<span class="built_in">min</span>(digits))</span><br><span class="line"><span class="comment">### 输出最大值</span></span><br><span class="line">print(<span class="built_in">max</span>(digits))</span><br><span class="line"><span class="comment">### 计算总和</span></span><br><span class="line">print(<span class="built_in">sum</span>(digits))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><h5 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h5><p>列表解析将<code>for</code>循环和创建新元素的代码合并成一行，并自动附加新元素。下面的示例使用列表解析创建你在前面看到的平方数列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)] </span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure><p>要使用这种语法，首先指定一个描述性的列表名，如<code>squares</code>；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为<code>value**2</code>，它来计算平方值。接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。在这个示例中，<code>for</code>循环为<code>for value in range(1,11)</code>，它将值1~10提供给表达式<code>value**2</code>。请注意，这里的for语句末尾没有冒号。<br>  结果与你在前面看到的平方数列表相同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>要创建自己的列表解析，需要经过一定的练习，但能够熟练地创建常规列表后，你会发现这样做是完全值得的。当你觉得编写三四行代码来生成列表有点繁复时，就应考虑创建列表解析了。</p><h3 id="列表中的一部分"><a href="#列表中的一部分" class="headerlink" title="列表中的一部分"></a>列表中的一部分</h3><p>在上面的内容中，我们学习了如何访问单个列表元素。接下来，我们将学习如何处理列表的所有元素。我们还可以处理列表的部分元素——Python称之为<strong>切片</strong>。</p><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数<code>range()</code>一样，Python 在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3， 这将输出分别为0、1和2的元素。<br>我们还是以蔬菜列表为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>上面的代码打印该列表的一个切片，其中只包含三种蔬菜。输出也是一个列表，其中包含前三种蔬菜:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;potato&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你可以生成列表的任何子集，例如，如果你要提取列表的第2~4个元素，可将起始索引指定为1，并将终止索引指定为4:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>这一次，切片始于<code>tomato</code>，终于<code>leek</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果你没有指定第一个索引，Python将自动从列表开头开始:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>由于没有指定起始索引，Python从列表开头开始提取:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;potato&#x27;</span>, <span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要让切片终止于列表末尾，也可使用类似的语法。例如，如果要提取从第3个元素到列表末 尾的所有元素，可将起始索引指定为2，并省略终止索引:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>Python将返回从第3个元素到列表末尾的所有元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><p>无论列表多长，这种语法都能够让你输出从特定位置到列表末尾的所有元素。前面我们了解过，负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。例如，如果你要输出名单上的最后三种蔬菜，可使用切片<code>vegetables[-3:]</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(vegetables[-<span class="number">3</span>:])</span><br><span class="line">[<span class="string">&#x27;tomato&#x27;</span>, <span class="string">&#x27;onion&#x27;</span>, <span class="string">&#x27;leek&#x27;</span>]</span><br></pre></td></tr></table></figure><h5 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h5><p>如果要遍历列表的部分元素，可在for循环中使用切片。在下面的示例中，我们遍历前三种蔬菜，并打印它们的名字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vegetables = [<span class="string">&#x27;potato&#x27;</span>,<span class="string">&#x27;tomato&#x27;</span>,<span class="string">&#x27;onion&#x27;</span>,<span class="string">&#x27;leek&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;Here are the first three vegetable:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> vegetables[:<span class="number">3</span>]:</span><br><span class="line">    print(name.title())</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Here are the first three vegetable:</span><br><span class="line">Potato</span><br><span class="line">Tomato</span><br><span class="line">Onion</span><br></pre></td></tr></table></figure><p>在很多情况下，切片都很有用。例如，编写游戏时，你可以在玩家退出游戏时将其最终得分加入到一个列表中。然后，为获取该玩家的三个最高得分，你可以将该列表按降序排列，再创建一个只包含前三个得分的切片。处理数据时，可使用切片来进行批量处理；编写Web应用程序时，可使用切片来分页显示信息，并在每页显示数量合适的信息。</p><h5 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h5><p>我们经常需要根据既有列表创建全新的列表。下面来介绍复制列表的工作原理，以及复制列表可提供极大帮助。<br>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引(<code>[:]</code>)。 这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。<br>例如，假设有一个列表，其中包含你最喜欢的四种食品，而你还想创建另一个列表，在其中包含一位朋友喜欢的所有食品。不过，你喜欢的食品，这位朋友都喜欢，因此你可以通过复制来创建这个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] friend_foods = my_foods[:]</span><br><span class="line">print(<span class="string">&quot;My favorite foods are:&quot;</span>) </span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure><p>我们首先创建了一个名为<code>my_foods</code>的食品列表，然后创建了一个名为<code>friend_foods</code>的新列表。我们在不指定任何索引的情况下从列表<code>my_foods</code>中提取一个切片，从而创建了这个列表的副本，再将该副本存储到变量<code>friend_foods</code>中。打印每个列表后，我们发现它们包含的食品相同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are: </span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><p>为了核实我们确实有两个列表，下面在每个列表中都添加一种食品，并核实每个列表都记录了相应人员喜欢的食品:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>] <span class="number">5</span></span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>) </span><br><span class="line">print(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line">print(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>) </span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure><p>与前一个示例一样，我们首先将<code>my_foods</code>的元素复制到新列表<code>friend_foods</code>中。接下来，在每个列表中都添加一种食品:在列表<code>my_foods</code>中添加<code>cannoli</code>，而在<code>friend_foods</code>中添加<code>ice cream</code>。最后，打印这两个列表，核实这两种食品包含在正确的列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are:</span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">``` </span></span><br><span class="line"><span class="string">上面的输出表明，`cannoli`包含在你喜欢的食品列表中，而`ice cream`没有。`ice cream`包含在你朋友喜欢的食品列表中，而`cannoli`没有。倘若我们只是简单地将`my_foods`赋给`friend_foods`，就不能得到两个列表。例如，下例演示了在不使用切片的情况下复制列表的情况:</span></span><br><span class="line"><span class="string">``` python</span></span><br><span class="line"><span class="string">my_foods = [&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">#这行不通 </span></span><br><span class="line"><span class="string">friend_foods = my_foods</span></span><br><span class="line"><span class="string">my_foods.append(&#x27;</span>cannoli<span class="string">&#x27;) </span></span><br><span class="line"><span class="string">friend_foods.append(&#x27;</span>ice cream<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">print(&quot;My favorite foods are:&quot;) </span></span><br><span class="line"><span class="string">print(my_foods)</span></span><br><span class="line"><span class="string">print(&quot;\nMy friend&#x27;</span>s favorite foods are:<span class="string">&quot;) </span></span><br><span class="line"><span class="string">print(friend_foods)</span></span><br></pre></td></tr></table></figure><p>这里将<code>my_foods</code>赋给<code>friend_foods</code>，而不是将<code>my_foods</code>的副本存储到<code>friend_foods</code>。这种语法实际上是让Python将新变量<code>friend_foods</code>关联到包含在<code>my_foods</code>中的列表，因此这两个变量都指向同一个列表。鉴于此，当我们将<code>cannoli</code>添加到<code>my_foods</code>中时，它也将出现在<code>friend_food</code>中；同样，虽然<code>ice cream</code>好像只被加入到了<code>friend_foods</code>中，但它也将出现在这两个列表中。<br>输出表明，两个列表是相同的，这并非我们想要的结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>, <span class="string">&#x27;ice cream&#x27;</span>]</span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are:</span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>cannoli<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>8-1 动物:想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for循环将每种动物的名称都打印出来。<br> 修改这个程序，使其针对每种动物都打印一个句子，如”A dog would make a great pet”。在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如”Any of these animals would make a great pet!”这样的句子。<br>8-2  数到 20:使用一个 for 循环打印数字 1<del>20(含)。<br>8-3 计算 1</del> 1000000 的总和:创建一个列表，其中包含数字1<del>1000000，再使用min()和max()核实该列表确实是从1开始，到1000000 结束的。另外，对这个列表调用函数sum()，体会一下Python将一百万个数字相加需要多长时间。<br>8-4 3的倍数:创建一个列表，其中包含 3</del>30 内能被3整除的数字;再使用一个for循环将这个列表中的数字都打印出来。<br>8-5 切片:修改8-1的代码，在末尾添加几行代码，以完成如下任务。 打印消息”The first three items in the list are:”，再使用切片来打印列表的前三个元素。打印消息”Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。打印消息”The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费送书啦！细数Github大神们的开源书籍！</title>
      <link href="tips-github-free-books-3.html"/>
      <url>tips-github-free-books-3.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h3 id="Go-系列"><a href="#Go-系列" class="headerlink" title="Go 系列"></a>Go 系列</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_2.jpeg" /></p><p align="center">《Mastering GO》</p><blockquote><p>推荐语：本书适用于Golang程序员。您之前应该阅读有关Go的介绍性书籍。本书的内容包括但不限于并发、网络编程、垃圾回收、组合、GO UNIX系统编程、基本数据类型（Array,Slice,Map）、GO源码、反射，接口，类型方法等高级概念。阅读本书需要一定的编程经验。如果你在工作中使用Go或者业余时间爱好GO，那么这本书一定会让你对GO的理解更上一层楼。<br><a href="https://github.com/hantmac/Mastering_Go_ZH_CN">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_6.png" /></p><p align="center">《Go语法树入门——开启自制编程语言和编译器之旅》</p>  <blockquote><p>Go语法树是Go语言源文件的另一种语义等价的表现形式。而Go语言自带的go fmt和go doc等命令都是在Go语法树的基础之上分析工具。因此将Go语言程序作为输入数据，让我们语法树这个维度重新审视Go语言程序，我们将得到创建Go语言本身的技术。Go语法树由标准库的go/ast包定义，它是在go/token包定义的词法基础只是抽象的语法树结构。本书简单介绍语法树相关包的使用（出版社已经约稿出版本书，并在开源版本的基础之上增加了语义信息、SSA形式、LLVM和凹语言等内容，因为出版社版权问题不方便全部公开新增内容）。<br><a href="https://github.com/chai2010/go-ast-book">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_18.png" /></p><p align="center">《Go语言101》</p>   <blockquote><p>Go语言101是一本侧重于Go语言语法语义以及运行时相关知识点的编程解释和指导书。 此书旨在尽可能地帮助Go程序员更深更全面地理解Go语言。 此书也搜集了Go语言和Go编程中的很多细节。 此书同时适合Go初学者和有一定经验的Go程序员阅读。<br><a href="https://github.com/golang101/golang101">领取地址</a></p></blockquote><h3 id="C-和-C"><a href="#C-和-C" class="headerlink" title="C 和 C++"></a>C 和 C++</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_15.png" /></p><p align="center">《C/C++面向WebAssembly编程》</p>  <blockquote><p>适读人群 ：本书适合从事高性能Web前端开发、跨语言Web应用开发的技术人员学习参考，也可以作为WebAssembly标准参考手册随时查阅。<br>作为一种新颖的网页前端技术，WebAssembly的发展日新月异。本书基于已受浏览器普遍支持的WebAssembly极小可用特征集，致力于通过简单易懂的方式，从使用方法到虚拟机设计，讲解WebAssembly的运行原理。极小可用特征集只是快速迭代的起点，SIMD、多线程等更多特性将逐渐被添加到WebAssembly标准中。<br><a href="https://github.com/3dgen/cppwasm-book">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_16.jpeg" /></p><p align="center">《C++ Concurrency in Action》</p>  <blockquote><p>作者为对《C++ Concurrency in Action》的中文翻译。本书是基于C++11新标准的并发和多线程编程深度指南。从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，最后还介绍了多线程代码的测试工作。本书的附录部分还对C++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了C++11线程库的完整参考。本书适合于需要深入了解C++多线程开发的读者，以及使用C++进行各类软件开发的开发人员、测试人员。对于使用第三方线程库的读者，也可以从本书后面的章节中了解到相关的指引和技巧。同时，本书还可以作为C++11线程库的参考工具书。<br><a href="https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_5.png" /></p><p align="center">《BuildYourOwnLisp》</p> <blockquote><p>在本书中，你将在学习 C 语言的同时学会编写你自己的编程语言——一个 1000 行左右代码的简单 Lisp。不过我们并不是从零开始编写的，在代码中我用到了一个外部的库来完成一些初始化的工作。但是剩下的最重要的部分都是我们一行一行编写的，而且在本书结束时，你将会拥有一个属于自己的“麻雀虽小，五脏俱全”的 Lisp。<br>很多人非常想学习 C 语言，但却无从下手。现在大可不必担心了。如果你能坚持看完本书，我敢保证，至少你将拥有一个非常酷的新语言可以把玩，说不定还能成为一个熟练的 C 程序员呢！<br><a href="https://ksco.gitbooks.io/build-your-own-lisp/content">领取地址</a></p></blockquote><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_8.jpg" /></p><p align="center">《Istio 服务网格进阶实战》</p> <blockquote><p>Istio 是由 Google、IBM、Lyft 等共同开源的 Service Mesh（服务网格）框架，作为云原生时代下承 Kubernetes、上接 Serverless 架构的重要基础设施层，于 2017 年开始进入大众视野。<br>2018 年由蚂蚁金服发起成立了 ServiceMesher 社区，作为中国最早的一批研究和推广 Service Mesh 技术的开源社区决定整合社区资源，合作撰写一本开源的 Service Mesh 电子书以飨读者。<br><a href="https://github.com/servicemesher/istio-handbook">领取地址</a></p></blockquote><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p align="center">《Rust 程序设计语言（第二版 & 2018 edition）》</p> <blockquote><p>Rust 被证明是可用于大型的、拥有不同层次系统编程知识的开发者团队间协作的高效工具。底层代码中容易出现种种隐晦的 bug，在其他编程语言中，只能通过大量的测试和经验丰富的开发者细心的代码评审来捕获它们。在 Rust 中，编译器充当了守门员的角色，它拒绝编译存在这些难以捕获的 bug 的代码，这其中包括并发 bug。通过与编译器合作，团队将更多的时间聚焦在程序逻辑上，而不是追踪 bug。<br><a href="https://github.com/KaiserY/trpl-zh-cn">领取地址</a></p></blockquote><h3 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h3><p align="center">《Machine-Learning-Systems-Design》</p> <blockquote><p>一本关于机器学习系统设计的小册子附有练习题<br><a href="https://github.com/chiphuyen/machine-learning-systems-design">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_9.jpg" /></p><p align="center">《Front-End Developer Handbook 2019》</p> <blockquote><p>该书适合任何阶段的人用来了解前端开发实践的指南，它概述和讨论了前端工程的实践：如何学习前端、在 2019 年进行前端实践时应该使用哪些工具。<br><a href="https://frontendmasters.com/books/front-end-handbook/2019/#1">领取地址</a></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_1.jpg" /></p><p align="center">《Java 编程思想》</p> <blockquote><p>《计算机科学丛书：Java编程思想（第4版）》赢得了全球程序员的广泛赞誉，即使是晦涩的概念，在BruceEckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。Bruce Eckel，是MindView公司的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想第2卷》。<br>关注公众号【fulade_me】<br>回复关键字：<strong>Java4</strong></p></blockquote><p align="center">  <img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_23_book_4.png" /></p><p align="center">《JavaScript 20 年》</p> <blockquote><p>本书由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化历程。全书不仅讲解了大量语言技术细节层面的演进，更复盘了更高层面上规范制定与标准博弈中的历史成败，是一部讲述人类如何在商业与技术上的竞争合作中促进产业发展的故事。这个故事相当漫长而复杂。全文分为四个部分，每部分都对应 JavaScript 演化历程中的一个主要阶段。各部分之间还有一段简短的插曲，介绍彼时的开发者们是如何看待与使用 JavaScript 的。<br>关注公众号:【fulade_me】<br>回复关键字：<strong>JavaScript</strong></p></blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protoc 同时编译多个.protoc文件</title>
      <link href="tips-command-line-protoc-5.html"/>
      <url>tips-command-line-protoc-5.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h5 id="官方的示例"><a href="#官方的示例" class="headerlink" title="官方的示例"></a>官方的示例</h5><p>只是编译一个文件的命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure><p>我们想要编译同时编译多个文件<br>只需要把<code>path/to/file.proto</code>改为<code>path/to/*.proto</code> 即可。</p><h5 id="同时编译多个示例："><a href="#同时编译多个示例：" class="headerlink" title="同时编译多个示例："></a>同时编译多个示例：</h5><p>此示例只是编译了<code>objc</code>代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=/Users/Demo/Desktop/Demo/proto --objc_out=./out /Users/Demo/Desktop/Demo/proto/*.proto</span><br></pre></td></tr></table></figure><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-7】Python手把手教程之——详解列表List</title>
      <link href="python-list-7.html"/>
      <url>python-list-7.html</url>
      
        <content type="html"><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)  </p><p>列表，在其他语言中又被称为<strong>数组</strong>，是由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表。你也可以创建几个列表，把这几个列表又放在一个列表内。<br>在Python中，用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。下面是一个简单的列表示例，这个列表包含几种常见的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="访问列表数据"><a href="#访问列表数据" class="headerlink" title="访问列表数据"></a>访问列表数据</h4><p>列表是有序的数据集合，每一个元素都有一个位置参数。比如上面的<code>fruits</code>列表里面，其中<code>Apple</code>的位置参数是<code>0</code>，<code>Banana</code>位置参数是<code>1</code>。要访问列表元素，可指出列表的名称，再指出元素的索引，并将其放在方括号内。<br>例如，下面的代码从列表<code>fruits</code>中选出第一种水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">Apple</span><br></pre></td></tr></table></figure><h4 id="索引是从0开始的"><a href="#索引是从0开始的" class="headerlink" title="索引是从0开始的"></a>索引是从0开始的</h4><p>所有的列表位置参数都是从<code>0</code>开始的而不是从1开始的，对于初学者，这个一定要记牢。如果在编码过程中发现取出的元素跟自己预期的不一样，请看看你是否犯了这种简单的错误。<br>第二个列表元素的索引为1。根据这种简单的计数方式，要访问列表的任何元素，都可将其位置减<code>1</code>，并将结果作为索引。例如，要访问第4个列表元素，可使用索引<code>3</code>。<br>下面的代码访问索引<code>1</code>和<code>3</code>处的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">1</span>])</span><br><span class="line">print(fruits[<span class="number">3</span>])</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure><p>Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为<code>-1</code>，可让Python返回最后一个列表元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[-<span class="number">1</span>])</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure><p>这里返回的是<code>Orange</code>。这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。<br>这种约定也适用于其他负数索引，例如：索引<code>-2</code>返回倒数第二个列表元素， 索引<code>-3</code>返回倒数第三个列表元素，以此类推。</p><h4 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h4><p>要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。<br>例如，假设有一个水果列表，其中的第一个元素为<code>Apple</code>，如何修改它的值呢?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">print(fruits)</span><br><span class="line">Apple</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始把第一个元素修改为 Cherry</span></span><br><span class="line">fruits[<span class="number">0</span>] = <span class="string">&#x27;Cherry&#x27;</span></span><br><span class="line">print(fruits[<span class="number">0</span>])</span><br><span class="line">print(fruits)</span><br><span class="line">Cherry</span><br><span class="line">[<span class="string">&#x27;Cherry&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h4><p>你可能出于很多原因要在列表中添加新元素。比如商场里又新增加了一种水果，需要在<code>fruits</code>里面中再新增一种水果。Python提供了多种在既有列表中添加新数据的方式。<br><strong>1.在列表末尾添加元素</strong><br>在列表中添加新元素时，最简单的方式是将元素附加到列表末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">fruits.append(<span class="string">&#x27;Cherry&#x27;</span>)</span><br><span class="line">print(fruits)</span><br></pre></td></tr></table></figure><p>方法<code>append()</code>将元素<code>Cherry</code>添加到了列表末尾，而不影响列表中的其他所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Orange&#x27;</span>,<span class="string">&#x27;Cherry&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>append()</code>可以很好的满足我们动态创建数组的需求。例如，我们可以先创建一个空的列表，在使用一系列的<code>append()</code>语句来动态的添加元素。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = []</span><br><span class="line">fruits.append(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">fruits.append(<span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line">fruits.append(<span class="string">&#x27;Pear&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这种创建方式比较常见，因为很多时候，我们在代码的执行过程中才会知道哪些元素需要添加到列表中，哪些元素不需要添加。<br><strong>2.在列表中插入元素</strong>  </p><p>使用方法<code>insert()</code>可在列表的任何位置添加新元素。但是，你需要指定新元素的索引和值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">fruits.insert(<span class="number">0</span>,<span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Orange&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在该实例中，<code>Orange</code>被插入到了索引为<code>0</code>的这个位置。这种操作会使列表内的其他的每个元素都右移一个位置。<br>需要注意的是：插入数据的索引不能超过列表当前最大的索引值，如果我们执行<code>fruits.insert(10,&#39;Orange&#39;)</code>就会报错。你可以试一下。</p><h4 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h4><p>我们经常需要从列表中删除一个元素，比如说有<code>Apple</code>这种水果因为缺货需要下架了，我们需要将<code>Apple</code>从列表中移除掉。你可以根据位置或值来删除列表中的元素。<br><strong>1.使用del语句删除元素</strong><br>如果知道要删除的元素在列表中的位置，可直接使用<code>del</code>语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> fruits[<span class="number">0</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>使用<code>del</code>可删除任何位置处的列表元素，条件是知道其索引。下例演示了如何删除<code>fruits</code>列表中的第二个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> fruits[<span class="number">1</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>从输出来看，第二个元素已经被删除了。<br><strong>2.使用方法pop()删除元素</strong><br>有时候，你要将元素从列表中删除，并接着使用它的值。比如你下架了某种水果，需要把这种水果放入到明天的采购列表中。<br>方法<code>pop()</code>可删除列表末尾的元素，并让你能够接着使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">poped_fruit = fruits.pop()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>]</span><br><span class="line">print(poped_fruit)</span><br><span class="line">Pear</span><br></pre></td></tr></table></figure><p>执行<code>pop()</code>方法后，原数组最后一个元素被移除掉且最后一个元素作为返回值被返回。<br><strong>3.pop列表中任何位置处的元素</strong><br>想必你已经猜到了，我们只需要在<code>pop()</code>方法内传入想移除的元素索引就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">first_fruit = fruits.pop(<span class="number">0</span>)</span><br><span class="line">print(first_fruit)</span><br><span class="line">Apple</span><br></pre></td></tr></table></figure><p>别忘了，每当你使用pop()时，被弹出的元素就不再在列表中了。<br>如果你不确定该使用del语句还是<code>pop()</code>方法，下面是一个简单的判断标准: 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句，如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。<br><strong>4.根据值删除元素</strong><br>有时候，我们并不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用<code>remove()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br><span class="line">fruits.remove(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>方法<code>remove()</code>只删除在列表中出现的第一个指定的值。也就是说假如<code>Apple</code>在<code>fruits</code>列表中出现了多次，调用<code>remove()</code>方法，只会删除第一个<code>Apple</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>,<span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br><span class="line">fruits.remove(<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="整合列表"><a href="#整合列表" class="headerlink" title="整合列表"></a>整合列表</h3><p>在我们创建的列表中，元素的排列顺序常常是无法预测的。因为我们并非总能控制用户提供数据的顺序。我们又经常需要以特定的顺序呈现信息。有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python提供了很多组织列表的方式，可根据具体情况选用。</p><h4 id="使用方法sort-对列表进行永久性排序"><a href="#使用方法sort-对列表进行永久性排序" class="headerlink" title="使用方法sort()对列表进行永久性排序"></a>使用方法sort()对列表进行永久性排序</h4><p>Python方法<code>sort()</code>让你能够轻松地对列表进行排序。假设你有一个水果列表，并要让其中的水果按字母顺序排列。为简化这项任务，我们假设该列表中的所有值都是小写的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">fruits.sort()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p>方法<code>sort()</code>永久性地修改了列表元素的排列顺序。现在，<code>fruits</code>是按字母顺序排列的，再也无法恢复到原来的排列顺序。<br>我们还可以按与字母顺序相反的顺序排列列表元素，为此，只需向<code>sort()</code>方法传递参数<code>reverse=True</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="使用函数sorted-对列表进行临时排序"><a href="#使用函数sorted-对列表进行临时排序" class="headerlink" title="使用函数sorted()对列表进行临时排序"></a>使用函数sorted()对列表进行临时排序</h4><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数<code>sorted()</code>。函数<code>sorted()</code>让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。下面尝试对<code>fruits</code>列表调用这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(fruits))</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br><span class="line"><span class="comment"># 再一次输出 fruits</span></span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure><p>注意，调用函数<code>sorted()</code>后，列表元素的排列顺序并没有变。如果你要按与字母顺序相反的顺序显示列表，也可向函数<code>sorted()</code>传递参数<code>reverse=True</code>。<br>在并非所有的值都是小写时，按字母顺序排列列表要复杂些，这个问题我们后面再详细解答。</p><h4 id="倒序输出列表"><a href="#倒序输出列表" class="headerlink" title="倒序输出列表"></a>倒序输出列表</h4><p>要反转列表元素的排列顺序，可使用方法<code>reverse()</code>。假设<code>fruist</code>列表是按购买时间排列的，可轻松地按相反的顺序排列其中的水果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">fruits.reverse()</span><br><span class="line">print(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>reverse()</code>不是指按与字母顺序相反的顺序排列列表元素，而只是<strong>反转</strong>列表元素的排列顺序。<br>方法<code>reverse()</code>永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此 只需对列表再次调用reverse()即可</p><h4 id="列表的长度"><a href="#列表的长度" class="headerlink" title="列表的长度"></a>列表的长度</h4><p>使用函数<code>len()</code>可快速获悉列表的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fruits = [<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="built_in">len</span>(fruits)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>获取列表的长度在开发过程中很有用，比如我们利用<code>len()</code>方法一下就可以获取到当前有多少种水果正在销售。</p><h4 id="动手试一试"><a href="#动手试一试" class="headerlink" title="动手试一试"></a>动手试一试</h4><blockquote><p>7-1 将一些朋友的姓名存储在一个列表中，并将其命名为 names。依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。<br>7-2 嘉宾名单: 如果你可以邀请任何人一起共进晚餐(无论是在世的还是故去的)，你会邀请哪些人？请创建一个列表，其中包含至少 3 个你想邀请的人，然后，打印列表。<br>7-3 修改嘉宾名单:你刚得知有位嘉宾无法赴约，因此需要另外邀请一位嘉宾。修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。<br>然后再一次打印这个列表。<br>7-4 添加嘉宾:你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。<br>使用 insert()将一位新嘉宾添加到名单开头。<br>使用 insert()将另一位新嘉宾添加到名单中间。<br>使用 append()将最后一位新嘉宾添加到名单末尾。<br>7-5 缩减名单: 你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。  使用pop()不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一下。<br>7-7 放眼世界: 想出至少 5 个你渴望去旅游的地方。将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python 列表。<br>使用 sorted()按字母顺序打印这个列表，同时不要修改它。再次打印该列表，核实排列顺序未变。<br>使用 sorted()按与字母顺序相反的顺序打印这个列表，同时不要修改它。再次打印该列表，核实排列顺序未变。<br>使用 reverse()修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了。<br>使用 reverse()再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序。<br>使用 sort()修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了。<br>使用 sort()修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是时候来薅京东的羊毛了，自动化签到脚本！</title>
      <link href="tips-jd-auto-sigh-2.html"/>
      <url>tips-jd-auto-sigh-2.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)<br><a href="http://fulade.me/tips-jd-auto-sigh-2.html">文章首发地址</a></p><blockquote><p>双十一刚刚过，相信很多小伙伴也都剁手了。今年电商平台同样给出了很多优惠。有些优惠，比如红包，是靠运气来获得的，但是还有一些优惠是靠长期坚持才能获得。比如：签到、东东萌宠。每天都能坚持签到固然很棒，但是如果有脚本可以自动签到，那岂不是更美？</p></blockquote><p><a href="https://github.com/Johnson8888/jd_sign_bot">自动签到脚本</a>此脚本涵盖了目前京90%以上的签到任务，我们只需要简单配置，每天定时触发，就可以签到，领奖品了。而且都是<strong>免费的</strong>。</p><h5 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h5><ul><li>node.js</li><li>Server酱(可选)</li></ul><h5 id="获取京东Cookie"><a href="#获取京东Cookie" class="headerlink" title="获取京东Cookie"></a>获取京东Cookie</h5><p>这里以<code>Chrome</code>浏览器为例，<code>Edge</code>、<code>360浏览器</code>、<code>QQ浏览器</code>同样支持。</p><ul><li>打开Chrome浏览的隐私模式，输入<a href="https://m.jd.com/">https://m.jd.com/</a>。</li><li>按下键盘上的<code>F12</code>进入调试模式，选择手机模式。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_device.jpg" alt="2020_11_13_auto_sign_device"><br>如果没有登录就使用<code>手机验证码</code>方式登录(已登录，可忽略)，使用验证码登录获取的<code>cookie</code>有效时长30天左右，存活时间更长。</li><li>登录成功后，点击<code>Network</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_network.png" alt="2020_11_13_auto_sign_network"></li></ul><p>然后点击箭头所指的这个按钮清理一下，因为网络请求太多了，不方便查看。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_clear.png" alt="2020_11_13_auto_sign_clear"><br>清理完了之后，点击一下<code>我的</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_gif.png" alt="2020_11_13_auto_sign_gif"><br>这个时候我们找到一个<code>log.gif?</code>开头的请求，点击它，就可以看到<code>cookie</code>字段了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_cookie.png" alt="2020_11_13_auto_sign_cookie"></p><ul><li>这样复制出来的cookie比较长，我们只需要<code>pt_pin=xxxx;</code>和 <code>pt_key=xxxx;</code>部分的内容即可(注:英文引号<code>;</code>是必要的)。<br>可以用下面的脚本，直接在<code>console</code>里面输入下面脚本按<code>enter</code>回车键。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CV = <span class="string">&#x27;单引号里面放上面拿到的cookie&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> CookieValue = CV.match(<span class="regexp">/pt_pin=.+?;/</span>) + CV.match(<span class="regexp">/pt_key=.+?;/</span>);</span><br><span class="line">copy(CookieValue);</span><br></pre></td></tr></table></figure>这样子整理出关键的的cookie已经在你的剪贴板上，可直接粘贴。<br>我们先把它保存好，下面的步骤要用到。</li></ul><h5 id="配置-Server酱"><a href="#配置-Server酱" class="headerlink" title="配置 Server酱"></a>配置 Server酱</h5><p><a href="http://sc.ftqq.com/3.version">Server酱</a>是一个免费的，可以推送消息到我们微信的服务。<br>推送服务可以帮助我们每天观察签到的情况，如果出错了，可以及时调整。如果有的小伙伴不需要，可忽略这个步骤，直接进入下一步。</p><ul><li>打开主页 <a href="http://sc.ftqq.com/3.version">http://sc.ftqq.com/3.version</a>，点击右上角<code>登入</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_main_page.jpg" alt="2020_11_13_server_jiang_main_page"></li><li>使用Github 授权，登录。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_login.jpg" alt="2020_11_13_server_jiang_login"><br>输入账号密码即可。</li><li>登录成功后点击<code>微信推送</code>并扫描二维码绑定微信<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_wechat.jpg" alt="2020_11_13_server_jiang_wechat"><br>使用手机打开微信，扫描屏幕上的二维码，如果未关注，先关注，然后再绑定即可。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_qrcode.jpg" alt="2020_11_13_server_jiang_qrcode"></li><li>绑定成功后，点击右上方的<code>发送消息</code>链接，就可以看到你自己的 <code>key</code>值，保存下来，后面会用到。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_server_jiang_test.jpg" alt="2020_11_13_server_jiang_test"><br>当然你也可以在下面的<code>在线发送工具</code>测试推送是否生效。</li></ul><h5 id="配置本地代码"><a href="#配置本地代码" class="headerlink" title="配置本地代码"></a>配置本地代码</h5><ul><li><p>使用<code>git clone</code>命令将<a href="https://github.com/Johnson8888/jd_sign_bot">https://github.com/Johnson8888/jd_sign_bot</a>代码下载下来。</p></li><li><p>下载完成后，我们需要安装项目所需要的依赖。使用命令行工具(Mac下使用<code>Termainal</code>,Windows下使用<code>PowerShell</code>)进入到<code>jd_sign_bot</code>文件内。在命令行内输入 <code>npm install --dependencies</code>，等待运行完成。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_npm_install.png" alt="2020_11_13_npm_install"><br>此时，项目文件夹内会多出一个 <code>node_modules</code>文件夹。</p></li><li><p>配置Cookies<br>打开文件内的<code>JD_DailyBonus.js</code>文件，修改<code>Key</code>参数为刚刚获取到的cookies<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_input_server_jiang.png" alt="2020_11_13_input_server_jiang"></p></li><li><p>配置Server酱<br>打开文件内的<code>app.js</code>文件，修改<code>serverJ</code>参数为刚刚获取到的Server酱的key<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_input_cookies.png" alt="2020_11_13_input_cookies"></p></li></ul><h5 id="执行签到"><a href="#执行签到" class="headerlink" title="执行签到"></a>执行签到</h5><p>进入到<code>jd_sign_hot</code>文件夹下，执行 <code>node app.js</code>即可签到！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_auto_sign_exec.jpg" alt="2020_11_13_auto_sign_exec"><br>此时我们的脚本在本地就已经部署好了，如果你想更编辑，可以把代码部署到云服务器上，这样就不需要每天点击触发了。<br>或者你也可以部署在自己的服务器上，每天定时执行。</p><h4 id="你也可以-将脚本部署在腾讯云-·-云函数-上"><a href="#你也可以-将脚本部署在腾讯云-·-云函数-上" class="headerlink" title="你也可以 将脚本部署在腾讯云 · 云函数 上"></a>你也可以 将脚本部署在腾讯云 · 云函数 上</h4><p>去到<a href="https://console.cloud.tencent.com/scf/index">腾讯云函数地址</a>，如果没有开通此服务的顺手开一下就可以了。</p><ul><li><p>单击左侧导航栏函数服务，进入<strong>函数服务</strong>页面。 在页面上方选择一个地域，最好选择离你常用地区近点的，不至于导致账号异常。单击<strong>新建</strong>。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxun_clound.jpg" alt="2020_11_13_tengxun_clound"></p></li><li><p>在<strong>新建函数</strong>页面填写函数基础信息，单击下一步。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input.png" alt="2020_11_13_tengxunyun_input"></p></li><li><p>函数名称：可以自定义，比如为<code>jd_sign</code>。 运行环境：选择 <code>Nodejs 12.16</code>。 创建方式：选择 <code>空白函数</code>。<br>确保环境为<code>Nodejs 12.16</code>，执行方法改为：<code>index.main_handler</code>，提交方式建议选本地文件夹。</p></li><li><p>然后将刚才下载并配置好的文件夹<code>jd_sign_bot</code>上传上来。（记得node_modules文件夹一并上传），完了后点击下面的高级设置。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_1.png" alt="2020_11_13_tengxunyun_input_1"></p></li><li><p>内存用不了太大，64MB就够了（64M内存，免费时长6,400,000秒，内存与免费时长大致关系可以参看云函数官方说明），超时时间改为最大的900秒，然后点击最下面的完成。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_2.png" alt="2020_11_13_tengxunyun_input_3"></p><ul><li>点击刚创建的函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_3.png" alt="2020_11_13_tengxunyun_input_3"></p><p>点击<code>创建触发器</code></p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxunyun_input_4.png" alt="2020_11_13_tengxunyun_input_4"></p><p>比如我填写的是 <code>0 45 8 * * * *</code>，每天上午8点45触发一次。<br>腾讯云提供了相关配置<a href="https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F">Cron的文档</a>，也有第三方<a href="https://tool.lu/crontab/">测试工具</a>。</p><h5 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><p>我们打开刚才创建的云函数，点击<code>保存并测试</code>，等过1分钟左右手机上收到推送，那我们的配置就是成功的。<br>如果没有收到推送，可以点击<code>日志查看</code>排查问题。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_11_13_tengxun_cloud_test.png" alt="2020_11_13_tengxun_cloud_test"></p><p>如果你不喜欢腾讯云的服务<br>我们可以参考<a href="https://ruicky.me/2020/06/05/jd-sign/">ruicky大神的博客</a>，将脚本部署在Github Actions上面也是也可以的。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-9】Flutter教程Dart语言——函数和匿名函数</title>
      <link href="dart-functions-1-9.html"/>
      <url>dart-functions-1-9.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h4><blockquote><p>Dart 同样也是一种面向对象的语音。所以即便函数也是一个对象。类型为 <code>Function</code>，这意味着函数可做作为变量，也也可以作为函数的参数。</p></blockquote><p>下面是定义一个函数的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isEmpty(<span class="built_in">List</span> aList) &#123;</span><br><span class="line">  <span class="keyword">return</span> aList.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了规范其实我们需要在函数的头部声明一下返回值类型，当然如果不声明也可以运行，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">List</span> aList) &#123;</span><br><span class="line">  <span class="keyword">return</span> aList.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数体内只包含一个表达式，你可以使用简写语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">List</span> aList) =&gt; aList.length == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p> <code>=&gt;</code> 表达的 是 <code>&#123; return 表达式; &#125;</code> 的简写，有时<code>=&gt;</code>也称之为<strong>胖箭头语法</strong>。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h4><p>函数可以有两种形式的参数：<strong>必选参数</strong> 和 <strong>可选参数</strong>。必选参数定义在参数列表前面，可选参数一定是定义在必要参数后面。</p><h5 id="可选的命名参数"><a href="#可选的命名参数" class="headerlink" title="可选的命名参数"></a><strong>可选的命名参数</strong></h5><p>当你调用函数时，可以使用 参数名: 参数值 的形式来指定命名参数。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>已命名的参数是可选参数了，除非他们被特别标记为 <code>required</code>。</p><p>定义函数时，使用 <code>&#123;param1, param2, …&#125;</code> 来指定命名参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>虽然命名参数是可选参数的一种类型，但是你仍然可以使用 <code>@required</code> 注解来标识一个命名参数是必须的参数，此时调用者则必须为该参数提供一个值。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, <span class="meta">@required</span> Widget child&#125;)</span><br></pre></td></tr></table></figure><p>如果调用者想要通过 <code>Scrollbar</code> 的构造函数构造一个 <code>Scrollbar</code> 对象而不提供 child 参数，则会导致编译错误。</p><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a><strong>可选参数</strong></h5><p>使用 <code>[]</code> 将一系列参数包裹起来作为可选参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2, [<span class="built_in">String</span> s3]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$s1</span> and <span class="subst">$s2</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (s3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s3</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是不使用可选参数调用上述函数的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>);</span><br><span class="line">s1 and s2</span><br></pre></td></tr></table></figure><p>下面是使用可选参数调用上述函数的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>, <span class="string">&quot;s3&quot;</span>);</span><br><span class="line">s1 and s2 and s3</span><br></pre></td></tr></table></figure><h5 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h5><p>我们可以用 <code>=</code> 为函数的命名参数和可选参数定义默认值，默认值必须为编译时常量，没有指定默认值的情况下默认值为 <code>null</code>。</p><p>下面是设置可选参数默认值示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">设置 [bold] 和 [hidden] 标识……</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold 的值将为 true；而 hidden 将为 false。</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>下一个示例 默认值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strings(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2, [<span class="built_in">String</span> s3 = <span class="string">&#x27;this is s3&#x27;</span>, <span class="built_in">String</span> s4]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$s1</span> and <span class="subst">$s2</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (s3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s3</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> and <span class="subst">$s4</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strings(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>);</span><br><span class="line">s1 and s2 and <span class="keyword">this</span> <span class="keyword">is</span> s3</span><br></pre></td></tr></table></figure><h5 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a><strong>main() 函数</strong></h5><p>每个 <code>Dart</code> 程序都必须有一个 <code>main()</code> 顶级函数作为程序的入口，<code>main()</code> 函数返回值为 <code>void</code>。</p><p>下面是一个 Flutter 应用的 <code>main()</code> 函数示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a><strong>函数作为参数</strong></h5><p>可以将函数作为参数传递给另一个函数。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 printElement 函数作为参数传递。</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure><p>你也可以将函数赋值给一个变量，比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">&#x27;!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result = loudify(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(result);</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h4><blockquote><p>大多数方法都是有名字的，比如 <code>main()</code> 或 <code>printElement()</code>。你可以创建一个没有名字的方法，称之为 <strong>匿名函数</strong>，其实匿名函数很常见，也有不同的叫法，在C++里面叫Lambda表达式，在Objective-C叫Block闭包。你可以将匿名方法赋值给一个变量然后使用它。</p></blockquote><p>匿名方法看起来与命名函数h类似，在括号之间可以定义参数，参数之间用逗号分割。</p><p>后面大括号中的内容则为函数体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[类型] 参数[, …]]) &#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面代码定义了只有一个参数 <code>item</code> 且没有参数类型的匿名方法。<code>List</code> 中的每个元素都会调用这个函数，打印元素位置和值的字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果函数体内只有一行语句，你可以使用胖箭头缩写法。下面代码的运行结果，与上面代码的运行结果是一致的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(</span><br><span class="line">    (item) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><strong>变量作用域</strong></h4><p>变量的作用域在写代码的时候就确定了，大括号内定义的变量只能在大括号内访问，与 Java 类似。</p><p>下面是一个嵌套函数中变量在多个作用域中的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>nestedFunction()</code> 函数可以访问包括顶层变量在内的所有的变量。</p><p>返回值<br>所有的函数都有返回值。没有显示返回语句的函数最后一行默认为执行 <code>return null</code>;。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(foo() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-8】Flutter教程Dart语言——控制语句</title>
      <link href="dart-control-flow-statements-1-8.html"/>
      <url>dart-control-flow-statements-1-8.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h5 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a><strong>控制语句</strong></h5><p>Dart语言的控制语句跟其他常见语言的控制语句是一样的，基本如下：</p><ul><li><strong>if 和 else</strong></li><li><strong>for 循环</strong></li><li><strong>while 和 do-while 循环</strong></li><li><strong>break 和 continue</strong></li><li><strong>switch 和 case</strong></li><li><strong>assert</strong></li></ul><p><a href="http://fulade.me/dart-control-flow-statements-1-8.html">文章首发地址</a> </p><h5 id="If-和-Else"><a href="#If-和-Else" class="headerlink" title="If 和 Else"></a><strong>If 和 Else</strong></h5><p>Dart 支持 <code>if - else</code> 语句，其中 <code>else</code> 是可选的，比如下面的例子。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;value 0&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;value 1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;other value&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要遍历的对象实现了 <code>Iterable</code> 接口，则可以使用 <code>forEach()</code> 方法，如果不需要使用到索引，则使用 <code>forEach</code> 方法是一个非常好的选择：</p><blockquote><p><code>Iterable</code>接口实现了很多方法，比如说 <code>forEach()、any()、where()</code>等，这些方法可以大大精简我们的代码，减少代码量。  </p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure><p>像 <code>List</code> 和 <code>Set</code> 等，我们同样可以使用 <code>for-in</code> 形式的 迭代：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="While-和-Do-While"><a href="#While-和-Do-While" class="headerlink" title="While 和 Do-While"></a><strong>While 和 Do-While</strong></h5><p>while 循环会在执行循环体前先判断条件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do-while</code> 循环则会先执行一遍循环体 再 判断条件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Break-和-Continue"><a href="#Break-和-Continue" class="headerlink" title="Break 和 Continue"></a><strong>Break 和 Continue</strong></h5><p>使用 <code>break</code> 可以中断循环：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;break now&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>continue</code> 可以跳过本次循环直接进入下一次循环：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span> + i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 List实现了 Iterable 接口，则可以简单地使用下述写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0,1, 2, 3, 4, 5, 6, 7, 8, 9].where((i) &#x3D;&gt; i &gt; 5).forEach((i) &#123;</span><br><span class="line">  print(&quot;i &#x3D; &quot; + i.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Switch-和-Case"><a href="#Switch-和-Case" class="headerlink" title="Switch 和 Case"></a><strong>Switch 和 Case</strong></h5><p>Switch 语句在 Dart 中使用 <code>==</code> 来比较整数、字符串或编译时常量，比较的两个对象必须是同一个类型且不能是子类并且没有重写 <code>==</code> 操作符。 枚举类型非常适合在 Switch 语句中使用。<br>每一个 <code>case</code> 语句都必须有一个 <code>break</code> 语句，也可以通过 <code>continue、throw</code> 或者 <code>return</code> 来结束 <code>case</code> 语句。<br>当没有 <code>case</code> 语句匹配时，可以使用 <code>default</code> 子句来匹配这种情况：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;OPEN&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;CLOSED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;PENDING&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;APPROVED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;APPROVED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;DENIED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;DENIED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;OPEN&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OPEN&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;UNKNOW&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Dart</code> 支持空的 <code>case</code> 语句，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>: <span class="comment">// case 语句为空时的 fall-through 形式。</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// case 条件值为 CLOSED 和 NOW_CLOSED 时均会执行该语句。</span></span><br><span class="line">    <span class="built_in">print</span>(command);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a><strong>断言</strong></h5><p>在开发过程中，可以在条件表达式为 <code>false</code> 时使用 <strong>assert</strong>， 来中断代码的执行，提示出错误。你可以在本文中找到大量使用 <code>assert</code> 的例子。下面是相关示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保变量值不为 null (Make sure the variable has a non-null value)</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保变量值小于 100。</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保这是一个 https 地址。</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br><span class="line"><span class="keyword">assert</span> 的第二个参数可以为其添加一个字符串消息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>),<span class="string">&#x27;URL (<span class="subst">$urlString</span>) should start with &quot;https&quot;.&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>assert</code> 的第一个参数可以是值为布尔值的任何表达式。如果表达式的值为<code>true</code>，则断言成功，继续执行。如果表达式的值为<code>false</code>，则断言失败，抛出一个 <code>AssertionError</code> 异常。</p><p><strong>注意：</strong><br>在生产环境代码中，断言会被忽略，与此同时传入 <code>assert</code> 的参数不被判断。</p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=885429326&bvid=BV1NK4y177BW&cid=261114539&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-7】Flutter教程Dart语言——变量</title>
      <link href="dart-variable-1-7.html"/>
      <url>dart-variable-1-7.html</url>
      
        <content type="html"><![CDATA[<p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><blockquote><p>2011年10月10日的GOTO大会上，谷歌的两位工程师发布了“Dart”；Dart是一种全新的编程语言，旨在帮助开发者构建Web应用程序。Dart 1.0于2013年11月14日发布。我们日常开发Flutter使用的就是Dart语言，所以我们有必要了解一下Dart语言的使用方法。</p></blockquote><p><a href="http://fulade.me/dart-variable-1-7.html">文章首发地址</a></p><h4 id="类型安全的语言"><a href="#类型安全的语言" class="headerlink" title="类型安全的语言"></a><strong>类型安全的语言</strong></h4><p>Dart 语言是类型安全的语言，但是由于其支持类型推断，因此大多数变量不需要显式地指定类型：<br>例如</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">初始化一个字符串</span></span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Fulade&#x27;</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">Int类型</span></span></span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1995</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">浮点数类型</span></span></span><br><span class="line"><span class="keyword">var</span> antennaDiameter = <span class="number">3.7</span>;</span><br><span class="line"><span class="comment">/// <span class="markdown">数组</span></span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="comment">/// <span class="markdown">字典类型</span></span></span><br><span class="line"><span class="keyword">var</span> image = &#123;</span><br><span class="line">  <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;土星&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;//path/to/saturn.jpg&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><p>下面的示例代码将创建一个变量并将其初始化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Fulade&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>变量仅存储对象的引用。</strong><br>这里名为 name 的变量存储了一个 <code>String</code> 类型对象的引用，<code>&#39;Fulade&#39;</code> 则是该对象的值。<br><code>name</code> 变量的类型被推断为 <code>String</code>，但是你可以为其指定类型。<br>如果一个对象的引用不局限于单一的类型，可以将其指定为 <code>Object</code> 或 <code>dynamic</code> 类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除此之外你也可以指定类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a><strong>默认值</strong></h4><p>在 Dart 中，未初始化的变量拥有一个默认的初始化值：<code>null</code>。即便数字也是如此，因为在 Dart 中一切皆为对象，数字也不例外。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="keyword">if</span>(lineCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;line is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Final-和-Const"><a href="#Final-和-Const" class="headerlink" title="Final 和 Const"></a><strong>Final 和 Const</strong></h5><p>如果你不想更改一个变量，可以使用关键字 <code>final</code> 或者 <code>const</code> 修饰变量，这两个关键字可以替代 <code>var</code> 关键字。<br><strong>需要注意的是：</strong><br><code>final</code> 变量只可以被赋值一次；<br><code>const</code> 变量是一个编译时常量。（<code>const</code> 变量同时也是 <code>final</code>）<br>被<code>final</code>修饰的变量在第一次使用的时候被初始化。<br>下面的示例中我们创建并设置两个 <code>final</code> 变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;Bob&#x27;</span>; <span class="comment">// Without a type annotation</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">&#x27;Bobby&#x27;</span>;</span><br></pre></td></tr></table></figure><p>你不能修改一个 <code>final</code> 变量的值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">// Error: a final variable can only be set once.</span></span><br></pre></td></tr></table></figure><p>使用关键字 <code>const</code> 修饰变量表示该变量为 <strong>编译时常量</strong>。如果使用 <code>const</code> 修饰类中的变量，则必须加上 <code>static</code> 关键字，即 <code>static const</code>（注意：顺序不能颠倒）。在声明 <code>const</code> 变量时可以直接为其赋值，也可以使用其它的 <code>const</code> 变量为其赋值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">10</span>; <span class="comment">// 直接赋值 [Unit of pressure (dynes/cm2)]</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> j = <span class="number">1.01325</span> * i; <span class="comment">// 利用其它 const 变量赋值 </span></span><br></pre></td></tr></table></figure><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">  <iframe src="//player.bilibili.com/player.html?aid=712880942&bvid=BV1pD4y1X7sN&cid=260806935&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>本文所有代码都已上传到<a href="https://github.com/Johnson8888/learn_flutter">Github</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-6】Python教程之——数字</title>
      <link href="python-number-1-6.html"/>
      <url>python-number-1-6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>数字是一种用来表示数的书写符号：<br>中文数字写作三十七、卅七<br>罗马数字写作XXXVII<br>阿拉伯数字二进制写作100101</p></blockquote><p><a href="http://fulade.me/python-number-1-6.html">文章首发地址</a></p><p>作者 | 弗拉德<br>来源 | 弗拉德（公众号：fulade_me)</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a><strong>数字</strong></h4><p>在编程中，经常使用数字来记录游戏得分、表示可视化数据、存储Web应用信息等。Python 根据数字的用法以不同的方式处理它们。我们平时最常见的就是整数，下面就先来看看Python是如何管理整数的。</p><h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a><strong>整数</strong></h5><p>在Python中，可对整数执行加<code>+</code>减<code>-</code>乘<code>*</code>除<code>/</code>运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> - <span class="number">2</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> * <span class="number">3</span> </span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> / <span class="number">2</span> </span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure><p>在终端(命令行)会话中，Python直接返回运算结果。Python使用两个乘号表示乘方运算:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span> </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">3</span> </span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> ** <span class="number">6</span> </span><br><span class="line"><span class="number">1000000</span></span><br></pre></td></tr></table></figure><p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。当然我们也可以使用括号来修改运算次序，让Python按你指定的次序执行运算，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span>*<span class="number">4</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span> + <span class="number">3</span>) * <span class="number">4</span> </span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><strong>浮点数</strong></h5><p>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样 一个事实:小数点可出现在数字的任何位置。<br>每种编程语言都须细心设计，以妥善地处理浮点数， 确保不管小数点出现在什么位置，数字的行为都是正常的。<br>从很大程度上说，使用浮点数时都无需考虑其行为。你只需输入要使用的数字，Python通常都会按你期望的方式处理它们:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span> + <span class="number">0.2</span> <span class="number">9</span> <span class="number">0.4</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> * <span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">2</span> * <span class="number">0.2</span></span><br><span class="line"><span class="number">0.4</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，结果包含的小数位数可能是不确定的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span> + <span class="number">0.1</span> </span><br><span class="line"><span class="number">0.30000000000000004</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">0.1</span> </span><br><span class="line"><span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能<strong>精确</strong>地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略多余的小数位数即可。</p><h5 id="使用函数str-避免类型错误"><a href="#使用函数str-避免类型错误" class="headerlink" title="使用函数str()避免类型错误"></a><strong>使用函数str()避免类型错误</strong></h5><p>你经常需要在消息中使用变量的值。例如，假设你要祝别人生日快乐，可能会编写类似于下面的代码(将下面代码保存为<code>birthday.py</code>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + age + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>你可能认为，上述代码会打印一条简单的生日祝福语:<code>Happy 23rd birthday!</code>。但如果你运行这些代码，将发现它们会引发错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;birthday.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + age + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">TypeError: Can<span class="string">&#x27;t convert &#x27;</span><span class="built_in">int</span><span class="string">&#x27; object to str implicitly</span></span><br></pre></td></tr></table></figure><p>这是一个类型错误，意味着Python无法识别你使用的信息。在这个示例中，Python发现你使 用了一个值为整数(int)的变量，但它不知道该如何解读这个值(见)。Python知道，这个变 量表示的可能是数值23，也可能是字符2和3。像上面这样在字符串中使用整数时，需要显式地指 出你希望Python将这个整数用作字符串。为此，可调用函数str()，它让Python将非字符串值表示 为字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>这样，Python就知道你要将数值23转换为字符串，进而在生日祝福消息中显示字符2和3。经 过上述处理后，将显示你期望的消息，而不会引发错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy 23rd Birthday!</span><br></pre></td></tr></table></figure><p>大多数情况下，在Python中使用数字都非常简单。如果结果出乎意料，请检查Python是否按 你期望的方式将数字解读为了数值或字符串。</p><blockquote><p>小作业<br>6-1 编写 4 个表达式，它们分别使用加法、减法、乘法和除法运算，但结果都是数字 <code>8</code>。<br>为使用 print 语句来显示结果，务必将这些表达式用括号括起来，也就是说，你应该编写4行类似于下面的代码:<br><code>print(5 + 3)</code><br>输出应为 4 行，其中每行都只包含数字8。命名为<code>eight.py</code><br>6-2 将你最喜欢的数字存储在一个变量中，再使用这个变量创建一条消息，指出你最喜欢的数字，然后将这条消息打印出来。命名为<code>number.py</code></p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-0】10个学习Python的理由以及Python的优势有哪些？</title>
      <link href="/reason-learn-python-1-0.html"/>
      <url>/reason-learn-python-1-0.html</url>
      
        <content type="html"><![CDATA[<h4 id="Python的由来"><a href="#Python的由来" class="headerlink" title="Python的由来"></a><strong>Python的由来</strong></h4><p>Python的创始人是<a href="https://baike.baidu.com/item/%E5%90%89%E5%A4%9A%C2%B7%E8%8C%83%E7%BD%97%E8%8B%8F%E5%A7%86">吉多·范罗苏姆</a>，1989年他在阿姆斯特丹的CWI工作，圣诞节期间，吉多·范罗苏姆为了打发圣诞节的无聊，决定开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选择Python作为编程语言的名字，是因为他是BBC电视剧——蒙提·派森的飞行马戏团的爱好者。</p><h4 id="Python是什么"><a href="#Python是什么" class="headerlink" title="Python是什么"></a><strong>Python是什么</strong></h4><p>Python是一种被广泛使用的解释型、高级编程、通用型编程语言。Python支持多种编程范式，包括面向对象、结构化、指令式、函数式和反射式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个广泛的标准库。</p><h4 id="10个学习Python的理由"><a href="#10个学习Python的理由" class="headerlink" title="10个学习Python的理由"></a><strong>10个学习Python的理由</strong></h4><p>计算机语言已经出现很多年了，基本每隔10年就会出现一种新的编程语言，这多少让程序员们有些慌乱，不知道哪一种才是应该去学习和掌握的。<br>Python被认为是最受欢迎的编程语言之一。<br>在最近的<a href="https://stackoverflow.com/">Stack OverFlow</a>调查中，Python的热度已经超过了Java、C、C++，成为了第一。这也证明了Python是最受欢迎的语言之一。在这篇博客中，我将列出学习Python的10大理由。</p><h4 id="让我们拥抱Python吧"><a href="#让我们拥抱Python吧" class="headerlink" title="让我们拥抱Python吧"></a><strong>让我们拥抱Python吧</strong></h4><p>以下是列举的学习Python的10个理由：</p><ul><li>1.Python知名度高且容易拿到高薪</li><li>2.可应用于科研工作</li><li>3.脚本语言能够实现自动化</li><li>4.可应用于大数据</li><li>5.优秀的自动化测试功能</li><li>6.可开发桌面应用程序</li><li>7.可进行人工智能开发</li><li>8.支持Web服务开发</li><li>9.高可移植性和高可扩展性</li><li>10.上手简单学习容易</li></ul><p>Python语言正处于一个蓬勃发展的阶段，如果你考虑使用Python来解决一些问题，或者你想成为一名Python从业者，这正是学习和使用Python的好时机。<br>现在让我们来展开说一下这10个Python的优势：</p><h5 id="10-上手简单学习容易"><a href="#10-上手简单学习容易" class="headerlink" title="10.上手简单学习容易"></a><strong>10.上手简单学习容易</strong></h5><p>Python的语法跟自然语言很相似，使用起来非常简单。同时它又是非常强大的语言。<br>是什么使它如此简单呢，有以下几个特点：</p><ul><li>免费的 开源的</li><li>高级语言</li><li>解释型语言</li><li>有很多活跃的开发者社区</li></ul><p>在实际的编程过程中，Python的语法更简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用 Java 输出 &quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 用Python输出 &quot;Hello World&quot;</span></span><br><span class="line">print(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用<code>Java</code>语言输出<code>Hello World</code>，必须要写三行以上的代码，而使用<code>Python</code>语言一行就可以，如此简单的语法非常适合初学者。</p><h5 id="9-高可移植性和高可扩展性"><a href="#9-高可移植性和高可扩展性" class="headerlink" title="9.高可移植性和高可扩展性"></a><strong>9.高可移植性和高可扩展性</strong></h5><p>Python的可移植性体现在目前大多数平台都支持Python。它不仅能运行在Windows上，还可以运行在MacOS、Linux等平台上。<br>Python又被称为胶水语音，使用Python可以很方便的集成Java和.NET组件，同时也支持调用C和C++库。</p><h5 id="8-支持Web服务开发"><a href="#8-支持Web服务开发" class="headerlink" title="8.支持Web服务开发"></a><strong>8.支持Web服务开发</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_web_framework.jpg" alt="2020_10_10_python_web_framework"><br>Python有着一系列支持Web服务开发的框架，比较常见的框架有<a href="https://github.com/django/django">Django</a>、<a href="https://github.com/pallets/flask">Flask</a>、<a href="https://pylonsproject.org/">Pylons</a>等。这些框架都是用Python语言来实现的。<br>你可能也听说过用Python写爬虫来抓取数据，Python确实有着很多优秀的爬虫框架，比如<a href="https://scrapy.org/">Scrapy</a>、<a href="https://github.com/binux/pyspider">PySpider</a>、<a href="http://project.crawley-cloud.com/">Crawley</a>等等。</p><h5 id="7-可进行人工智能开发"><a href="#7-可进行人工智能开发" class="headerlink" title="7.可进行人工智能开发"></a><strong>7.可进行人工智能开发</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_artificial_intelligence.png" alt="2020_10_10_python_artificial_intelligence.png"><br>人工智能很可能就是下一次技术革命，Python同样可以用来开发人工智能，使用Python我们可以很简单的让机器模拟人的大脑，使机器具有思考、分析和决策的能力。<br>像 <a href="https://keras.io/">Keras</a>、<a href="https://www.tensorflow.org/">Tensorflow</a>、<a href="https://pytorch.org/">Pytorch</a>这些优秀的框架，本身就支持Python，我们只需要简单几行代码就可以体验到机器学习的乐趣。<br>在计算机视觉和图像识别上也有 <a href="https://github.com/opencv/opencv">OpenCV</a>这样优秀的框架，OpenCV也提供了大量的Python API。</p><h5 id="6-可开发桌面应用程序"><a href="#6-可开发桌面应用程序" class="headerlink" title="6.可开发桌面应用程序"></a><strong>6.可开发桌面应用程序</strong></h5><p><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_10_python_desktop_app_development.png" alt="2020_10_10_python_desktop_app_development"><br>不管是在大型、小型、离线、在线项目中都能看到Python的影子，使用Python可以很快的构建GUI程序和桌面程序。常见的框架有<a href="https://docs.python.org/3/library/tkinter.html">Tkinter</a>。<br>同样Python也可以应用于游戏开发，<a href="https://www.pygame.org/news">Pygame</a> 是Python开发的一个很优秀的游戏框架，它同样支持运行在Android设备上。</p><h5 id="5-优秀的自动化测试功能"><a href="#5-优秀的自动化测试功能" class="headerlink" title="5.优秀的自动化测试功能"></a><strong>5.优秀的自动化测试功能</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_testing.png" alt="2020_10_10_python_testing"><br>Python有许多内置的测试框架，涵盖了测试、调试、打包、发布等工作流。使用这些框架可以简化我们的日常工作流程，使测试工作更简单更准确。常见的框架有<a href="www.selenium.dev">Selenium</a> 和<a href="https://pypi.org/project/splinter/">Splinter</a> 。<br>像<a href="https://docs.pytest.org/en/stable/">PyTest</a> 和<a href="https://robotframework.org/">Robot Framework</a> 是常见的Python测试框架，这些框架都支持跨平台和跨浏览器的测试。<br>测试是一项繁琐的任务，Python可以帮我们做的更好，所以，每个测试人员都应该掌握一些Python技术！</p><h5 id="4-可应用于大数据"><a href="#4-可应用于大数据" class="headerlink" title="4.可应用于大数据"></a><strong>4.可应用于大数据</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_big_data.png" alt="2020_10_10_python_big_data"><br>Python是处理大数据的利器，它支持并行计算，我们也可以在 大数据框架<a href="https://hadoop.apache.org/">Hadoop</a> 中使用Python，只需要引入<a href="https://pypi.org/project/pydoop/">Pydoop</a>就可以了，是不是很简单呢！<br>还有<a href="https://dask.org/">Dask</a> 和<a href="https://pypi.org/project/pyspark/">Pyspark</a> 可用于大数据处理。所以说在大数据领域Python也有着广泛的应用，使用Python可以帮助我们轻松的应对大数据！</p><h5 id="3-脚本语言能够实现自动化"><a href="#3-脚本语言能够实现自动化" class="headerlink" title="3.脚本语言能够实现自动化"></a><strong>3.脚本语言能够实现自动化</strong></h5><p>Python不仅是一门编程语言，它也可以作为脚本语言来使用。我们将代码以脚本的形式编写并执行，机器读取返回结果并处理，在脚本执行过程中我们可以发现一些执行错误并作出调整。一旦执行成功，后面我们就可以多次重复执行此脚本，这样的自动化脚本可以帮助我们节省很多工作时间。比如Python脚本可以帮助我们解压缩100个压缩文件，可以帮助我们把大量的汉字转成拼音等等。任何繁琐的重复的机械的工作都可以用Python脚本来完成。</p><h5 id="2-Python可应用于科研数据"><a href="#2-Python可应用于科研数据" class="headerlink" title="2.Python可应用于科研数据"></a><strong>2.Python可应用于科研数据</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_data_science.png" alt="2020_10_10_data_science"><br>在科研领域同样有很多科学家使用Python。多年来，很多科研人员都在使用<a href="https://www.mathworks.com/products/matlab.html">MATLAB</a> 进行科学研究，随着Python的数字引擎(如<a href="https://numpy.org/">Numpy</a> 和 <a href="https://pandas.pydata.org/">Pandas</a>) 的发布，在科研领域也有很多人开始使用Python。<br>Python还可以处理大量数据表格、矩阵计算以及数据统计，也可以使用”<a href="https://matplotlib.org/">Matplotlib</a>“和”<a href="http://seaborn.pydata.org/">Seaborn</a>“等流行库来将数据和计算可视化。</p><h5 id="1-Python知名度高且容易拿到高薪"><a href="#1-Python知名度高且容易拿到高薪" class="headerlink" title="1.Python知名度高且容易拿到高薪"></a><strong>1.Python知名度高且容易拿到高薪</strong></h5><p>我们随便在招聘平台搜索一下北京的招聘信息，可以看到薪水还是很不错的。<br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_10_python_salary.png" alt="2020_10_10_python_salary"></p><p>这是<a href="https://baike.baidu.com/item/TIOBE">Tiobe</a>2020年发布的计算机语言排名。Python排在第三名。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_python_top.png" alt="2020_10_10_python_top"><br>下面是近10年来计算机语音的趋势图<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_10_year_laguage.png" alt="2020_10_10_year_laguage"><br>不难看出，在过去的几年中，Python的受欢迎程度增速迅猛。<br>最后，我希望我的博客“学习Python的十大理由”对您有帮助。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jauns-gateway 报错【No package &#39;libssl&#39; found No package &#39;libcrypto&#39; found】</title>
      <link href="tips-janus-openssl-1.html"/>
      <url>tips-janus-openssl-1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>No package ‘libssl’ found<br>No package ‘libcrypto’ found</p></blockquote><p><a href="http://fulade.me/tips-janus-openssl-1.html">文章首发地址</a></p><p>在Mac下配置janus-gateway服务器的时候遇到了找不到<code>libssl</code>和<code>libcrypto</code>错误，<br>详情如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">...</span><br><span class="line">checking for</span><br><span class="line">                    glib-2.0 &gt;&#x3D; 2.34</span><br><span class="line">libconfig</span><br><span class="line">                    nice</span><br><span class="line">                    jansson &gt;&#x3D; 2.5</span><br><span class="line">                    libssl &gt;&#x3D; 1.0.1</span><br><span class="line">                    libcrypto</span><br><span class="line">                    zlib</span><br><span class="line">                  ... no</span><br><span class="line">configure: error: Package requirements (</span><br><span class="line">                    glib-2.0 &gt;&#x3D; 2.34</span><br><span class="line">libconfig</span><br><span class="line">                    nice</span><br><span class="line">                    jansson &gt;&#x3D; 2.5</span><br><span class="line">                    libssl &gt;&#x3D; 1.0.1</span><br><span class="line">                    libcrypto</span><br><span class="line">                    zlib</span><br><span class="line">                  ) were not met:</span><br><span class="line"></span><br><span class="line">No package &#39;libssl&#39; found</span><br><span class="line">No package &#39;libcrypto&#39; found</span><br><span class="line"></span><br><span class="line">Consider adjusting the PKG_CONFIG_PATH environment variable if you</span><br><span class="line">installed software in a non-standard prefix</span><br></pre></td></tr></table></figure><p>只需要自定义<code>PKG_CONFIG_PATH</code>即可<br>在执行  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus PKG_CONFIG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure><p>之前在命令行内执行一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;pkgconfig:&#x2F;usr&#x2F;local&#x2F;opt&#x2F;libffi&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure><p>如果没有安装<code>libffi</code>,可以使用 <code>Home brew</code>安装一下就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-5】Python教程之——字符串</title>
      <link href="python-string-1-5.html"/>
      <url>python-string-1-5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。   </p></blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4><p>字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号， 也可以是双引号，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is a string.&quot;</span>   </span><br><span class="line"><span class="string">&#x27;This is also a string.&#x27;</span></span><br></pre></td></tr></table></figure><p>这种灵活性让你能够在字符串中包含引号和撇号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I told my friend, &quot;Python is my favorite language!&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;The language &#x27;Python&#x27; is named after Monty Python, not the snake.&quot;</span> </span><br><span class="line"><span class="string">&quot;One of Python&#x27;s strengths is its diverse and supportive community.&quot;</span></span><br></pre></td></tr></table></figure><p><a href="http://fulade.me/python-string-1-5.html">文章首发地址</a></p><h4 id="使用方法修改字符串的大小写"><a href="#使用方法修改字符串的大小写" class="headerlink" title="使用方法修改字符串的大小写"></a><strong>使用方法修改字符串的大小写</strong></h4><p>对于字符串，可执行的最简单的操作之一是修改其中的单词的大小写。<br>请看下面的代码，并尝试判断其作用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;fulade blog&quot;</span> </span><br><span class="line">print(name.title())</span><br><span class="line">```  </span><br><span class="line">将这个文件保存为`name.py`，再运行它。你将看到如下输出:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Fulade Blog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这个示例中，小写的字符串&quot;fulade blog&quot;存储到了变量name中。在&#96;print()&#96;语句中，方法 &#96;title()&#96;出现在这个变量的后面。在&#96;name.title()&#96;中，name后 面的句点(.)让Python对变量name执行方法&#96;title()&#96;的操作。每个方法后面都跟着一对括号， 这是因为方法通常需要一些参数来完成其工作。这些参数往往写在括号内的。方法&#96;title()&#96;不需要参数，因此它后面的括号是空的。</span><br><span class="line">&#96;title()&#96;的实现结果是以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。</span><br><span class="line">还有几个其他的很有用的处理大小写的方法。例如，要将符串改为全部大写或全部小写，可以像下面这样做:</span><br><span class="line">&#96;&#96;&#96; Python</span><br><span class="line">name &#x3D; &quot;Fulade Blog&quot;  </span><br><span class="line">print(name.upper()) </span><br><span class="line">print(name.lower())</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FULADE BLOG</span><br><span class="line">fulade blog</span><br></pre></td></tr></table></figure><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a><strong>拼接字符串</strong></h4><p>在很多情况下，我们需要合并字符串。例如，你可能想将姓和名存储在不同的变量中，等要显示姓名时再将它们合而为一:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;Fu&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lade&quot;</span></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line">print(full_name)</span><br></pre></td></tr></table></figure><p>Python使用加号(+)来合并字符串。在这个示例中，我们使用<code>+</code>来合并first_name、空格和<br>last_name，以得到完整的姓名，其结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu lade</span><br></pre></td></tr></table></figure><p>这种合并字符串的方法称为拼接。通过拼接，可使用存储在变量中的字符串来创建完整的字符串。下面来看另外一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;fu&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lade&quot;</span></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line">message = <span class="string">&quot;Hello, &quot;</span> + full_name.title() + <span class="string">&quot;!&quot;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>上述代码显示消息”Hello, Fu Lade!”，但将这条消息存储在了一个变量中， 这让最后的<code>print</code>语句简单得多。</p><h4 id="使用制表符-按Tab键产生空格的叫做制表符-或换行符来添加空白"><a href="#使用制表符-按Tab键产生空格的叫做制表符-或换行符来添加空白" class="headerlink" title="使用制表符(按Tab键产生空格的叫做制表符)或换行符来添加空白"></a><strong>使用制表符(按Tab键产生空格的叫做制表符)或换行符来添加空白</strong></h4><p>在编程中，空白泛指任何非打印字符，如空格、制表符和换行符。你可使用空白来组织输出，使输出更易读。<br>要在字符串中添加制表符，可使用字符组合<code>\t</code>，如下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">Python</span><br><span class="line">print(<span class="string">&quot;\tPython&quot;</span>)</span><br><span class="line">    Python</span><br></pre></td></tr></table></figure><p>要在字符串中添加换行符，可使用字符组合<code>\n</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Languages:\nPython\nC\nJavaScript&quot;</span>) </span><br><span class="line">Languages:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">JavaScript</span><br></pre></td></tr></table></figure><p>还可在同一个字符串中同时包含制表符和换行符。字符串”\n\t”让Python换到下一行，并在<br>  下一行开头添加一个制表符。下面的示例演示了如何使用一个单行字符串来生成四行输出:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Languages:\n\tPython\n\tC\n\tJavaScript&quot;</span>) </span><br><span class="line">Languages:</span><br><span class="line">    Python</span><br><span class="line">    C </span><br><span class="line">    JavaScript</span><br></pre></td></tr></table></figure></p><h4 id="删除空白和空格"><a href="#删除空白和空格" class="headerlink" title="删除空白和空格"></a><strong>删除空白和空格</strong></h4><p>在程序中，多余的空白可能令人迷惑。对程序员来说，<code>&#39;python&#39;</code>和<code>&#39;python &#39;</code>看起来几乎没什么两样，但对编译器来说，它们却是两个不同的字符串。Python能够发现’python ‘中多余的空格，并认为它是有意义的——除非你告诉它不是这样的。<br>空格很重要，因为你经常需要比较两个字符串是否相同。例如，在用户登陆网站的时候，我们需要对比用户名。但在有些场景下我们并不想要空格。所以，Python提供了很简单的删除空格的方法。<br>Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法 <code>rstrip()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27;python &#x27;&quot;</span> </span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python &#x27;</span></span><br><span class="line">print(favorite_language.rstrip())</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python &#x27;</span> </span><br></pre></td></tr></table></figure><p>存储在变量<code>favorite_language</code>中的字符串末尾包含多余的空格。你在运行这个代码的时候，可看到末尾的空格。对变量<code>favorite_language</code>调用方法 <code>rstrip()</code>后，这个多余的空格被删除了。然而，这种删除只是暂时的，接下来再次输出<code>favorite_language</code>的值时，你会发现这个字符串与输入时一样，依然包含多余的空格。<br>要永久删除这个字符串中的空格，必须将删除操作的结果保存回到变量中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27;python &#x27;&quot;</span></span><br><span class="line">favorite_language = favorite_language.rstrip()</span><br><span class="line">print(favorite_language)</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br></pre></td></tr></table></figure><p>为删除这个字符串中的空格，你需要将其末尾的空格剔除，再将结果存回到原来的变量中。<br>在我们的日常开发中，经常需要修改变量的值，再将新值存回到原来的变量中。<br>你还可以剔除字符串开头的空格，或同时剔除字符串两端的空格。为此，可分别使用方法 <code>lstrip()</code>和<code>strip()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&quot;&#x27; python &#x27;&quot;</span> </span><br><span class="line">print(favorite_language.rstrip())</span><br><span class="line"><span class="string">&#x27; python&#x27;</span></span><br><span class="line">print(favorite_language.lstrip())</span><br><span class="line"><span class="string">&#x27;python &#x27;</span></span><br><span class="line">print(favorite_language.strip())</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个开头和末尾都有空格的字符串。接下来，我们 分别删除末尾、开头两端的空格。在实际程序开发中，这些剔除函数最常用于在存储用户输入前对输入进行清理。</p><h4 id="使用字符串时避免语法错误"><a href="#使用字符串时避免语法错误" class="headerlink" title="使用字符串时避免语法错误"></a><strong>使用字符串时避免语法错误</strong></h4><p>语法错误是一种经常会出现的错误。程序中包含非法的Python代码时，就会导致语法错误。 例如，在用单引号括起的字符串中，如果包含撇号，就将导致错误。这是因为这会导致Python将 第一个单引号和撇号之间的内容视为一个字符串，进而将余下的文本视为Python代码，从而引发 错误。<br>下面演示了如何正确地使用单引号和双引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;One of Python&#x27;s strengths is its diverse community.&quot;</span> </span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><p>撇号位于两个双引号之间，因此Python解释器能够正确地理解这个字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One of Python<span class="string">&#x27;s strengths is its diverse community.</span></span><br></pre></td></tr></table></figure><p>然而，如果你使用单引号，Python将无法正确地确定字符串的结束位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;One of Python&#x27;</span>s strengths <span class="keyword">is</span> its diverse community.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">print(message)</span></span><br></pre></td></tr></table></figure><p>而你将看到如下输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;One of Python&#x27;</span>s strengths <span class="keyword">is</span> its diverse community.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">SyntaxError: invalid syntax</span></span><br></pre></td></tr></table></figure><p>从上面的输出我们可以看到，错误发生在第二个单引号后面。这种语法错误表明，在解释器看来，其中的有些内容不是有效的Python代码。错误的来源多种多样，这里指出一些常见的。学习 编写Python代码时，你可能会经常遇到语法错误。</p><p>所以，大家在做练习的时候也要细心，避免出现这种小错误。</p><blockquote><p>小作业<br>在做下面的每个练习时，都编写一个独立的程序，并将其保存为名称类似于 <code>name_cases.py</code> 的文件。<br>2-1 个性化消息:将用户的姓名存到一个变量中，并向该用户显示一条消息。显示 的消息应非常简单，如“Hello Eric, would you like to learn some Python today?”。<br>2-2 调整名字的大小写:将一个人名存储到一个变量中，再以小写、大写和首字母 大写的方式显示这个人名。<br>2-3 名言:找一句你钦佩的名人说的名言，将这个名人的姓名和他的名言打印出来。输出应类似于下面这样(包括引号):<br>Albert Einstein once said, “A person who never made a mistake never tried anything new.”<br>2-4 名言 【重复练习 2-3】，但将名人的姓名存储在变量 famous_person 中，再创建 要显示的消息，并将其存储在变量 message 中，然后打印这条消息。<br>2-5 剔除人名中的空白:存储一个人名，并在其开头和末尾都包含一些空白字符。 务必至少使用字符组合”\t”和”\n”各一次。<br>打印这个人名，以显示其开头和末尾的空白。然后，分别使用剔除函数 lstrip()、 rstrip()和 strip()对人名进行处理，并将结果打印出来。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-4】Python教程之——变量</title>
      <link href="python-variable-1-4.html"/>
      <url>python-variable-1-4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>变量来源于《数学》<br>是计算机语言中能储存计算结果或能表示值的抽象概念。<br><a href="http://fulade.me/python-variable-1-4.html">文章首发地址</a></p></blockquote><h5 id="运行hello-world-py时发生了什么"><a href="#运行hello-world-py时发生了什么" class="headerlink" title="运行hello_world.py时发生了什么"></a><strong>运行hello_world.py时发生了什么</strong></h5><p>运行hello_world.py时，Python都做了些什么呢?下面来深入研究一下。实际上，即便是运行简单的程序，Python所做的工作也相当多:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello Python World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码代码时，你将看到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python World!</span><br></pre></td></tr></table></figure><p>运行文件hello_world.py时，末尾的.py指出这是一个Python程序，因此编辑器将使用Python解释器来运行它。<br>Python解释器读取整个程序，确定其中每个单词的含义。例如，看到单词<code>print</code>时，解释器就会将括号中的内容打印到屏幕，而不会管括号中的内容是什么。<br>编写程序时，编辑器会以各种方式突出程序的不同部分。例如，它知道print是一个函数的名称，因此将其显示为蓝色；它知道”Hello Python world!”不是Python代码，因此将其显示为另一种颜色。这种功能称为<code>语法突出</code>。</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h5><p>下面来尝试在hello_world.py中使用一个变量。在这个文件开头添加一行代码，并对代码进行修改，修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span> </span><br><span class="line">print(message) </span><br></pre></td></tr></table></figure><p>运行这个程序，看看结果如何。你会发现，输出跟前面一样：<br><code>Hello Python world! </code><br>我们添加了一个名为<code>message</code>的变量。每个变量都存储了一个值——与变量相关联的信息。<br>在这里，存储的值为文本”Hello Python world!”。<br>添加变量导致Python解释器需要做更多工作。处理第1行代码时，它将文本”Hello Python world!”与变量<code>message</code>关联起来；而处理第2行代码时，它将与变量<code>message</code>关联的值打印到屏幕。</p><p>下面来进一步扩展这个程序：修改hello_world.py，使其再打印一条消息。为此，在<br><code>hello_world.py</code>中添加一个空行，再添加下面两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span> </span><br><span class="line">print(message)</span><br><span class="line">message = <span class="string">&quot;Hello Python Crash Course world!&quot;</span> </span><br><span class="line">print(message) </span><br></pre></td></tr></table></figure><p>现在如果运行这个程序，将看到两行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Python world! </span><br><span class="line">Hello Python Crash Course world! </span><br></pre></td></tr></table></figure><p>在程序中可随时修改变量的值，而Python将始终记录变量的最新值。</p><h5 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a><strong>变量的命名</strong></h5><p>我们在命名变量的是应该遵循一定的规则，不能想怎么写就怎么写，简单来说有以下几个规则：</p><ul><li><p>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打<br>头，例如，可将变量命名为message_1，但不能将其命名为1_message。 </p></li><li><p>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message<br>可行，但变量名greeting message会引发错误。</p></li><li><p>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如<code>print</code>。</p></li><li><p>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length<br>比length_of_persons_name好。</p></li><li><p>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。    </p></li></ul><p>要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着我们写的代码越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。</p><blockquote><p>小作业<br>请完成下面的练习，在做每个练习时，都编写一个独立的程序。保存每个程序时，使用符合标准 Python 约定的文件名：使用小写字母和下划线，如 simple_message.py 和simple_messages.py。<br>1-1 简单消息：将一条消息存储到变量中，再将其打印出来。<br>1-2 多条简单消息：将一条消息存储到变量中，将其打印出来；再将变量的值修改<br>为一条新消息，并将其打印出来。</p></blockquote><p>想查看作业答案可以去<a href="https://github.com/Johnson8888/learn_python">我的Githu仓库</a></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一台电脑2个或多个Git账号如何配置和管理</title>
      <link href="git-multiple-user.html"/>
      <url>git-multiple-user.html</url>
      
        <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h4><p>由于我在公司的Git源码服务器有一套账号和密码，我个人的Github又有一套账号和密码，这两个账号都需要PUSH和PULL代码，如果对Git使用的不太熟练，经常会遇到<code>git@github.com: Permission denied (publickey)</code>这种错误，那么我们该如何同时管理多个Git账号呢？</p><p>这里我们以MacOS系统为例。</p><h5 id="同一台电脑两个Git账号且账号相同"><a href="#同一台电脑两个Git账号且账号相同" class="headerlink" title="同一台电脑两个Git账号且账号相同"></a><strong>同一台电脑两个Git账号且账号相同</strong></h5><p>这里所说的账号相同，指的是：邮箱相同。比如我在公司Gitlab用的账号和Github的账号就是同一个邮箱，这种情况比较好处理，Gitlab和Github在校验的时候是只认邮箱的。只要我们把秘钥，也就是 <code>id_ras.pub</code>里面的内容在Gitlab和Github上都配置好就可以了。也就说多个Git源码服务器且都是使用同一个邮箱的情况下，我们只要把<code>id_ras.pub</code>配置到多个源码服务器就OK了！</p><h5 id="同一台电脑多个账号且账号不同"><a href="#同一台电脑多个账号且账号不同" class="headerlink" title="同一台电脑多个账号且账号不同"></a><strong>同一台电脑多个账号且账号不同</strong></h5><p>这个时候就需要我们指明哪个账号使用哪一个<code>.pub</code>文件了。我们需要在<code>~/.ssh</code>文件夹下创建名为<code>config</code>的文件，如果已经存在了该文件则需要修改一下。<br><code>config</code>的内容参考以下写法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 第一个账号为 </span></span><br><span class="line"><span class="comment"># Email:fulade1@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade1</span></span><br><span class="line"></span><br><span class="line">host gitlab.ttal.com</span><br><span class="line">    hostname gitlab.ttal.com</span><br><span class="line">    Port 65095</span><br><span class="line">    User fulade1</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个账号为 </span></span><br><span class="line"><span class="comment"># Email:fulade2@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade2</span></span><br><span class="line"></span><br><span class="line">host gitlab-test.ttal.com</span><br><span class="line">    hostname gitlab.ttal.com</span><br><span class="line">    Port 65095</span><br><span class="line">    User fulade2</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa_second</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个账号 </span></span><br><span class="line"><span class="comment"># Email:fulade2@gmail.com  </span></span><br><span class="line"><span class="comment"># User:fulade2</span></span><br><span class="line"></span><br><span class="line">host github.com</span><br><span class="line">    hostname github.com</span><br><span class="line">    Port 22</span><br><span class="line">    User fulade2</span><br><span class="line">    IdentityFile /home/Fulade/.ssh/id_rsa_second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中第二个账号跟第三个账号相同，只是源码服务器不同。</span></span><br></pre></td></tr></table></figure><p>因为配置了多个邮箱账号，所有git的global配置就要删除了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消全局配置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure><p>然后在每个Repo下配置账号就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个项目Repo设置自己的user.email</span></span><br><span class="line">git config  user.email <span class="string">&quot;xxxx@xx.com&quot;</span></span><br><span class="line">git config  user.name <span class="string">&quot;fulade&quot;</span></span><br></pre></td></tr></table></figure><p>这样就可以了。</p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><p>指定<code>.pub</code>文件路径的方法：<br>需要使用命令<code>ssh-keygen -t rsa -C &quot;fulade@gmail.com&quot;</code>，接下来输入路径就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;fulade@gmail.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/Fulade/.ssh/id_rsa):/Users/Fulade/.ssh/id_rsa_second</span><br></pre></td></tr></table></figure><p>其中<code>/Users/Fulade/.ssh/id_rsa_second</code>是要输入的部分。<br>Have Fun !</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】Flutter系列、Python系列目录</title>
      <link href="/top_index.html"/>
      <url>/top_index.html</url>
      
        <content type="html"><![CDATA[<h5 id="目前有两个系列-Flutter-和-Python稳定更新。"><a href="#目前有两个系列-Flutter-和-Python稳定更新。" class="headerlink" title="目前有两个系列 Flutter 和 Python稳定更新。"></a>目前有两个系列 <a href="http://fulade.me/categories/Flutter/">Flutter</a> 和 <a href="http://fulade.me/categories/Python/">Python</a>稳定更新。</h5><p>还有一些Tips不定时更新。</p><h3 id="Flutter系列"><a href="#Flutter系列" class="headerlink" title="Flutter系列"></a><strong>Flutter系列</strong></h3><p><a href="http://fulade.me/why-flutter-1-1.html">Flutter的8优势以及为什么要在下一个项目中尝试Flutter</a></p><h5 id="Flutter安装与运行"><a href="#Flutter安装与运行" class="headerlink" title="Flutter安装与运行"></a><strong>Flutter安装与运行</strong></h5><p><a href="http://fulade.me/windows-install-flutter.html">【Flutter1-1】在 Windows 10下配置Flutter开发环境</a><br><a href="http://fulade.me/not-support-vt-x.html">【Flutter1-2】在VMWare Android Studio 安装模拟器报错 Your CPU does not support VT-x</a><br><a href="http://fulade.me/windows-vscode-flutter-1-4.html">【Flutter1-3】Windows下VSCode配置Flutter开发环境</a><br><a href="http://fulade.me/flutter-hello-word-1-5.html">【Flutter1-4】运行Flutter的第一个项目——计数器</a><br><a href="http://fulade.me/flutter-hello-word-1-5.html">【Flutter1-5】Flutter项目目录结构</a><br><a href="http://fulade.me/flutter-project-files-1-6.html">【Flutter 1-6】Flutter项目目录结构</a></p><h5 id="Dart语音基础"><a href="#Dart语音基础" class="headerlink" title="Dart语音基础"></a><strong>Dart语音基础</strong></h5><p><a href="http://fulade.me/dart-variable-1-7.html">【Flutter 1-7】Flutter教程Dart语言——变量</a><br><a href="http://fulade.me/dart-control-flow-statements-1-8.html">【Flutter 1-8】Flutter教程Dart语言——控制语句</a><br><a href="http://fulade.me/dart-functions-1-9.html">【Flutter 1-9】Flutter教程Dart语言——函数和匿名函数</a><br><a href="http://fulade.me/dart-operator-1-10.html">【Flutter 1-10】Flutter手把手教程Dart语言——运算符</a><br><a href="http://fulade.me/dart-class-1-11.html">【Flutter 1-11】Flutter手把手教程Dart语言——类、类的的成员变量和方法、类的构造函数</a><br><a href="http://fulade.me/dart-generic-1-12.html">【Flutter 1-12】Flutter手把手教程Dart语言——什么是泛型和泛型的使用场景</a><br><a href="http://fulade.me/dart-asynchronous-1-13.html">【Flutter 1-13】Flutter手把手教程Dart语言——异步、Future、Stream、async、await详解</a><br><a href="http://fulade.me/dart-package-1-14.html">【Flutter 1-14】Flutter手把手教程Dart语言——Dart语言引用、import、package使用</a><br><a href="http://fulade.me/dart-pub-command-1-15.html">【Flutter 1-15】Flutter手把手教程Dart语言——包管理工具Pub详解、pub get,pub cache使用</a></p><h5 id="Flutter-UI-基础"><a href="#Flutter-UI-基础" class="headerlink" title="Flutter UI 基础"></a><strong>Flutter UI 基础</strong></h5><p><a href="http://fulade.me/flutter-ui-text-widget-2-1.html">【Flutter 2-1】Flutter手把手教程UI布局和Widget——文本和样式 Text Widget</a><br><a href="http://fulade.me/flutter-ui-button-widget-2-2.html">【Flutter 2-2】Flutter手把手教程UI控件——【多图预警】按钮RaisedButton、FlatButton、OutlineButton、IconButton</a><br><a href="http://fulade.me/flutter-ui-container-widget-2-3.html">【Flutter 2-3】Flutter手把手教程UI布局和Widget——容器控件Container</a><br><a href="http://fulade.me/flutter-ui-stateful-widget-2-4.html">【Flutter 2-4】Flutter手把手教程UI布局和Widget——Statelesswidget与Statefulwidget</a><br><a href="http://fulade.me/flutter-ui-textfield-widget-2-5.html">【Flutter 2-5】Flutter手把手教程UI布局和Widget——TextField使用、搭配InputDecoration和FocusedNode使用</a><br><a href="http://fulade.me/flutter-ui-image-widget-2-6.html">【Flutter 2-6】Flutter手把手教程UI布局和Widget——Image控件、NetworkImage、AssetImage</a><br><a href="http://fulade.me/flutter-ui-column-widget-2-7.html">【Flutter 2-7】Flutter手把手教程UI布局和Widget——垂直布局控件Column</a><br><a href="http://fulade.me/flutter-ui-row-widget-2-8.html">【Flutter 2-8】Flutter手把手教程UI布局和Widget——水平布局控件Row</a><br><a href="http://fulade.me/flutter-ui-flexible-widget-2-9.html">【Flutter 2-9】Flutter手把手教程UI布局和Widget——弹性布局控件Flexible</a><br><a href="http://fulade.me/flutter-ui-warp-widget-2-10.html">【Flutter 2-10】Flutter手把手教程UI布局和Widget——流式布局Wrap</a><br><a href="http://fulade.me/flutter-ui-listview-widget-2-11.html">【Flutter 2-11】Flutter手把手教程UI布局和Widget——列表ListView</a><br><a href="http://fulade.me/flutter-ui-gridview-widget-2-12.html">【Flutter 2-12】Flutter手把手教程UI布局和Widget——网格列表GridView</a></p><h5 id="Flutter-进阶-基础"><a href="#Flutter-进阶-基础" class="headerlink" title="Flutter 进阶 基础"></a><strong>Flutter 进阶 基础</strong></h5><p><a href="http://fulade.me/flutter-high-bottomnavigationbar-widget-3-1.html">【Flutter 3-1】Flutter进阶教程——底部导航栏BottomNavigationBar使用</a><br><a href="http://fulade.me/flutter-high-router-widget-3-2.html">【Flutter 3-2】Flutter进阶教程——路由Router和导航Navigator以及传值</a><br><a href="http://fulade.me/flutter-high-request-3-3.html">【Flutter 3-3】Flutter进阶教程——http请求和FutureBuilder</a><br><a href="http://fulade.me/flutter-high-sqflite-3-4.html">【Flutter 3-4】Flutter进阶教程——数据持久化sqflite使用</a></p><hr><h3 id="Python系列"><a href="#Python系列" class="headerlink" title="Python系列"></a><strong>Python系列</strong></h3><p><a href="http://fulade.me/reason-learn-python-1-0.html">【Python1-0】10个学习Python的理由以及Python的优势有哪些？</a></p><h5 id="Python安装与运行"><a href="#Python安装与运行" class="headerlink" title="Python安装与运行"></a><strong>Python安装与运行</strong></h5><p><a href="http://fulade.me/windows-install-python-1-1.html">【Python1-1】Windows 10 安装Python3环境</a><br><a href="http://fulade.me/vscode-install-python-1-2.html">【Python1-2】Visual Studio Code(VSCode) 配置 Python开发环境</a><br><a href="http://fulade.me/python-run-helloword-1-3.html">【Python1-3】Python的第一个程序 Hello World</a></p><h5 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a><strong>Python基础</strong></h5><p><a href="http://fulade.me/python-variable-1-4.html">【Python 1-4】Python教程之——变量</a><br><a href="http://fulade.me/python-string-1-5.html">【Python 1-5】Python教程之——字符串</a><br><a href="http://fulade.me/python-number-1-6.html">【Python 1-6】Python教程之——数字</a><br><a href="http://fulade.me/python-list-7.html">【Python 1-7】Python手把手教程之——详解列表List</a><br><a href="http://fulade.me/python-handle-list-1-8.html">【Python 1-8】Python手把手教程之——管理列表List</a><br><a href="http://fulade.me/python-tuple-1-9.html">【Python 1-9】Python手把手教程之——元组和元组的使用技巧</a><br><a href="http://fulade.me/python-if-control-1-10.html">【Python 1-10】Python手把手教程之——一篇讲透if语句以及if语句的特殊用法</a><br><a href="http://fulade.me/python-dict-1-11.html">【Python 1-11】Python手把手教程之——字典的用法和对字典的管理</a><br><a href="http://fulade.me/python-input-12.html">【Python 1-12】Python手把手教程之——用户输入input函数</a><br><a href="http://fulade.me/python-functions-1-13.html">【Python 1-13】Python手把手教程之——详解函数和函数的使用</a><br><a href="http://fulade.me/python-functions-1-14.html">【Python 1-14】Python手把手教程之——详解函数的高级用法</a><br><a href="http://fulade.me/python-class-1-15.html">【Python 1-15】Python手把手教程之——详解类Class以及类的使用</a><br><a href="http://fulade.me/python-class-1-16.html">【Python 1-16】Python手把手教程之——类Class的继承、父类、子类</a><br><a href="http://fulade.me/python-file-1-17.html">【Python 1-17】Python手把手教程之——文件的读写以及I/O操作</a><br><a href="http://fulade.me/python-error-1-18.html">【Python 1-18】Python手把手教程之——异常处理、try-except、error</a></p><hr><h4 id="其他系列"><a href="#其他系列" class="headerlink" title="其他系列"></a><strong>其他系列</strong></h4><p><a href="http://fulade.me/how-to-set-up-hexo-blog.html">1. Mac下使用GitHub+Hexo搭建个人博客</a><br><a href="http://fulade.me/tips-janus-openssl-1.html">2. Jauns-gateway 报错【No package ‘libssl’ found No package ‘libcrypto’ found】</a><br><a href="http://fulade.me/tips-jd-auto-sigh-2.html">3. 是时候来薅京东的羊毛了，自动化签到脚本！</a></p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h4><h5 id="目前只有两个系列-Flutter-和-Python"><a href="#目前只有两个系列-Flutter-和-Python" class="headerlink" title="目前只有两个系列 Flutter 和 Python"></a>目前只有两个系列 <a href="http://fulade.me/categories/Flutter/">Flutter</a> 和 <a href="http://fulade.me/categories/Python/">Python</a></h5><h5 id="如果大家有喜欢的教程尽管留言，我也会考虑更新。"><a href="#如果大家有喜欢的教程尽管留言，我也会考虑更新。" class="headerlink" title="如果大家有喜欢的教程尽管留言，我也会考虑更新。"></a>如果大家有喜欢的教程尽管留言，我也会考虑更新。</h5><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 说明 </tag>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-5】运行Flutter的第一个项目——计数器</title>
      <link href="/flutter-hello-word-1-5.html"/>
      <url>/flutter-hello-word-1-5.html</url>
      
        <content type="html"><![CDATA[<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h4><p>创建Flutter项目有很多种方法，各个IDE工具也都集成了创建Flutter项目的快捷操作。我们这里列举三种方式：使用命令行创建、使用Android Studio创建和使用VSCode创建。</p><blockquote><p>文末附有视频教程</p></blockquote><ul><li>使用命令行创建<br>在Flutter安装完之后，我们就已经配置好了命令行工具，命令行工具很强大，可以满足我们日常开发Flutter的所有操作（如果你还没有安装好Flutter环境，可以参考<a href="http://fulade.me/2020/09/28/windows-install-flutter/">这里</a>来安装）。<br>我们只需要打开命令行工具 输入:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create flutter_app</span><br></pre></td></tr></table></figure>  其中 <code>flutter_app</code>是我们项目的名字。</li><li>使用 Android Studio 创建<br>我们打开 Android Studio，点击左上角 <code>File</code>-&gt;<code>New</code>-&gt;<code>New Flutter Project</code> 即可。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_android_create.png" alt="2020_10_25_android_create"></li><li>使用 VSCode创建<br>点击VSCode上方按钮 <code>View</code>-&gt;<code>Command Palette..</code><br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_view.png" alt="2020_10_25_vscode_view.png"><br>然后在弹出的输入框内输入关键字<code>flutter</code>回车就可以了创建项目了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_flutter.png" alt="2020_10_25_vscode_flutter"></li></ul><h4 id="使用Android-Studio-运行-计数器项目"><a href="#使用Android-Studio-运行-计数器项目" class="headerlink" title="使用Android Studio 运行 计数器项目"></a><strong>使用Android Studio 运行 计数器项目</strong></h4><p>用 Android Studio打开我们刚刚创建的项目<code>flutter_app</code><br>打开之后我们先选择一下模拟器，然后直接点击运行就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_android_select_device.png" alt="2020_10_25_android_select_device"></p><h4 id="使用VSCode-运行-计数器项目"><a href="#使用VSCode-运行-计数器项目" class="headerlink" title="使用VSCode 运行 计数器项目"></a><strong>使用VSCode 运行 计数器项目</strong></h4><p>用VSCode打开项目<code>flutter_app</code>，找到目录下的 <code>main.dart</code>文件打开<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_main_dart.png" alt="2020_10_25_vscode_main_dart"><br>然后点击右上角运行按钮就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_run.png" alt="2020_10_25_vscode_run"></p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=245172764&bvid=BV1wv411r7Po&cid=251359013&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-6】Flutter项目目录结构</title>
      <link href="/flutter-project-files-1-6.html"/>
      <url>/flutter-project-files-1-6.html</url>
      
        <content type="html"><![CDATA[<h5 id="Flutter项目结构"><a href="#Flutter项目结构" class="headerlink" title="Flutter项目结构"></a><strong>Flutter项目结构</strong></h5><p>了解Flutter的目录结构，可以帮助我们更好的管理和开发项目。这样我们在开发的过程中就会很清楚的知道，iOS代码该放在那里，Android代码该放在那里，Flutter代码该放在哪里，测试代码放在哪里等等。</p><p>我们以<a href="http://fulade.me/2020/10/25/flutter-hello-word-1-5/">上一节</a>中创建的<code>flutter_app</code>为例，我们用VSCode打开它。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_25_vscode_main_dart.png" alt="2020_10_25_vscode_main_dart"><br>如图，我们看到了下面这些目录：  </p><table><thead><tr><th>文件或目录</th><th>说明</th></tr></thead><tbody><tr><td>.dart_tool</td><td>记录了一些dart工具库所在的位置和信息</td></tr><tr><td>.idea</td><td>android studio 是基于idea开发的，.idea 记录了项目的一些文件的变更记录</td></tr><tr><td>android</td><td>Android项目文件夹</td></tr><tr><td>ios</td><td>iOS项目文件夹</td></tr><tr><td>lib</td><td>lib文件夹内存放我们的dart语音代码</td></tr><tr><td>test</td><td>用于存放我们的测试代码</td></tr><tr><td>.gitignore</td><td>git忽略配置文件</td></tr><tr><td>.metadata</td><td>IDE 用来记录某个 Flutter 项目属性的的隐藏文件</td></tr><tr><td>.packages</td><td>pub 工具需要使用的，包含 package 依赖的 yaml 格式的文件</td></tr><tr><td>flutter_app.iml</td><td>工程文件的本地路径配置</td></tr><tr><td>pubspec.lock</td><td>当前项目依赖所生成的文件</td></tr><tr><td>pubspec.yaml</td><td>当前项目的一些配置文件，包括依赖的第三方库、图片资源文件等</td></tr><tr><td>README.md</td><td>READEME文件</td></tr></tbody></table><h5 id="比较重要的四个文件夹是-android、ios、lib、test"><a href="#比较重要的四个文件夹是-android、ios、lib、test" class="headerlink" title="比较重要的四个文件夹是 android、ios、lib、test"></a><strong>比较重要的四个文件夹是 android、ios、lib、test</strong></h5><ul><li>lib<br>我们日常开发的dart语言代码都放在这里，可以说是我们的“核心工作文件夹”</li><li>ios<br>这里面包含了iOS项目相关的配置和文件，当我们的项目需要打包上线的时候，需要打开该文件内的<code>Runner.xcworkspace</code>文件进行编译和打包工作。</li><li>android<br>与<code>ios</code>文件夹一样，在android项目需要打包上架的时候，也需要使用此文件夹里面的文件。同样的如果我们需要原生代码的支持，原生代码也是放在这里。</li><li>test<br>这里存放了我们在项目开发过程中的测试代码，良好的测试习惯是保证代码质量的必要手段，希望大家在<code>test</code>文件里写更多的代码！</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-2】Visual Studio Code(VSCode) 配置 Python开发环境</title>
      <link href="/vscode-install-python-1-2.html"/>
      <url>/vscode-install-python-1-2.html</url>
      
        <content type="html"><![CDATA[<h5 id="使用-VSCode-作为开发Python的IDE工具"><a href="#使用-VSCode-作为开发Python的IDE工具" class="headerlink" title="使用 VSCode 作为开发Python的IDE工具"></a><strong>使用 VSCode 作为开发Python的IDE工具</strong></h5><p>IDE(Integrated Development Environment, 集成开发环境)，目前支持Python的IDE有很多。有PyCharm、Eclipse、Atom、Anaconda、Sublime Text等等。我个人更喜欢使用 Visual Studio Code 也就是 VSCode。如果大家有自己喜欢的IDE工具，尽情享用！<br><a href="http://fulade.me/2020/10/20/vscode-install-python-1-2/">文章首发地址</a></p><h5 id="在-VSCode-里面安装Python扩展工具"><a href="#在-VSCode-里面安装Python扩展工具" class="headerlink" title="在 VSCode 里面安装Python扩展工具"></a><strong>在 VSCode 里面安装Python扩展工具</strong></h5><p>首先确保我们的机器上面已经安装好了<code>Python</code>环境，如果没有安装，<a href="http://fulade.me/2020/10/04/windows-install-python-1-1/">可参考我的另一篇教程来安装Python环境</a>，步骤很简单。<br>然后我们打开已经安装好的VSCode，找到 <code>Extensions</code>并点击(或使用快捷键<code>Ctrl+Shift+X</code>来打开)。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_extensions_tag.png" alt="2020_10_17_vscode_extensions_tag"><br>在弹出的输入框中 输入<code>Python</code>并搜索，出现的第一个结果我们直接点击<code>Install</code>就可以了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_extensions_search.png" alt="2020_10_17_vscode_extensions_search"><br>等待Install结束后，也就安装好了。</p><h5 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a><strong>测试安装是否成功</strong></h5><p>我们新建名为<code>hello_world.py</code>的文件，写入如下一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后点击右上角的<code>绿色三角按钮</code>运行，看到有控制台输出<code>hello world!</code>就代表我们安装成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_run.png" alt="2020_10_17_vscode_run"></p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=712535982&bvid=BV1KD4y197PB&cid=247590406&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-3】Python的第一个程序 Hello World</title>
      <link href="/python-run-helloword-1-3.html"/>
      <url>/python-run-helloword-1-3.html</url>
      
        <content type="html"><![CDATA[<h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a><strong>Hello World</strong></h5><p>“Hello, World!” 程序是一个经典的，确立已久的传统电脑程序。”Hello, World!” 因为能展示一个语言的基本句法，因此常被用作初学者的第一个”简单但完整”的程序，并可以被用来测试编程环境。</p><p>下面我们将写出Python中的”Hello, World!”程序，并使用两种方式运行它。</p><p><a href="http://fulade.me/2020/10/20/python-run-helloword-1-3/">文章首发地址</a></p><h5 id="书写-Hello-World程序"><a href="#书写-Hello-World程序" class="headerlink" title="书写 Hello World程序"></a><strong>书写 Hello World程序</strong></h5><p>首先我们打开VSCode，新建一个文件，想必大家也都知道了，<code>Python</code>的输出语句非常简单，我们只需要在新建的文件中写入如下一行代码就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后使用快捷键<code>Ctrl+S</code>保存文件到<code>桌面</code>，文件名我们就命名为<code>hello_world.py</code>这样我们的Hello World程序就写完了！是不是很简单！</p><h5 id="使用-VSCode运行-hello-world-py"><a href="#使用-VSCode运行-hello-world-py" class="headerlink" title="使用 VSCode运行 hello_world.py"></a><strong>使用 VSCode运行 hello_world.py</strong></h5><p>然后点击右上角的<code>绿色三角按钮</code>运行，看到有控制台输出<code>hello world!</code>，我们的程序运行成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_vscode_run.png" alt="2020_10_17_vscode_run"></p><h5 id="使用命令行运行-hello-world-py"><a href="#使用命令行运行-hello-world-py" class="headerlink" title="使用命令行运行 hello_world.py"></a><strong>使用命令行运行 hello_world.py</strong></h5><p>我们打开<code>Windows PowerShell</code>，输入<code>cd .\Desktop</code> 按回车，这样就进入到<code>hello_world.py</code>所在的文件夹，接着再输入<code>python.exe .\hello_world.py</code><br>看到有输出<code>hello world!</code>，我们用命令行工具也运行成功了！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_17_command_run.png" alt="2020_10_17_command_run"></p><h5 id="两种运行方式的使用场景"><a href="#两种运行方式的使用场景" class="headerlink" title="两种运行方式的使用场景"></a><strong>两种运行方式的使用场景</strong></h5><p>其实在日常工作中，我个人就是使用VSCode来开发，所以也是使用VSCode来运行和调试Python程序的，这样简单也方便，直接使用快捷键运行一下就可以了。<br>但是当我们的Python程序需要部署在一台没有安装任何IDE工具的机器上的时候，这个时候我们就可以使用命令行来启动我们的Python程序来运行。<br>同样的，当其他脚本想启动我们的Python程序的时候，大多数情况也是通过命令行工具来运行的。</p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a><strong>视频教程</strong></h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=800034187&bvid=BV1My4y187ov&cid=247600869&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-4】Windows下VSCode配置Flutter开发环境</title>
      <link href="/windows-vscode-flutter-1-4.html"/>
      <url>/windows-vscode-flutter-1-4.html</url>
      
        <content type="html"><![CDATA[<h5 id="VSCode是什么"><a href="#VSCode是什么" class="headerlink" title="VSCode是什么"></a><strong>VSCode是什么</strong></h5><p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。VSCode同样支持Flutter开发，在我的日常开发中会更多的使用VSCode，而不是Android Studio。</p><h5 id="下载和安装VSCode"><a href="#下载和安装VSCode" class="headerlink" title="下载和安装VSCode"></a><strong>下载和安装VSCode</strong></h5><p>打开<a href="https://code.visualstudio.com/">VSCode官方网站</a><br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_download_vscode.png" alt="2020_10_09_download_vscode"><br>下在完成后双击<code>exe</code>文件进行安装并打开。<br>打开后找到<code>Extensions</code>或使用快捷键<code>Ctrl+Shift+X</code>打开扩展中心。<br>在扩展中心输入<code>flutter</code>，显示的第一个便是我们要安装的Flutter扩展程序，点击安装。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_flutter.png" alt="2020_10_09_vscode_flutter"></p><h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a><strong>新建项目</strong></h5><p>安装完成之后依次点击<code>View</code>-&gt;<code>Command Palette...</code>(或者是使用快捷键<code>Ctrl+Shift+P</code>)<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_command.png" alt="2020_10_09_vscode_command"><br>在弹出的输入框中输入关键字<code>flutter</code>然后回车，选择项目要保持的目录，输入项目名称就可以了。<br><img src="https://cdn.jsdelivr.net/gh/Johnson8888/blog_pages/images/2020_10_09_vscode_new_flutter.png" alt="2020_10_09_vscode_new_flutter"><br>注意：创建项目完成之后，VSCode会帮助我们来安装<code>Dart</code>语言相关的依赖。<br>这样我们在VSCode下配置Flutter环境就算完成了。</p><h5 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=287403050&bvid=BV1gf4y1B7yJ&cid=245689967&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-3】在VMWare Android Studio 安装模拟器报错 Your CPU does not support VT-x</title>
      <link href="/not-support-vt-x.html"/>
      <url>/not-support-vt-x.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://fulade.me/2020/10/08/not-support-vt-x/">文章首发地址</a></p><h4 id="出现这个问题的原因"><a href="#出现这个问题的原因" class="headerlink" title="出现这个问题的原因"></a><strong>出现这个问题的原因</strong></h4><p>Android模拟器需要计算器的处理器必须支持以下虚拟化扩展技术之一：</p><ul><li>Intel 虚拟化技术（VT、VT-x 和 vmx）扩展</li><li>AMD 虚拟化（AMD-V 和 SVM）扩展</li></ul><p>大部分处理器都会支持，这里就以Intel处理器为例。</p><h4 id="在BOIS内开启"><a href="#在BOIS内开启" class="headerlink" title="在BOIS内开启"></a><strong>在BOIS内开启</strong></h4><p>如果之前没有开启过虚拟化，需要我们进入到BIOS开启，各个主板进入BIOS的方式不同，这里就不一一列举了。</p><h4 id="编辑VMWare-虚拟机配置"><a href="#编辑VMWare-虚拟机配置" class="headerlink" title="编辑VMWare 虚拟机配置"></a><strong>编辑VMWare 虚拟机配置</strong></h4><p>打开<code>VMware Workstation Pro</code>，找到要编辑的虚拟机，依次点击<code>编辑虚拟机</code>-&gt;<code>处理器</code>-&gt;<code>虚拟化 Intel VT-x/EPT 或 AMD V/RVI(V)</code><br><img src="https://raw.githubusercontent.com/Johnson8888/blog_pages/master/images/2020_10_08_vt-x.png" alt="2020_10_08_vt-x"><br>编辑后保持一下，重启虚拟机就可以了。</p><h4 id="HAXM-is-not-installed"><a href="#HAXM-is-not-installed" class="headerlink" title="HAXM is not installed"></a><strong>HAXM is not installed</strong></h4><p>接下来在安装模拟器的时候还有可能会遇到<code>HAXM is not installed</code>错误<br>这里就直接点击下面的 <code>Install Haxm</code>就可以了！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 1-1】Windows 10 安装Python3环境</title>
      <link href="/windows-install-python-1-1.html"/>
      <url>/windows-install-python-1-1.html</url>
      
        <content type="html"><![CDATA[<p>[收看视频教程的拖到文章末尾查看]</p><h4 id="Windows-10-安装Python3环境"><a href="#Windows-10-安装Python3环境" class="headerlink" title="Windows 10 安装Python3环境"></a>Windows 10 安装Python3环境</h4><h5 id="1-首先打开Python-官网"><a href="#1-首先打开Python-官网" class="headerlink" title="1. 首先打开Python 官网"></a>1. 首先打开Python <a href="https://www.python.org/">官网</a></h5><h5 id="2-在官网的主页找到-Downloads选项并点击"><a href="#2-在官网的主页找到-Downloads选项并点击" class="headerlink" title="2. 在官网的主页找到 Downloads选项并点击"></a>2. 在官网的主页找到 <code>Downloads</code>选项并点击</h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/Inked2020_10_4_python_org_LI.jpg" alt="python_org"></p><h5 id="3-找到-Windows选项-并点击-Python3-8-5即可下载Python3安装包"><a href="#3-找到-Windows选项-并点击-Python3-8-5即可下载Python3安装包" class="headerlink" title="3. 找到 Windows选项 并点击 Python3.8.5即可下载Python3安装包"></a>3. 找到 <code>Windows</code>选项 并点击 <code>Python3.8.5</code>即可下载Python3安装包</h5><p>由于官方在不断更新和维护，所以这里不一定是恰好是<code>Python3.8.5</code>，选择自己想安装的版本即可<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/Inked2020_10_4_select_windows_LI.jpg" alt="windows"><br>然后等待安装文件下载完成</p><h5 id="4-开始安装"><a href="#4-开始安装" class="headerlink" title="4. 开始安装"></a>4. 开始安装</h5><p>双击我们下载好的<code>python-3.8.5-amd64.exe</code>文件<br>我们选择<code>Customize installation</code>并且勾选<code>Add Python 3.8 to PATH</code>，勾选这个选项的目的是将Python直接添加到环境变量中，便于使用。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_add_python.jpg" alt="custom_install"></p><h5 id="5-安装成功提示"><a href="#5-安装成功提示" class="headerlink" title="5.安装成功提示"></a>5.安装成功提示</h5><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_install_success.jpg" alt="install_success"></p><h5 id="6-命令行测试安装是否完整"><a href="#6-命令行测试安装是否完整" class="headerlink" title="6.命令行测试安装是否完整"></a>6.命令行测试安装是否完整</h5><p>我们打开Windows 10 自带的命令行工具<code>Windows PowerShell</code>，然后在命令行输入 <code>python -V</code>看到能够输出版本号，就意味这我们的Python安装成功了。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_4_cmd.jpg" alt="cmd"></p><h5 id="7-视频教程"><a href="#7-视频教程" class="headerlink" title="7. 视频教程"></a>7. 视频教程</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=372253752&bvid=BV1JZ4y157u8&cid=243496843&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-1】8个Flutter的优势以及为什么要在下一个项目中尝试Flutter</title>
      <link href="/why-flutter-1-1.html"/>
      <url>/why-flutter-1-1.html</url>
      
        <content type="html"><![CDATA[<p>让我们一起来了解Flutter与其他跨平台框架的优势，以及这些优势在开发流程中的作用。</p><ul><li><h4 id="Flutter是什么"><a href="#Flutter是什么" class="headerlink" title="Flutter是什么"></a><a href="#jump1">Flutter是什么</a></h4></li><li><h4 id="Flutter的优势"><a href="#Flutter的优势" class="headerlink" title="Flutter的优势"></a><a href="#jump2">Flutter的优势</a></h4><ul><li><h5 id="1-跨平台使用相同的UI和业务逻辑"><a href="#1-跨平台使用相同的UI和业务逻辑" class="headerlink" title="1. 跨平台使用相同的UI和业务逻辑"></a><a href="#jump2_1">1. 跨平台使用相同的UI和业务逻辑</a></h5></li><li><h5 id="2-节省开发时间"><a href="#2-节省开发时间" class="headerlink" title="2. 节省开发时间"></a><a href="#jump2_2">2. 节省开发时间</a></h5></li><li><h5 id="3-更快的迭代速度"><a href="#3-更快的迭代速度" class="headerlink" title="3. 更快的迭代速度"></a><a href="#jump2_3">3. 更快的迭代速度</a></h5></li><li><h5 id="4-无限接近原生的交互体验"><a href="#4-无限接近原生的交互体验" class="headerlink" title="4. 无限接近原生的交互体验"></a><a href="#jump2_4">4. 无限接近原生的交互体验</a></h5></li><li><h5 id="5-丰富的UI动画"><a href="#5-丰富的UI动画" class="headerlink" title="5. 丰富的UI动画"></a><a href="#jump2_5">5. 丰富的UI动画</a></h5></li><li><h5 id="6-独立的渲染引擎"><a href="#6-独立的渲染引擎" class="headerlink" title="6. 独立的渲染引擎"></a><a href="#jump2_6">6. 独立的渲染引擎</a></h5></li><li><h5 id="7-能够很容易与原生进行交互"><a href="#7-能够很容易与原生进行交互" class="headerlink" title="7. 能够很容易与原生进行交互"></a><a href="#jump2_7">7. 能够很容易与原生进行交互</a></h5></li><li><h5 id="8-不只是能运行在移动端"><a href="#8-不只是能运行在移动端" class="headerlink" title="8. 不只是能运行在移动端"></a><a href="#jump2_8">8. 不只是能运行在移动端</a></h5></li></ul></li><li><h4 id="从业务层来看，Flutter是一个好的选择吗？"><a href="#从业务层来看，Flutter是一个好的选择吗？" class="headerlink" title="从业务层来看，Flutter是一个好的选择吗？"></a><a href="#jump3">从业务层来看，Flutter是一个好的选择吗？</a></h4></li><li><h4 id="为什么要尝试使用Fultter"><a href="#为什么要尝试使用Fultter" class="headerlink" title="为什么要尝试使用Fultter?"></a><a href="#jump4">为什么要尝试使用Fultter?</a></h4></li></ul><h4 id="Flutter是什么-1"><a href="#Flutter是什么-1" class="headerlink" title="Flutter是什么"></a><span id="jump1">Flutter是什么</span></h4><p>就我目前的职业开发生涯中，目睹了太多太多项目不知道该选择哪种跨平台方案的例子。这些项目都是不同的，但是我们都希望这些项目能够运行在更多平台和更多设备上，常见的作法就是在不同的客户端招聘不同的开发人员来进行开发工作，比如手机端有iOS程序员和Android程序员等等。<br>我记得在2013年，我第一次看到了比较完善的跨平台游戏开发方案，那时候我就在想，为什么App端没有这种工具可以满足我们跨平台的需求呢？<br>但是，现在我们有了，它就是Flutter！我将在下面介绍我使用Flutter做了些什么，希望能对你有所帮助或启发。<br>我有过一些iOS开发经验，也有过一些游戏开发经验，可以说Flutter就是我一直在寻找的跨平台解决方案。它不仅使用简单，还能保持跨平台UI的一致性时，并且很容易的与原生进行交互。是非常好的体验。</p><h4 id="Flutter的优势-1"><a href="#Flutter的优势-1" class="headerlink" title="Flutter的优势"></a><span id="jump2">Flutter的优势</span></h4><p>你之前可能会了解到，所有的跨平台框架都会在节约开发时间上有所帮助。但是，Flutter在有些地方跟其他框架有很多不同，让我们来看看，究竟Flutter比其他跨平台框架在哪些地方做的更好。</p><h5 id="1-跨平台使用相同的UI和业务逻辑-1"><a href="#1-跨平台使用相同的UI和业务逻辑-1" class="headerlink" title="1. 跨平台使用相同的UI和业务逻辑"></a><span id="jump2_1">1. 跨平台使用相同的UI和业务逻辑</span></h5><p>我们知道，基本上所有的跨平台框架都提供了一种在目标平台之间共享代码的实现方式。但是没有任何一个平台像Flutter这样允许共享UI代码以及UI本身。<br>为了说明这一点，下面我们来看一下其中一个跨平台框架UI的实现逻辑：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_09_30_other_paltform.png" alt="2020_09_30_other_paltform"><br>React Navite 的渲染过程看起来像是在每个平台上都很简单。但是从图中我们不难发现，这种渲染过程需要依然各个平台原生组件来进行渲染，React Native 就是帮我们实现了对各个平台应用层UI控件的映射。这就需要将每个动画每个UI映射到各个平台的动画和UI上，显然这比较繁琐。<br>相比之下，Flutter不需要依赖热任何平台的UI组件就能生成UI界面。Flutter唯一需要的就是一个画布，也就是我们常说的Canvas。<br>下面是Flutter的渲染过程:<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_09_30_flutter_canvas.png" alt="2020_09_30_flutter_canvas"><br>Flutter能够在任何平台上构建完全一模一样的的UI，这种独特的渲染方式是它脱颖而出的关键。<br>简而言之，使用Flutter来实现UI和业务逻辑能够节省时间和精力，并且同时不影响最终产品的性能。原来iOS、Android需要每个平台都要配备相应的程序员，使用Flutter只需要一组程序员就可以了，还节省了程序员！</p><h5 id="2-节省开发时间-1"><a href="#2-节省开发时间-1" class="headerlink" title="2. 节省开发时间"></a><span id="jump2_2">2. 节省开发时间</span></h5><p>依据我个人的开发经验，从编译到运行一个Android App至少需要40秒的时间。同时，在调试UI的过程中需要不停的编译和运行，这就需要消耗大量的时间。诚然，Android Studio是具有布局预览功能的，但是总有一点不足的是：Android Studio 不能每次都像预期那样运行，特别是在自定义View的时候。<br>Flutter的 “热重载”功能可以让我们实时看到应用的变化，并且不会丢失当前应用程序的状态。这就是使用Flutter节省开发时间的根本原因。<br>此外，Flutter团体还付出了很多努力来提供各种控件。这些控件大多数都可以自定义，这就在构建UI上给我们节省了不少时间。除了众多的核心控件外，Flutter还提供了大量的Material(Android风格)和Cupertino(iOS风格)的控件可以满足不同的设计风格。<br>如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_09_30_services.png" alt="2020_09_30_services"><br>总而言之，使用Flutter来开发，我们可以绕过几个程序开发过程中比较耗时的步骤，这样使整个开发过程更快，更简单且更省心。</p><h5 id="3-更快的迭代速度-1"><a href="#3-更快的迭代速度-1" class="headerlink" title="3. 更快的迭代速度"></a><span id="jump2_3">3. 更快的迭代速度</span></h5><p>使用Flutter来开发迭代产品会更快。在大多数情况下，我们研发一个App需要Android端和iOS端都需要进行开发和维护，而Flutter只要一组人员就可以完成这个任务。在开发时间上至少节省了一倍。原因很简单，我们只需要编写一套代码就可以得到在各个应用平台相同的交互效果。任何基于2D的UI都可以在Flutter中实现，且不需要调用原生代码。<br>除此之外，Flutter使用声明式语法构建UI，根据我的经验，它可以显著提高开发速度。当涉及到UI效果调整时这是最明显的。</p><h5 id="4-无限接近原生的交互体验-1"><a href="#4-无限接近原生的交互体验-1" class="headerlink" title="4. 无限接近原生的交互体验"></a><span id="jump2_4">4. 无限接近原生的交互体验</span></h5><p>我们知道，App的性能是好的用户体验的关键。<br>尽管很难说出确切的数字，但是可以肯定地说，在大多数情况下，Flutter应用程序的性能与本机应用程序没有区别，甚至在复杂的UI动画场景中表现的更好。<br>为什么呢？与大多数跨平台框架不同的是，Flutter不依赖任何中间代码做映射。Flutter应用直接调用了底层代码，这就极大的提高了性能。<br>我们同样可以使用Flutter完全编译和发布应用程序。</p><h5 id="5-丰富的UI动画-1"><a href="#5-丰富的UI动画-1" class="headerlink" title="5. 丰富的UI动画"></a><span id="jump2_5">5. 丰富的UI动画</span></h5><p>Flutter的一个最大的优势就是可以随时修改屏幕上的任何控件，无论这个控件有多复杂。同样也支持直接使用原生控件来做UI动画。<br>下面是一个简单的自定义动画的示例：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_09_30_animate.png" alt="2020_09_30_animate"><br>同样的，使用Flutter生成动画更加灵活和通用，并且不会额外增加工作量。过渡动画、圆角、颜色、阴影、变换等，Flutter都能轻松实现。<br><a href="https://itsallwidgets.com/">这里</a>给大家提供更多的Demo。让我们更好的熟悉这些动画。</p><h5 id="6-独立的渲染引擎-1"><a href="#6-独立的渲染引擎-1" class="headerlink" title="6. 独立的渲染引擎"></a><span id="jump2_6">6. 独立的渲染引擎</span></h5><p>与其他框架相比，Flutter应有更多的能力。显然，这需要框架本身非常强大，且需要框架本身是一个高性能的框架。<br>Flutter是使用<a href="https://github.com/google/skia">Skia</a>作为底层的渲染引擎。有了Skia的支持，UI层可以在任何平台上进行渲染，且保持一致性。换句话说，我们不需要调整任何代码就可以将UI呈现在其他平台上，这极大的简化了开发过程。</p><h5 id="7-能够很容易与原生进行交互-1"><a href="#7-能够很容易与原生进行交互-1" class="headerlink" title="7. 能够很容易与原生进行交互"></a><span id="jump2_7">7. 能够很容易与原生进行交互</span></h5><p>除了UI之外，我们还有很多功能需要依赖原生的支持，比如获取GPS信息，蓝牙通信，传感器，照相机，相册等等。这些功能都可以通过Flutter的插件来实现。<br>当然有些时候这些插件也是不足以满足我们的需求。但是不用担心，Flutter使用的开发语言（Dart语言）与原生代码通信非常简单。只需要几行代码我们就可以实现原生与Flutter之间的交互，就可以实现任何你想调用原生功能的需求。<br>交互流程如下图：<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_09_30_channel.png" alt="2020_09_30_channel"></p><h5 id="8-不只是能运行在移动端-1"><a href="#8-不只是能运行在移动端-1" class="headerlink" title="8. 不只是能运行在移动端"></a><span id="jump2_8">8. 不只是能运行在移动端</span></h5><p>Flutter不仅是可以在移动设备上使用，还支持Web端和桌面端。在2018年的I / O会议上，Google展示了Flutter Web的技术，这使得在浏览器中运行纯Flutter应用程序成为可能，且不需要修改任何源代码。<br>下面是演示视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=927277621&bvid=BV1iT4y1c71E&cid=241986005&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><p>不能打开视频的可以点击<a href="https://www.bilibili.com/video/BV1iT4y1c71E/">这里</a>查看<br>官方的这一操作，意味着Flutter从移动开发框架升级到了全平台开发框架的行列。<br>如果我们不需要在移动端做部署和使用，技术娴熟的Flutter程序员可以让Flutter在热门平台上运行，包括但不限于Android、iOS、Web浏览器、Windows、macOS、Linux甚至是嵌入式设备。同样的代码可以在这些任何平台上运行，且不需要修改任何Dart代码。</p><h4 id="从业务层来看，Flutter是一个好的选择吗？-1"><a href="#从业务层来看，Flutter是一个好的选择吗？-1" class="headerlink" title="从业务层来看，Flutter是一个好的选择吗？"></a><span id="jump3">从业务层来看，Flutter是一个好的选择吗？</span></h4><p>是的！是的！是的！<br>软件产品能保证性能和稳定性、人员容易招聘、产品能够快速的迭代和开发这些优势都能够给企业带来巨大的价值。一旦技术方案出现缺陷和存在任何方面的问题，都会给企业带来直接或间接的损失。<br>从这个角度来看，Flutter都是可以降低我们的风险的：</p><ul><li>目前Google正在研发<a href="https://www.techradar.com/news/google-fuchsia">Fuchsia OS</a>(与Flutter配合使用)，因此Flutter会继续投入研发人员维护和升级，不会中断。</li><li>使用Flutter的门槛并不高，因为社区中已经有了很多的人气很高的Android开发人员都在提倡和使用Flutter。</li><li>已经有很多大公司在使用，例如：阿里巴巴，Google Ads，AppTree，Reflectly和My Leaf等等，这是Flutter实力的证明。</li></ul><h4 id="为什么要尝试使用Fultter-1"><a href="#为什么要尝试使用Fultter-1" class="headerlink" title="为什么要尝试使用Fultter?"></a><span id="jump4">为什么要尝试使用Fultter?</span></h4><p>让我们总结一下Flutter的最突出优点：</p><ul><li>UI和业务逻辑代码在各个平台呈现效果一直</li><li>更快的开发速度</li><li>更快的迭代速度和更快的上线速度</li><li>无限接近原生的交互体验</li><li>更容易的自定UI和动画功能</li><li>独立的渲染引擎</li><li>不依赖于任何平台的UI组件</li><li>适用于更多的平台</li><li>商业风险控制在最小</li></ul><p>所以说，想开发跨平台的，性能优良的应用，Flutter是不二选择。Flutter正式成为最终的跨平台UI框架只是时间问题。</p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Flutter 1-2】在 Windows 10下配置Flutter开发环境</title>
      <link href="/windows-install-flutter.html"/>
      <url>/windows-install-flutter.html</url>
      
        <content type="html"><![CDATA[<h4 id="在-Windows-10下安装Flutter-Dart-Android-Studio-配置Flutter开发环境"><a href="#在-Windows-10下安装Flutter-Dart-Android-Studio-配置Flutter开发环境" class="headerlink" title="在 Windows 10下安装Flutter+Dart+Android Studio 配置Flutter开发环境"></a><strong>在 Windows 10下安装Flutter+Dart+Android Studio 配置Flutter开发环境</strong></h4><p><a href="https://johnson8888.github.io/2020/09/28/windows-install-flutter/">文章首发地址</a></p><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h5><p>由于部分网站被墙的原因，我们需要先配置Flutter国内镜像地址，这两个地址是由Flutter官方维护的，可以放心使用<br>首先我们找到<code>此电脑</code>点击右键，然后点击<code>属性</code></p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_my_computer.png" alt="2020_10_07_my_computer"></p><p>然后点击<code>高级系统设置</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_heigh_setting.png" alt="2020_10_07_heigh_setting"></p><p>点击<code>高级</code>然后找到下面的<code>环境变量</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_huanjingbianliang.png" alt="2020_10_07_huanjingbianliang"><br>点击<code>新建</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_xinjian.png" alt="2020_10_07_xinjian"><br>变量名输入<code>PUB_HOSTED_URL</code> 变量值输入 <code>https://pub.flutter-io.cn</code> 然后点击<code>确定</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_input_pub.png" alt="2020_10_07_input_pub"><br>继续点击 <code>新建</code><br>变量名输入<code>FLUTTER_STORAGE_BASE_URL</code> 变量值输入 <code>https://storage.flutter-io.cn</code> 然后点击<code>确定</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_input_storage.png" alt="2020_10_07_input_storage"><br>到这里需要的环境变量就配置完成了</p><h5 id="开始安装Flutter"><a href="#开始安装Flutter" class="headerlink" title="开始安装Flutter"></a><strong>开始安装Flutter</strong></h5><ul><li><p>下载安装文件并解压缩<br><a href="https://flutter.dev/docs/development/tools/sdk/releases">点击进入官网下载需要的版本</a><br>如果不能打开该网站，<a href="https://pan.baidu.com/s/1SgNz14eVc1SDlHlTH7Y0mA">可去我的网盘去取版本是1.22.0</a> 提取码: awjy<br>下载完成后在新建一个文件夹解压缩，我这里选的是<code>C:\src\flutter</code><br>解压成功之后，我们需要将Flutter也配置到环境变量中，flutter文件夹下的<code>bin</code>目录路径(我这里是<code>C:\src\flutter\bin</code>)配置到环境变量中。打开配置环境变量的步骤参考 上面的步骤<code>配置环境变量</code><br>双击<code>Path</code>来添加<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_find_pth.png" alt="2020_10_07_find_pth"><br>将<code>C:\src\flutter\bin</code>配置进去<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_flutter_path.png" alt="2020_10_07_flutter_path"></p></li><li><p>运行 flutter doctor<br>将路径配置之后我们打开 终端工具<code>PowerShell</code> 输入 <code>flutter doctor</code>查看还有哪些需要配置。<code>flutter doctor</code>是Flutter官方提供的用来检测当前Flutter配置环境的工具，可以快速的帮我们发现问题。<br>运行之后我们会看到输出如下:<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_flutter_doctor_1.png" alt="2020_10_07_flutter_doctor_1"></p></li></ul><p>很明显我们还需要安装 <code>Android Studio</code>，Andriod Studio是Flutter官方支持的IDE工具。<br><a href="https://developer.android.com/studio">去Andriod Studio 官网下载</a>下载完成后，一路Next安装完成，然后启动Android Studio，第一次安装默认会安装很多依赖，这个等慢慢安装就可以了。<br>启动之后点击<code>File</code>-&gt;<code>Settings</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_settings.png" alt="2020_10_07_android_studio_settings"></p><p>找到<code>Plugins</code>在输入框内输入<code>Flutter</code>点击安装<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_andriod_studio_install_flutter.png" alt="2020_10_07_andriod_studio_install_flutter"><br>安装<code>Flutter</code>的时候默认会要求安装<code>Dart</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_install_dart.png" alt="2020_10_07_android_studio_install_dart"><br>安装后重启 <code>Andriod Studio</code></p><p>然后我们把<code>Android SDK</code>路径配置到系统变量里面<br>我们先找到<code>File</code>-&gt;<code>Other Settings</code>-&gt;<code>Default Project Structure..</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_sdk.png" alt="2020_10_07_android_sdk"><br>找到SDK的路径<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_sdk_path.png" alt="2020_10_07_android_sdk_path"><br>进入到文件下找到SDK文件夹有一个<code>platform-tools</code>的文件夹，复制这个路径添加到系统<code>Path</code>中<br>变量名是<code>ANDROID_HOME</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_adroid_home.png" alt="2020_10_07_adroid_home"></p><p>这时候我们再执行一次 <code>flutter doctor</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_doctor_error.png" alt="2020_10_07_doctor_error"><br>现在我们只需要再执行一次 <code>flutter doctor --android-licenses</code> 弹出的提示选择<code>y</code>或者是直接<code>回车</code>即可。<br>然后再运行一次<code>flutter doctor</code>已经没有错误提示了。<br>这样我们的Flutter的环境就配置完成了。</p><h5 id="安装Android-模拟器"><a href="#安装Android-模拟器" class="headerlink" title="安装Android 模拟器"></a><strong>安装Android 模拟器</strong></h5><p>打开Android Studio 找到右上角的<code>AVD Manager</code>并点击<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_android_studio_avd_manager.png" alt="2020_10_07_android_studio_avd_manager"></p><p>点击<code>Create Virtual Device...</code> 选择一个我们需要需要安装的模拟器，然后点击<code>Next</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_select_device.png" alt="2020_10_07_select_device"><br>在配置页面选择<code>Hardware - GLES 2.0</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_hardware_gles.png" alt="2020_10_07_hardware_gles"></p><h5 id="新建Flutter项目并运行"><a href="#新建Flutter项目并运行" class="headerlink" title="新建Flutter项目并运行"></a><strong>新建Flutter项目并运行</strong></h5><p>点击Android Studio 里面的 <code>File</code>-&gt;<code>New</code>-&gt;<code>New Flutter Project</code><br>新建项目并打开<br>选择我们刚刚安装好的模拟器，并且点击运行 就可以看到效果啦！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_runing.png" alt="2020_10_07_runing"></p><h5 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a><strong>可能会遇到的问题</strong></h5><p>在执行 <code>flutter doctor --android-licenses</code>出现以下错误<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_fluuter_sdk_error.png" alt="2020_10_07_fluuter_sdk_error"><br>需要我们手动安装<code>Android SDK Platform-Tools</code><br>打开Android Studio 点击<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Android SDK</code>找到<code>Android SDK Platform-Tools</code>安装即可！<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/2020_10_07_error_platform_tools.png" alt="2020_10_07_error_platform_tools"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/page_footer.jpg" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下使用GitHub+Hexo搭建个人博客</title>
      <link href="/how-to-set-up-hexo-blog.html"/>
      <url>/how-to-set-up-hexo-blog.html</url>
      
        <content type="html"><![CDATA[<p>开始之前需要在电脑上安装好<a href="https://git-scm.com/">Git</a>和<a href="https://nodejs.org/en/">node.js</a>，Mac上可以使用Homebrew命令行工具来安装Git和node.js</p><h5 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a><strong>安装Homebrew</strong></h5><p>在命令行工具输入以下命令，如果已经安装过Homebrew可以忽略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><h5 id="Homebrew-安装-node-js"><a href="#Homebrew-安装-node-js" class="headerlink" title="Homebrew 安装 node.js"></a><strong>Homebrew 安装 node.js</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装后可以使用命令来检查是否安装成功<br>检查node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v12.14.1</span><br></pre></td></tr></table></figure><p>检查<a href="https://www.npmjs.com/">npm</a>是否安装成功，npm是node.js的包管理工具，用它来安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.13.4</span><br></pre></td></tr></table></figure><h5 id="Homebrew-安装git"><a href="#Homebrew-安装git" class="headerlink" title="Homebrew 安装git"></a><strong>Homebrew 安装git</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>检查git是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">``` </span><br><span class="line">输出结果:</span><br><span class="line">``` bash</span><br><span class="line">git version 2.24.3 (Apple Git-128)</span><br></pre></td></tr></table></figure><h5 id="使用-npm-安装-hexo"><a href="#使用-npm-安装-hexo" class="headerlink" title="使用 npm 安装 hexo"></a><strong>使用 npm 安装 <a href="https://hexo.io/zh-cn/docs/">hexo</a></strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br><span class="line">``` </span><br><span class="line">安装完成后，在Desktop创建一个blog文件夹，在该文件夹下初始化我们的博客</span><br><span class="line">``` bash</span><br><span class="line"><span class="built_in">cd</span> ~/Desktop &amp;&amp; mkdir blog &amp;&amp; <span class="built_in">cd</span> blog</span><br><span class="line">``` </span><br><span class="line">在该文件件目录下执行博客初始化操作</span><br><span class="line">``` bash</span><br><span class="line"><span class="comment"># 会下载一些node.js的依赖文件</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化成功后，在blog目录下执行预览操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo s </span><br><span class="line">``` </span><br><span class="line">当看到如下输出就可以预览我们创建的博客了</span><br><span class="line">``` bash</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. </span><br></pre></td></tr></table></figure><p>预览效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/preview_hexo_20200928.jpg" alt="preview_hexo_20200928"></p><h5 id="配置客户端git-添加SSH-Key到github"><a href="#配置客户端git-添加SSH-Key到github" class="headerlink" title="配置客户端git  添加SSH Key到github"></a><strong>配置客户端git  添加SSH Key到github</strong></h5><p>如果已经配置过，该步骤可以忽略<br>在命令行输入配置用户名和账号的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>其中 <code>username</code> 是你的用户名，<code>email@gmail.com</code>是你github的登录邮箱<br>然后通过终端命令生成SSH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>如果已经创建过会出现 <code>Overwrite (y/n)? n</code>提示可以输入 <code>n</code>，如果没有创建过会要求我们输入密码，然后一路回车下去就行，执行完成后会在<code>~/.ssh/id_rsa.pub</code>目录下生成 需要使用的 key。</p><p>可以使用命令行输出key并复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者可以找到这个文件并打开它，复制里面的内容。</p><p>登录github账号 找到 <code>setting</code><br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/setting_20200928.png" alt="setting_20200928"></p><p>先点击 <code> SSH and GPG keys</code> 然后再点击 <code>New SSH key</code> 进入到配置 SSH Key 的页面<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/select_sshkey_20200928.jpg?token=ABHYKC5WITD7CZYQDC4ABAK7OFO3W" alt="select_sshkey_20200928"></p><p>然后输入复制好的key的内容</p><p><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/set_my_pc_ssh_key_20200928.png?token=ABHYKC4PWIEGG63VBN3Q3NS7OFPEC" alt="set_my_pc_ssh_key_20200928"></p><p>点击 <code>Add SSH Key</code> 即可</p><h5 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a><strong>本地博客关联到Github主页</strong></h5><p>登录Github并且创建一个名字为 <code>username.githug.io</code> 的仓库，比如我的仓库名字为 <code>Johnson8888.github.io</code><br>因为我已经创建过了，所以会显示红色，如果创建过，会显示绿色的，然后点击创建。切记一定要选择 <code>Public</code>，否定不能访问。<br><img src="https://cdn.jsdelivr.net/gh/johnson8888/blog_pages/images/create_my_repo_20200928.png?token=ABHYKCYY4HSYNU4W6VVG5Q27OFPVO" alt="create_my_repo_20200928"></p><p>然后命令行切换到本地blog目录下 <code>cd ~/Desktop/blog</code><br>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后开始修改配置文件 <code>~/Desktop/blog/_config.yml</code><br>修改 <code>deploy</code>部分为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:Johnson8888/Johnson8888.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后就可以把博客push到github了<br>在命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成我们想要的博客文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment">#将本地的博客文件push到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><code>hexo d </code>执行成功后，就可以查看我们的<a href="https://johnson8888.github.io/">Blog</a>了</p><h5 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a><strong>开始写博客</strong></h5><p>在命令行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new firstPage.md </span><br></pre></td></tr></table></figure><p>会在 <code>~/Desktop/blog/source/_post</code>目录下生成 <code>firstPage.md</code> 打开这个文件就可以开心的写博客了<br>写完后重新执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>就可以同步博客到github</p><h4 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a><strong>Todo</strong></h4><ul><li>申请域名指向博客，这样就可以直接使用域名访问了</li><li>hexo支持很多模板样式 可以去<a href="https://hexo.io/themes/">官网</a>选择自己喜欢的使用</li></ul><h5 id="附-hexo常用命令"><a href="#附-hexo常用命令" class="headerlink" title="附 hexo常用命令"></a><strong>附 hexo常用命令</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  &#x3D;&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式</span><br><span class="line">hexo p  &#x3D;&gt; hexo publish</span><br><span class="line">hexo g  &#x3D;&gt; hexo generate  #生成</span><br><span class="line">hexo s  &#x3D;&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  &#x3D;&gt; hexo deploy  #部署  </span><br><span class="line"></span><br><span class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s   #静态模式</span><br><span class="line">hexo server -p 5000   #更改端口</span><br><span class="line">hexo server -i 192.168.1.1   #自定义IP</span><br><span class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g   #生成静态网页</span><br><span class="line">hexo d   #开始部署</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
